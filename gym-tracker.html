<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Gym Tracker">
    <meta name="theme-color" content="#000000">
    <!-- iOS 17+ optimizations -->
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-orientations" content="portrait,portrait-primary">
    <!-- Dynamic Island support hint -->
    <meta name="supported-color-schemes" content="dark light">
    <!-- Spatial Audio support -->
    <meta name="apple-audio-spatialization" content="allows">
    <!-- Action Button support (iPhone 15 Pro+) -->
    <meta name="apple-action-button-type" content="workout">
    <meta name="apple-action-button-title" content="Start Workout">
    <!-- Live Activities hint -->
    <meta name="apple-live-activities" content="workout-timer">
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiR3ltIFRyYWNrZXIgUHJvIiwic2hvcnRfbmFtZSI6Ikd5bSBUcmFja2VyIiwic3RhcnRfdXJsIjoiL2d5bS10cmFja2VyLmh0bWwiLCJzY29wZSI6Ii8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsIm9yaWVudGF0aW9uIjoicG9ydHJhaXQiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzAwMDAwMCIsInRoZW1lX2NvbG9yIjoiIzRBOTBFMiIsImxhbmciOiJubCIsImlzY2FwYWJsZl9hY3Rpb25zIjp0cnVlfQ==">
    <!-- Chart.js will be loaded from CDN with offline fallback -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <title> Gym Tracker Pro</title>
</head>
<script>
// Register Service Worker for offline support (only in secure contexts)
(function(){
  const isSecure = (window.isSecureContext && (location.protocol === 'https:' || location.hostname === 'localhost'));
  if ('serviceWorker' in navigator && isSecure) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('service-worker.js').then(registration => {
        console.log('✅ Service Worker registered:', registration.scope);
      }).catch(err => {
        console.warn('⚠️ Service Worker registration failed:', err);
      });
    });
  } else {
    // In file:// or non-secure contexts, skip SW to avoid SecurityError
    // console.info('ℹ️ Service Worker skipped: insecure context', { isSecure, protocol: location.protocol });
  }
})();
</script>
<body>
<!-- Console Log Overlay -->
<div id="console-log-overlay" style="display:none;position:fixed;bottom:0;left:0;right:0;max-height:40vh;overflow-y:auto;z-index:99999;background:rgba(18,18,18,0.95);color:#fff;font-size:13px;font-family:monospace;padding:8px 12px;border-top:2px solid #4A90E2;box-shadow:0 -2px 16px #000;pointer-events:auto;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
        <b>Console Log</b>
        <button onclick="document.getElementById('console-log-overlay').style.display='none'" style="background:#222;color:#fff;border:none;padding:2px 10px;border-radius:6px;">Sluiten</button>
    </div>
    <div style="font-size:11px;color:#ccc;margin-bottom:8px;">
        💡 Tip: Houd 0.5s ingedrukt op de pagina voor snelle console toegang<br>
        🔍 Test Haptic toont gedetailleerde diagnostiek voor vibratie problemen<br>
        📱 PWA installatie is vereist voor vibratie op iOS apparaten<br>
        🧪 Gebruik de test knoppen voor specifieke feedback types
    </div>
    <div style="display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap;">
        <button onclick="testHapticFeedback()" style="background:#4A90E2;color:#000;border:none;padding:6px 10px;border-radius:5px;font-size:12px;cursor:pointer;">Test Haptic</button>
        <button onclick="testDynamicIsland()" style="background:#2ECC71;color:#000;border:none;padding:6px 10px;border-radius:5px;font-size:12px;cursor:pointer;">Test Island</button>
        <button onclick="installPWA()" style="background:#E67E22;color:#000;border:none;padding:6px 10px;border-radius:5px;font-size:12px;cursor:pointer;">Install PWA</button>
        <button onclick="document.getElementById('console-log-content').innerHTML=''" style="background:#E74C3C;color:#fff;border:none;padding:6px 10px;border-radius:5px;font-size:12px;cursor:pointer;">Clear</button>
    </div>
    <div id="console-log-content"></div>
</div>
<button id="showConsoleLogBtn" onclick="document.getElementById('console-log-overlay').style.display='block'" style="position:fixed;bottom:12px;right:12px;z-index:99999;background:#4A90E2;color:#000;font-weight:bold;border:none;padding:8px 14px;border-radius:20px;box-shadow:0 2px 8px #000;display:none;">Log</button>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
}

:root {
    /* Base Colors - Professionele kleurstelling */
    --primary: #4A90E2;        /* Licht blauw als primaire kleur */
    --secondary: #7B7B7B;      /* Professioneel grijs */
    --tertiary: #B8B8B8;       /* Lichtere grijze accent */
    --danger: #E74C3C;         /* Professionele rode accent */
    --warning: #E67E22;        /* Professionele oranje accent */
    --purple: #9B59B6;         /* Professionele paarse accent */
    --success: #2ECC71;        /* Professionele groene accent */
    --gold: linear-gradient(135deg, #D4AF37, #FFD700); /* Professionele gouden accent */
    
    /* Dark Theme - Professionele zwarte basis */
    --dark: #121212;           /* Diep professioneel zwart */
    --dark-lighter: #1E1E1E;   /* Subtiel lichtere zwarte tint */
    --dark-card: #2A2A2A;      /* Professionele grijze kaarten */
    --dark-elevated: #3A3A3A;  /* Nog lichtere grijze elevated elementen */
    --text: #FFFFFF;           /* Wit voor optimale contrast */
    --text-muted: #B0B0B0;     /* Professionele grijze tekst */
    --border: #404040;         /* Subtiele grijze borders */
    --shadow: 0 8px 32px rgba(0,0,0,0.4); /* Professionele schaduwen */
    
    /* Light Theme - Professionele grijze basis */
    --light-bg: #F8F9FA;       /* Zeer licht grijze achtergrond */
    --light-card: #FFFFFF;     /* Zuiver wit voor kaarten */
    --light-elevated: #F1F3F4; /* Subtiel grijze elevated elementen */
    --light-text: #202124;     /* Donker professioneel grijs voor tekst */
    --light-text-muted: #5F6368; /* Professionele grijze muted tekst */
    --light-border: #C6C6C8;
    --light-shadow: 0 10px 40px rgba(0,0,0,0.1);
    
    /* Theme Transitions */
    --transition-fast: all 0.15s ease-out;
    --transition-normal: all 0.25s ease-out;
    --transition-slow: all 0.4s ease-out;
    
    /* Animations */
    --bounce-in: cubic-bezier(0.68, -0.55, 0.265, 1.55);
    --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
    --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
    --schema-accent: var(--primary);
    --schema-accent-2: var(--secondary);
}

/* Light Mode Colors */
body.light-mode {
    --dark: #FFFFFF;
    --dark-lighter: #F5F5F7;
    --dark-card: #FFFFFF;
    --dark-elevated: #F9F9FB;
    --text: #000000;
    --text-muted: #6B6B6F;
    --border: #D5D5D7;
    --shadow: 0 10px 40px rgba(0,0,0,0.1);
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background: var(--dark);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
    position: relative;
    padding-bottom: 100px;
}

/* iOS Safari standalone viewport fixes */
html { height: -webkit-fill-available; }
body { min-height: -webkit-fill-available; }

/* iOS 17+ Dynamic Island and notch support */
@supports (padding: max(0px)) {
    .header {
        padding-top: max(44px, env(safe-area-inset-top));
    }

    body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: max(34px, env(safe-area-inset-bottom));
    }

    /* Dynamic Island aware timer card */
    .timer-card {
        margin-top: max(10px, env(safe-area-inset-top, 10px));
    }
}

/* iOS 17+ enhanced haptic feedback simulation */
@media (prefers-reduced-motion: no-preference) {
    .btn:active {
        transform: scale(0.98);
        transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .schema-card:active {
        transform: scale(0.97) translateY(1px);
    }
}

/* Action Button support styling */
@media (device-width: 393px) and (device-height: 852px) { /* iPhone 15 Pro */
    .fab-add-exercise {
        bottom: 120px; /* Account for Action Button */
    }
}

@media (device-width: 430px) and (device-height: 932px) { /* iPhone 15 Pro Max */
    .fab-add-exercise {
        bottom: 120px;
    }
}

/* Prevent white flashes during load and show boot errors */
#boot-error-overlay {
    position: fixed;
    inset: 0;
    background: #000000;
    color: #FF3B30;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 24px;
    z-index: 9999;
}
#boot-error-overlay .content { max-width: 640px; text-align: center; }

body::before {
    content: "";
    position: fixed;
    inset: 0;
    background: radial-gradient(circle at 20% 50%, rgba(184, 230, 184, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 149, 0, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 50% 20%, rgba(175, 82, 222, 0.05) 0%, transparent 50%);
    pointer-events: none;
    z-index: 0;
    animation: bgMove 20s ease-in-out infinite;
}

@keyframes bgMove {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

@keyframes flash {
    0% { opacity: 0; }
    50% { opacity: 0.3; }
    100% { opacity: 0; }
}

.container {
    max-width: 100%;
    margin: 0 auto;
    padding: 1rem;
    position: relative;
    z-index: 1;
}

@media (max-width: 640px) {
    .container {
        padding: 0.5rem; /* Further reduce padding for mobile */
    }
}

/* Header Styles */
.header {
    position: sticky;
    top: 0;
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(30px) saturate(180%);
    z-index: 100;
    padding: 1rem;
    border-bottom: 1px solid var(--border);
    margin: -1rem -1rem 1.5rem -1rem;
}

.header-top {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}

h1 {
    font-size: 2rem;
    font-weight: 800;
    background: var(--gold);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: -0.5px;
}

.icon-group {
    display: flex;
    gap: 0.5rem;
}

.icon-btn {
    background: var(--dark-card);
    border: 1px solid var(--border);
    color: var(--text);
    width: 44px;
    height: 44px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.25rem;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.icon-btn::before {
    content: "";
    position: absolute;
    inset: 0;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    opacity: 0;
    transition: opacity 0.3s;
}

.icon-btn:active {
    transform: scale(0.92);
}

.icon-btn:active::before {
    opacity: 1;
}

.header-tabs {
    display: flex;
    gap: 0.5rem;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.header-tabs::-webkit-scrollbar {
    display: none;
}

.tab {
    padding: 0.5rem 0.875rem;
    border-radius: 20px;
    background: var(--dark-card);
    color: var(--text-muted);
    border: 1px solid var(--border);
    cursor: pointer;
    white-space: nowrap;
    font-weight: 600;
    font-size: 0.8rem;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.tab::before {
    content: "";
    position: absolute;
    inset: 0;
    background: var(--primary);
    opacity: 0;
    transition: opacity 0.3s;
}

.tab.active {
    background: var(--primary);
    color: var(--dark);
    border-color: var(--primary);
    box-shadow: 0 4px 12px rgba(184, 230, 184, 0.4);
}

.tab:not(.active):active {
    transform: scale(0.95);
}

/* Beheer Tabs */
.beheer-container {
    padding: 1rem;
}

.beheer-tabs-container {
    position: relative;
    margin-bottom: 1.5rem;
}

.beheer-tabs {
    display: flex;
    gap: 0.5rem;
    padding-bottom: 1rem;
    overflow-x: auto;
    scroll-behavior: smooth;
    scrollbar-width: none;
    -ms-overflow-style: none;
    padding-left: 1rem;
    padding-right: 1rem;
}

.beheer-tabs::-webkit-scrollbar {
    display: none;
}

.beheer-tabs-indicator {
    position: absolute;
    bottom: 0;
    left: 1rem;
    height: 2px;
    background: var(--primary);
    border-radius: 1px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    width: calc(25% - 0.375rem);
}

.beheer-tab {
    padding: 0.75rem 1rem;
    border-radius: 12px;
    background: var(--dark-card);
    color: var(--text-muted);
    border: 1px solid var(--border);
    cursor: pointer;
    font-weight: 500;
    font-size: 0.875rem;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    flex-shrink: 0;
    white-space: nowrap;
    text-align: center;
    min-width: fit-content;
}

.beheer-tab.active {
    background: var(--primary);
    color: var(--dark);
    border-color: var(--primary);
    box-shadow: 0 2px 8px rgba(184, 230, 184, 0.3);
}

.beheer-tab:not(.active):hover {
    background: var(--dark-elevated);
    border-color: var(--primary-light);
}

.beheer-content {
    /* Content will be populated by switchBeheerView */
}

/* View Management */
.view {
    display: none;
}

.view.active {
    display: block;
    animation: fadeSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    background: radial-gradient(circle at 20% 30%, rgba(255,255,255,0.03), transparent 40%),
                radial-gradient(circle at 80% 20%, rgba(255,255,255,0.02), transparent 35%),
                radial-gradient(circle at 50% 80%, rgba(255,255,255,0.02), transparent 45%),
                repeating-linear-gradient(45deg, rgba(255,255,255,0.04), rgba(255,255,255,0.04) 6px, rgba(0,0,0,0.02) 6px, rgba(0,0,0,0.02) 12px);
}

@keyframes fadeSlideIn {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Schema Selection */
.schema-grid {
    display: grid;
    gap: 1rem;
    margin-bottom: 2rem;
}

.schema-card {
    --schema-accent: var(--primary);
    --schema-accent-2: var(--secondary);
    background: linear-gradient(135deg, var(--dark-card) 0%, var(--dark-elevated) 100%);
    border-radius: 24px;
    padding: 1.75rem;
    border: 2px solid var(--schema-accent);
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.schema-card::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--schema-accent) 0%, var(--schema-accent-2) 100%);
    opacity: 0;
    transition: opacity 0.4s;
}

.schema-card:active {
    transform: scale(0.97) translateY(2px);
}

.schema-card.push {
    --schema-accent: #A8DADC;
    --schema-accent-2: #B8E6B8;
}

.schema-card.legs {
    --schema-accent: #A8DADC;
    --schema-accent-2: #F4C2A1;
}

.schema-card:hover::before {
    opacity: 0.08;
}

.schema-content {
    position: relative;
    z-index: 1;
}

.schema-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1rem;
}

.schema-icon {
    font-size: 3rem;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
}

.schema-badge {
    background: var(--schema-accent);
    color: var(--dark);
    padding: 0.375rem 0.875rem;
    border-radius: 14px;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.schema-card h3 {
    font-size: 1.75rem;
    margin-bottom: 0.5rem;
    font-weight: 700;
}

.schema-card p {
    color: var(--text-muted);
    font-size: 1rem;
    line-height: 1.5;
}

.schema-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
    margin-top: 1.25rem;
    padding-top: 1.25rem;
    border-top: 1px solid var(--border);
}

.schema-stat {
    text-align: center;
}

.schema-stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--schema-accent);
    display: block;
    margin-bottom: 0.25rem;
}

.schema-stat-label {
    font-size: 0.8rem;
    color: var(--text-muted);
}

/* Template Grid Styles */
.template-grid {
    margin-bottom: 2rem;
}

.template-header {
    text-align: center;
    margin-bottom: 2rem;
}

.template-header h2 {
    color: var(--text);
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
}

.template-list {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
}

.template-card {
    background: linear-gradient(135deg, var(--dark-card) 0%, var(--dark-elevated) 100%);
    border-radius: 16px;
    padding: 1.5rem;
    border: 1px solid var(--border);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.template-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    border-color: var(--primary);
}

.template-card:active {
    transform: translateY(0);
}

.template-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1rem;
}

.template-card-title {
    font-size: 1.25rem;
    font-weight: 700;
    color: var(--text);
    margin: 0;
}

.template-card-actions {
    display: flex;
    gap: 0.5rem;
}

.template-card .btn-icon {
    padding: 0.5rem;
    background: var(--dark-lighter);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.2s ease;
}

.template-card .btn-icon:hover {
    background: var(--danger);
    color: white;
}

.template-card-description {
    color: var(--text-muted);
    font-size: 0.9rem;
    margin-bottom: 1rem;
    line-height: 1.4;
}

.template-card-stats {
    display: flex;
    gap: 1rem;
    font-size: 0.85rem;
    color: var(--text-muted);
}

.template-card-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.template-card-stat-value {
    font-weight: 700;
    color: var(--primary);
    font-size: 1.1rem;
}

.template-card-stat-label {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Mobile responsive */
@media (max-width: 768px) {
    .template-list {
        grid-template-columns: 1fr;
    }
    
    .template-card {
        padding: 1rem;
    }
    
    .template-card-title {
        font-size: 1.1rem;
    }
}

/* PRs View Styles */
.prs-header {
    text-align: center;
    margin-bottom: 2rem;
}

.prs-controls {
    display: flex;
    justify-content: center;
    margin-top: 1rem;
}

.prs-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.pr-card {
    background: var(--dark-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 1.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: var(--shadow);
}

.pr-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border-color: var(--primary);
}

.pr-card:active {
    transform: translateY(0);
}

.pr-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1rem;
}

.pr-card-title {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--text);
    margin: 0;
    flex: 1;
}

.pr-card-actions {
    margin-left: 0.5rem;
}

.pr-card-stats {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
}

.pr-card-stat {
    text-align: center;
    flex: 1;
}

.pr-card-stat-value {
    display: block;
    font-size: 1.5rem;
    font-weight: 800;
    color: #FFCC00;
    margin-bottom: 0.25rem;
}

.pr-card-stat-label {
    font-size: 0.8rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.pr-card-date {
    font-size: 0.9rem;
    color: var(--text-muted);
    text-align: center;
    padding-top: 0.5rem;
    border-top: 1px solid var(--border);
}

@media (max-width: 768px) {
    .prs-grid {
        grid-template-columns: 1fr;
    }
    
    .pr-card {
        padding: 1rem;
    }
    
    .pr-card-title {
        font-size: 1.1rem;
    }
    
    .pr-card-stats {
        flex-direction: column;
        gap: 0.5rem;
    }
}

/* Goals View Styles */
.goals-header {
    text-align: center;
    margin-bottom: 2rem;
}

.goals-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
}

.goal-card {
    background: var(--dark-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 1.5rem;
    position: relative;
    overflow: hidden;
}

.goal-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #4A90E2, #5BA0F2);
}

.goal-card.completed::before {
    background: linear-gradient(90deg, #4A90E2, #5BA0F2);
}

.goal-card.overdue::before {
    background: linear-gradient(90deg, #FF3B30, #FF453A);
}

.goal-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1rem;
}

.goal-card-title {
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--text);
    margin: 0;
    flex: 1;
}

.goal-card-actions {
    margin-left: 0.5rem;
}

.goal-card-type {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    background: var(--primary);
    color: white;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    margin-bottom: 1rem;
}

.goal-card-progress {
    margin-bottom: 1rem;
}

.goal-progress-bar {
    width: 100%;
    height: 8px;
    background: var(--dark-elevated);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.goal-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4A90E2, #5BA0F2);
    border-radius: 4px;
    transition: width 0.3s ease;
}

.goal-card-stats {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
}

.goal-card-stat {
    text-align: center;
    flex: 1;
}

.goal-card-stat-value {
    display: block;
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--text);
    margin-bottom: 0.25rem;
}

.goal-card-stat-label {
    font-size: 0.8rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.goal-card-deadline {
    font-size: 0.9rem;
    color: var(--text-muted);
    text-align: center;
    padding-top: 0.5rem;
    border-top: 1px solid var(--border);
}

@media (max-width: 768px) {
    .goals-grid {
        grid-template-columns: 1fr;
    }
    
    .goal-card {
        padding: 1rem;
    }
    
    .goal-card-title {
        font-size: 1.1rem;
    }
    
    .goal-card-stats {
        flex-direction: column;
        gap: 0.5rem;
    }
}

/* Analytics View Styles */
.analytics-header {
    text-align: center;
    margin-bottom: 2rem;
}

.analytics-controls {
    display: flex;
    justify-content: center;
    margin-top: 1rem;
}

.analytics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 1.5rem;
    margin-top: 1rem;
}

.analytics-card {
    background: var(--dark-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 1.5rem;
    box-shadow: var(--shadow);
}

.analytics-card-header {
    display: flex;
    align-items: center;
    margin-bottom: 1rem;
}

.analytics-card-icon {
    font-size: 1.5rem;
    margin-right: 0.75rem;
}

.analytics-card-title {
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--text);
    margin: 0;
}

.analytics-card-content {
    color: var(--text-muted);
    font-size: 0.9rem;
    line-height: 1.5;
}

.analytics-metric {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 0;
    border-bottom: 1px solid var(--border);
}

.analytics-metric:last-child {
    border-bottom: none;
}

.analytics-metric-label {
    font-weight: 600;
    color: var(--text);
}

.analytics-metric-value {
    font-weight: 700;
    color: var(--primary);
    font-size: 1.1rem;
}

.analytics-chart-container {
    margin-top: 1rem;
    padding: 1rem;
    background: var(--dark-elevated);
    border-radius: 12px;
}

.analytics-insight {
    background: linear-gradient(135deg, var(--primary), var(--primary-dark));
    color: white;
    padding: 1rem;
    border-radius: 12px;
    margin-bottom: 1rem;
    text-align: center;
}

.analytics-insight-title {
    font-size: 1.1rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
}

.analytics-insight-text {
    font-size: 0.9rem;
    opacity: 0.9;
}

@media (max-width: 768px) {
    .analytics-grid {
        grid-template-columns: 1fr;
    }
    
    .analytics-card {
        padding: 1rem;
    }
}

/* Workout Selection Header */
.workout-selection-header {
    text-align: center;
    margin-bottom: 2rem;
}

.workout-selection-header h2 {
    color: var(--text);
    font-size: 1.75rem;
    margin-bottom: 1rem;
}

.workout-selection-tabs {
    display: flex;
    justify-content: center;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.selection-tab {
    padding: 0.75rem 1.5rem;
    background: var(--dark-lighter);
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
}

.selection-tab.active {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
}

.selection-tab:hover:not(.active) {
    background: var(--dark-card);
    border-color: var(--primary);
}

/* Timer Card */
.timer-card {
    --schema-accent: var(--primary);
    --schema-accent-2: var(--secondary);
    background: linear-gradient(135deg, var(--dark-card) 0%, var(--dark-elevated) 100%);
    border-radius: 24px;
    padding: 2rem;
    text-align: center;
    margin-bottom: 1.5rem;
    border: 1px solid var(--schema-accent);
    position: relative;
    overflow: hidden;
    box-shadow: var(--shadow);
}

.timer-card::before {
    content: "";
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: conic-gradient(from 0deg, transparent 0%, var(--schema-accent) 50%, transparent 100%);
    animation: timerRotate 6s linear infinite;
    opacity: 0;
    transition: opacity 0.5s;
}

.timer-card.running::before {
    opacity: 0.15;
}

@keyframes timerRotate {
    100% { transform: rotate(360deg); }
}

.timer-content {
    position: relative;
    z-index: 1;
}

.timer-label {
    color: var(--text-muted);
    font-size: 0.95rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 0.75rem;
}

.timer-meta {
    color: var(--text-muted);
    font-size: 0.9rem;
    margin-top: 0.25rem;
}

.timer-inline-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
    margin-top: 0.75rem;
}

.timer-stat {
    background: var(--dark-elevated);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 0.65rem 0.85rem;
    text-align: center;
}

.timer-stat-label {
    display: block;
    color: var(--text-muted);
    font-size: 0.8rem;
    margin-bottom: 0.15rem;
    font-weight: 600;
}

.timer-stat-value {
    display: block;
    font-size: 1.25rem;
    font-weight: 800;
}

.timer {
    font-size: 4rem;
    font-weight: 800;
    font-variant-numeric: tabular-nums;
    margin: 1rem 0;
    background: var(--gold);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: -2px;
}

.timer-controls {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-top: 1.5rem;
}

/* Buttons */
.btn {
    padding: 1rem 1.75rem;
    border-radius: 16px;
    border: none;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    font-size: 1rem;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    position: relative;
    overflow: hidden;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.btn::before {
    content: "";
    position: absolute;
    inset: 0;
    background: rgba(255, 255, 255, 0.15);
    opacity: 0;
    transition: opacity 0.2s;
}

.btn:active {
    transform: scale(0.96) translateY(1px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.btn:active::before {
    opacity: 1;
}

.btn-primary {
    background: linear-gradient(135deg, #4A90E2 0%, #5BA0F2 100%);
    color: var(--dark);
}

.btn-secondary {
    background: var(--dark-elevated);
    color: var(--text);
    border: 1px solid var(--border);
}

.btn-outline {
    background: transparent;
    color: var(--primary);
    border: 2px solid var(--primary);
    font-weight: 600;
}

.btn-outline:hover {
    background: var(--primary);
    color: white;
}

.btn-danger {
    background: linear-gradient(135deg, #FF3B30 0%, #D63028 100%);
    color: var(--text);
}

.btn-warning {
    background: linear-gradient(135deg, #E67E22 0%, #D35400 100%);
    color: var(--dark);
}

.btn-icon {
    width: 48px;
    height: 48px;
    padding: 0;
    border-radius: 50%;
}

.btn-icon.delete-btn {
    background: transparent;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.35rem;
    border-radius: 8px;
    width: auto;
    height: auto;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.btn-icon.delete-btn:hover {
    background: var(--dark-elevated);
    color: #FF3B30;
}

.btn-icon.delete-btn:active {
    transform: scale(0.95);
}

/* Stats Card */
.stats-card {
    background: linear-gradient(135deg, var(--dark-card) 0%, var(--dark-elevated) 100%);
    border-radius: 24px;
    padding: 1.75rem;
    margin-bottom: 1.5rem;
    border: 1px solid var(--border);
    box-shadow: var(--shadow);
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1.5rem;
}

.stat-item {
    text-align: center;
    position: relative;
}

.stat-item::before {
    content: "";
    position: absolute;
    top: 50%;
    right: 0;
    width: 1px;
    height: 60%;
    background: var(--border);
    transform: translateY(-50%);
}

.stat-item:last-child::before {
    display: none;
}

.stat-value {
    font-size: 2.25rem;
    font-weight: 800;
    background: var(--gold);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    display: block;
    margin-bottom: 0.5rem;
    letter-spacing: -1px;
}

.stat-label {
    font-size: 0.875rem;
    color: var(--text-muted);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Rest Timer Overlay */
.rest-timer-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    z-index: 9999;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(3px);
}

.rest-timer-card {
    background: var(--dark-card);
    border: 2px solid var(--primary);
    border-radius: 24px;
    padding: 2rem;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    max-width: 320px;
    width: 90%;
    text-align: center;
    transform: scale(0.9);
    transition: transform 0.3s ease;
}

.rest-timer-overlay.active .rest-timer-card {
    transform: scale(1);
}

.rest-timer-title {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text);
}

.rest-timer-actions {
    display: flex;
    gap: 0.5rem;
}

.rest-timer-progress {
    position: relative;
    width: 100%;
    height: 16px;
    background: var(--dark-elevated);
    border-radius: 999px;
    overflow: hidden;
    border: 2px solid var(--border);
    margin-top: 1rem;
}

.rest-timer-title {
    font-weight: 700;
    color: var(--text);
}

.rest-timer-actions {
    display: flex;
    gap: 0.5rem;
}

.rest-timer-progress {
    position: relative;
    width: 100%;
    height: 10px;
    background: var(--dark-elevated);
    border-radius: 999px;
    overflow: hidden;
    border: 1px solid var(--border);
}

.rest-timer-progress > div {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, var(--primary), #2FAA4E);
    transition: width 0.25s ease;
}

/* Muscle Groups */
.muscle-group {
    margin-bottom: 2rem;
}

.muscle-group-header {
    background: var(--dark-card);
    padding: 1.25rem 1.5rem;
    border-radius: 20px;
    margin-bottom: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border: 1px solid var(--border);
    box-shadow: var(--shadow);
}

.muscle-group-title {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.muscle-group-icon {
    font-size: 1.5rem;
}

.muscle-group-header h3 {
    font-size: 1.35rem;
    font-weight: 700;
}

.progress-badge {
    background: var(--dark-elevated);
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 600;
    border: 1px solid var(--border);
}

/* Exercise Cards */
.exercise-card {
    background: var(--dark-elevated);
    border-radius: 20px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    border: 1px solid var(--border);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    position: relative;
    overflow: hidden;
}

.exercise-card:active {
    transform: scale(0.99);
}

.exercise-card.swiping {
    transition: none;
}

.exercise-card.deleting {
    animation: slideOutLeft 0.3s ease-out forwards;
}

@keyframes slideOutLeft {
    to {
        transform: translateX(-100%);
        opacity: 0;
    }
}

.exercise-card-delete-bg {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    background: var(--danger);
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 1.5rem;
    color: white;
    font-weight: 600;
    font-size: 1rem;
    opacity: 0;
    transition: opacity 0.2s;
}

.exercise-card.swiping .exercise-card-delete-bg {
    opacity: 1;
}

.exercise-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1.25rem;
}

.exercise-title {
    flex: 1;
}

.exercise-name {
    font-size: 1.2rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.pr-badge-inline {
    background: linear-gradient(135deg, #FFD700, #FFA500);
    color: var(--dark);
    padding: 0.25rem 0.625rem;
    border-radius: 10px;
    font-size: 0.7rem;
    font-weight: 800;
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    animation: prGlow 2s ease-in-out infinite;
}

@keyframes prGlow {
    0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
    50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
}

.exercise-meta {
    color: var(--text-muted);
    font-size: 0.875rem;
    display: flex;
    gap: 1rem;
}

.exercise-meta-item {
    display: flex;
    align-items: center;
    gap: 0.375rem;
}

.exercise-actions {
    display: flex;
    gap: 0.5rem;
}

.exercise-btn {
    background: var(--dark-card);
    border: 1px solid var(--border);
    color: var(--text);
    width: 40px;
    height: 40px;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
}

.exercise-btn::before {
    content: "";
    width: 16px;
    height: 16px;
    background: currentColor;
    mask-size: contain;
    mask-repeat: no-repeat;
    mask-position: center;
    transition: transform 0.2s ease;
}

.exercise-btn.collapse-btn::before {
    mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23000" d="M6.7 9l5.3 5.3L17.3 9z"/></svg>');
}

.exercise-btn.collapse-btn.collapsed::before {
    transform: rotate(-90deg);
}

.exercise-btn.progress-btn::before {
    mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23000" d="M5 18h3V8H5zm6 0h3V5h-3zm6 0h3V11h-3z"/></svg>');
}

.exercise-btn:active {
    transform: scale(0.88);
}

/* Sets Container */
.sets-container {
    display: grid;
    gap: 0.875rem;
}

.set-row {
    background: var(--dark-card);
    border-radius: 14px;
    padding: 1rem;
    display: grid;
    grid-template-columns: 1fr 1fr 50px;
    gap: 0.75rem;
    align-items: center;
    border: 2px solid transparent;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.set-row.completed {
    background: var(--schema-accent-rgba-bg, rgba(184, 230, 184, 0.15));
    border-color: var(--schema-accent, #4A90E2);
    box-shadow: 0 0 20px var(--schema-accent-rgba-shadow, rgba(184, 230, 184, 0.2));
}

.set-row.new-pr {
    animation: prPulse 1.2s cubic-bezier(0.4, 0, 0.2, 1);
    border-color: #FFD700;
    background: linear-gradient(90deg, rgba(255, 215, 0, 0.1) 0%, transparent 100%);
}

@keyframes prPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.03); box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); }
}

.set-number { display: none; }

.set-input-group {
    position: relative;
}

.set-input {
    width: 100%;
    background: var(--dark-elevated);
    border: 2px solid var(--border);
    border-radius: 12px;
    padding: 0.875rem;
    color: var(--text);
    font-size: 1.1rem;
    font-weight: 700;
    text-align: center;
    transition: all 0.2s;
    font-variant-numeric: tabular-nums;
}

.set-input:focus {
    outline: none;
    border-color: var(--primary);
    background: var(--dark-card);
    box-shadow: 0 0 0 4px rgba(184, 230, 184, 0.1);
}

.set-input-label {
    position: absolute;
    top: -9px;
    left: 14px;
    background: var(--dark-elevated);
    padding: 0 0.5rem;
    font-size: 0.75rem;
    color: var(--text-muted);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.checkbox {
    width: 36px;
    height: 36px;
    border-radius: 10px;
    border: 2px solid var(--border);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    background: var(--dark-elevated);
}

.checkbox.checked {
    background: linear-gradient(135deg, var(--schema-accent, #4A90E2) 0%, var(--schema-accent-2, #5BA0F2) 100%);
    border-color: var(--schema-accent, #4A90E2);
    box-shadow: 0 4px 12px var(--schema-accent-rgba, rgba(184, 230, 184, 0.4));
}

.checkbox.checked::after {
    content: "";
    color: var(--dark);
    font-weight: 900;
    font-size: 1.4rem;
}

.checkbox:active {
    transform: scale(0.85) rotate(5deg);
}

/* Previous Best */
.previous-best {
    grid-column: 1 / -1;
    padding: 0.875rem 1rem;
    background: rgba(90, 200, 250, 0.1);
    border-radius: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.875rem;
    border: 1px solid rgba(90, 200, 250, 0.2);
}

.previous-best-label {
    color: var(--tertiary);
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.previous-best-value {
    color: var(--text);
    font-weight: 700;
}

/* Calendar Styles */
.calendar-container {
    padding: 1rem 0;
}

.calendar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    gap: 1rem;
}

.calendar-month-year {
    font-size: 1.25rem;
    font-weight: 700;
    text-align: center;
    flex: 1;
}

.calendar-nav-btn {
    background: var(--dark-card);
    border: 1px solid var(--border);
    color: var(--text);
    width: 40px;
    height: 40px;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
}

.calendar-nav-btn:active {
    transform: scale(0.92);
}

.calendar-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 0.5rem;
    margin-bottom: 1.5rem;
}

.calendar-weekday {
    text-align: center;
    font-weight: 600;
    font-size: 0.85rem;
    color: var(--text-muted);
    padding: 0.5rem 0;
}

.calendar-day {
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: var(--dark-card);
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    font-weight: 600;
    font-size: 0.95rem;
}

.calendar-day:active {
    transform: scale(0.95);
}

.calendar-day.other-month {
    color: var(--text-muted);
    opacity: 0.4;
}

.calendar-day.has-workout {
    background: var(--primary);
    color: #000;
    box-shadow: 0 0 12px rgba(184, 230, 184, 0.3);
}

.calendar-day.has-workout::after {
    content: "";
    position: absolute;
    bottom: 4px;
    width: 4px;
    height: 4px;
    background: rgba(0,0,0,0.4);
    border-radius: 50%;
}

.calendar-day.today {
    border: 2px solid var(--primary);
}

.calendar-workouts {
    background: var(--dark-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 1rem;
    margin-top: 1rem;
}

.calendar-workouts-title {
    font-weight: 700;
    margin-bottom: 1rem;
    color: var(--text);
}

.calendar-workout-item {
    background: var(--dark-elevated);
    padding: 0.75rem;
    border-radius: 12px;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
}

/* Bottom Actions */
.bottom-actions {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(28, 28, 30, 0.98);
    backdrop-filter: blur(30px) saturate(180%);
    border-top: 1px solid var(--border);
    padding: 1rem;
    display: none;
    gap: 1rem;
    z-index: 999;
    box-shadow: 0 -10px 40px rgba(0,0,0,0.3);
}

.bottom-actions.active {
    display: flex;
    animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes slideUp {
    from {
        transform: translateY(100%);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.bottom-actions .btn {
    flex: 1;
    font-size: 1.05rem;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.92);
    /* backdrop-filter: blur(10px); */ /* Disabled for iOS compatibility */
    z-index: 3000;
    align-items: center;
    justify-content: center;
    padding: 1rem;
}

.modal.active {
    display: flex;
    animation: fadeIn 0.3s ease-out;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
}

.modal-content {
    background: var(--dark-lighter);
    border-radius: 28px;
    max-width: 600px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    border: 1px solid var(--border);
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    animation: modalZoom 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes modalZoom {
    from {
        transform: scale(0.9) translateY(20px);
        opacity: 0;
    }
    to {
        transform: scale(1) translateY(0);
        opacity: 1;
    }
}

.modal-header {
    padding: 1.75rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: sticky;
    top: 0;
    background: var(--dark-lighter);
    z-index: 10;
}

.modal-header h2 {
    font-size: 1.75rem;
    font-weight: 700;
}

.close-btn {
    background: var(--dark-card);
    border: 1px solid var(--border);
    color: var(--text);
    font-size: 1.75rem;
    cursor: pointer;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
    line-height: 1;
}

.close-btn:active {
    transform: scale(0.88) rotate(90deg);
}

.modal-body {
    padding: 1.75rem;
}

.modal-title {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.modal-title h2 {
    margin: 0;
    font-size: 1.5rem;
    font-weight: 700;
}

/* History Item */
.history-item {
    background: var(--dark-card);
    border-radius: 20px;
    padding: 1.5rem;
    margin-bottom: 1rem;
    border: 1px solid var(--border);
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.history-item:active {
    transform: scale(0.98) translateY(1px);
}

.history-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1rem;
}

.history-date {
    font-weight: 700;
    font-size: 1.2rem;
}

.history-time {
    color: var(--text-muted);
    font-size: 0.95rem;
    margin-top: 0.25rem;
}

.history-schema {
    color: var(--primary);
    font-size: 0.95rem;
    font-weight: 700;
    padding: 0.375rem 0.875rem;
    background: rgba(184, 230, 184, 0.15);
    border-radius: 12px;
    display: inline-block;
}

.history-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
}

.history-stat {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
}

.history-stat-value {
    font-weight: 800;
    font-size: 1.25rem;
    color: var(--text);
}

.history-stat-label {
    color: var(--text-muted);
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Empty State */
.empty-state {
    text-align: center;
    padding: 3rem 1.5rem;
    color: var(--text-muted);
}

.empty-state-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
    opacity: 0.5;
}

.empty-state h3 {
    font-size: 1.5rem;
    margin-bottom: 0.5rem;
    color: var(--text);
}

.empty-state p {
    font-size: 1rem;
}

/* PR Celebration */
.pr-celebration {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.96);
    backdrop-filter: blur(20px);
    z-index: 3000;
    display: none;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.3s ease-out;
}

.pr-celebration.active {
    display: flex;
}

.pr-content {
    text-align: center;
    padding: 2.5rem;
    animation: prZoom 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes prZoom {
    0% { transform: scale(0.5) rotate(-10deg); opacity: 0; }
    70% { transform: scale(1.1) rotate(5deg); }
    100% { transform: scale(1) rotate(0deg); opacity: 1; }
}

.pr-emoji {
    font-size: 6rem;
    margin-bottom: 1.5rem;
    animation: prBounce 1s ease-in-out infinite;
    filter: drop-shadow(0 10px 30px rgba(255, 215, 0, 0.6));
}

@keyframes prBounce {
    0%, 100% { transform: translateY(0) scale(1); }
    50% { transform: translateY(-30px) scale(1.1); }
}

.pr-title {
    font-size: 3rem;
    font-weight: 900;
    background: var(--gold);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 1rem;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.pr-detail {
    font-size: 1.5rem;
    color: var(--text);
    margin-bottom: 2.5rem;
    font-weight: 600;
}

.pr-sub {
    font-size: 1.1rem;
    color: var(--text-muted);
    margin-bottom: 2rem;
}

/* Floating Action Button */
.fab-add-exercise {
    position: fixed;
    bottom: 100px;
    right: 20px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: var(--primary);
    color: white;
    border: none;
    font-size: 2rem;
    font-weight: 300;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(184, 230, 184, 0.4);
    display: none;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    z-index: 1000;
}

.fab-add-exercise.visible {
    display: flex;
}

.fab-add-exercise:hover {
    transform: scale(1.1);
    box-shadow: 0 8px 20px rgba(184, 230, 184, 0.6);
}

.fab-add-exercise:active {
    transform: scale(0.95);
}

.fab-voice-add {
    position: fixed;
    bottom: 170px; /* Above the regular FAB */
    right: 20px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: var(--dark-card);
    color: var(--text);
    border: 2px solid var(--primary);
    font-size: 1.5rem;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    display: none;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    z-index: 1000;
}

.fab-voice-add.visible {
    display: flex;
}

.fab-voice-add:hover {
    transform: scale(1.1);
    background: var(--primary);
    color: white;
}

.fab-voice-add:active {
    transform: scale(0.95);
}

/* Mobile Enhancements */
.set-row {
    transition: transform 0.2s ease, background 0.2s ease;
    touch-action: pan-y; /* Allow vertical scrolling but prevent horizontal swipe conflicts */
    user-select: none; /* Prevent text selection during swipe */
    -webkit-user-select: none;
    -webkit-touch-callout: none; /* Disable callout on iOS */
    -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
}

.set-row.swipe-active {
    transform: translateX(var(--swipe-x, 0));
    z-index: 10; /* Bring to front during swipe */
}

.set-row.swipe-active .set-input,
.set-row.swipe-active .checkbox {
    pointer-events: none; /* Disable interactions during swipe */
}

/* Better touch targets for mobile */
@media (max-width: 768px) {
    .set-input {
        min-height: 44px; /* iOS minimum touch target */
        font-size: 16px; /* Prevent zoom on iOS */
    }
    
    .btn {
        min-height: 44px;
        padding: 0.75rem 1rem;
    }
    
    .checkbox {
        width: 40px;
        height: 40px;
        border-radius: 12px;
    }
    
    .fab-add-exercise,
    .fab-voice-add {
        width: 60px;
        height: 60px;
        bottom: 110px;
    }
    
    .fab-voice-add {
        bottom: 180px;
    }
}

/* Prevent horizontal scroll during swipe */
body.swipe-active {
    overflow-x: hidden;
}

/* Modal Styles */
.modal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(12px);
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 1rem;
}

.modal.active {
    display: flex;
    animation: fadeIn 0.3s ease-out;
}

.modal-content {
    background: var(--dark-card);
    border-radius: 16px;
    border: 1px solid var(--border);
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    max-height: 90vh;
    overflow-y: auto;
    animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translateY(40px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.modal-header {
    padding: 1.5rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h2 {
    margin: 0;
    font-size: 1.5rem;
}

.modal-close {
    background: none;
    border: none;
    color: var(--text);
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.modal-close:hover {
    color: var(--primary);
    transform: rotate(90deg);
}

.modal-body {
    padding: 1.5rem;
}

.modal-footer {
    padding: 1.5rem;
    border-top: 1px solid var(--border);
    display: flex;
    gap: 1rem;
    justify-content: flex-end;
}

.form-group {
    margin-bottom: 1.5rem;
}

.form-group:last-child {
    margin-bottom: 0;
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 600;
    font-size: 0.95rem;
}

.form-input {
    width: 100%;
    padding: 0.75rem;
    background: var(--dark-elevated);
    border: 1px solid var(--border);
    border-radius: 10px;
    color: var(--text);
    font-size: 1rem;
    transition: all 0.2s ease;
    font-family: inherit;
}

.form-input:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(184, 230, 184, 0.1);
}

.form-input option {
    background: var(--dark-card);
    color: var(--text);
}

@media (max-width: 640px) {
    .fab-add-exercise {
        bottom: 80px;
        right: 16px;
    }
    
    .modal-content {
        max-width: 100%;
        border-radius: 20px 20px 0 0;
    }

    /* Statistics Page Mobile */
    .stats-grid {
        grid-template-columns: 1fr; /* Single column for better mobile layout */
        gap: 1rem;
    }

    .stat-card {
        padding: 0.75rem; /* Reduce padding for mobile */
    }

    .stat-icon {
        font-size: 1.5rem;
    }

    .stat-value {
        font-size: 1.5rem;
    }

    .stat-label {
        font-size: 0.9rem;
    }

    .stat-sub {
        font-size: 0.8rem;
    }

    .charts-section {
        grid-template-columns: 1fr;
        gap: 1.5rem;
    }

    .chart-container {
        padding: 0.75rem; /* Reduce padding for mobile */
    }

    .chart-container h3 {
        font-size: 1.2rem;
        margin-bottom: 0.75rem;
        width: 100%;
        text-align: center;
    }

    .chart-container canvas {
        width: 100% !important;
        height: 200px !important;
        max-width: none; /* Remove max-width restriction on mobile */
    }

    .chart-legend {
        font-size: 0.8rem;
        margin-top: 0.5rem;
        text-align: center;
        width: 100%;
    }

    .chart-legend-list {
        margin-top: 1rem;
        margin-left: 0; /* Remove left margin on mobile */
        width: 100%;
    }

    .legend-item {
        font-size: 0.8rem;
        margin-bottom: 0.25rem;
    }

    .legend-color {
        width: 12px;
        height: 12px;
        display: inline-block;
        margin-right: 0.5rem;
        border-radius: 2px;
    }

    .period-buttons {
        flex-direction: column;
        gap: 0.25rem;
    }

    .period-btn {
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
        min-height: 40px;
    }

    #exerciseSelector {
        width: 100%;
        margin-bottom: 0.5rem;
    }

    /* Header mobile adjustments */
    .header {
        padding: 0.75rem;
        margin: -0.75rem -0.75rem 1rem -0.75rem;
    }

    .tab {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
    }
}

/* Form Groups */
.form-group {
    margin-bottom: 1.75rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.875rem;
    font-weight: 700;
    color: var(--text);
    font-size: 0.95rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.form-input, .form-select {
    width: 100%;
    background: var(--dark-card);
    border: 2px solid var(--border);
    border-radius: 14px;
    padding: 1.125rem;
    color: var(--text);
    font-size: 1.05rem;
    transition: all 0.2s;
    font-weight: 600;
}

.form-input:focus, .form-select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 4px rgba(184, 230, 184, 0.1);
}

/* Empty State */
.empty-state {
    text-align: center;
    padding: 5rem 2rem;
    color: var(--text-muted);
}

.empty-state-icon {
    font-size: 5rem;
    margin-bottom: 1.5rem;
    opacity: 0.4;
    filter: grayscale(1);
}

.empty-state h3 {
    font-size: 1.5rem;
    margin-bottom: 0.75rem;
    color: var(--text);
}

.empty-state p {
    font-size: 1rem;
    line-height: 1.6;
}

/* Toast */
.toast {
    position: fixed;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%) translateY(150px);
    background: var(--dark-card);
    color: var(--text);
    padding: 1.125rem 1.75rem;
    border-radius: 16px;
    border: 1px solid var(--border);
    z-index: 2500;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    max-width: 90%;
    font-weight: 600;
}

.toast.show {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
}

.toast.success {
    background: var(--success);
    color: var(--dark);
    border-color: var(--success);
}

.toast.error {
    background: var(--danger);
    color: var(--text);
    border-color: var(--danger);
}

/* Loading */
.loading {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 3rem;
}

.spinner {
    width: 50px;
    height: 50px;
    border: 4px solid var(--border);
    border-top-color: var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    100% { transform: rotate(360deg); }
}

/* PR List */
.pr-list {
    display: grid;
    gap: 1rem;
}

.pr-card {
    background: var(--dark-card);
    border-radius: 20px;
    padding: 1.5rem;
    border: 1px solid var(--border);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.pr-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 1rem;
}

.pr-card-title {
    font-size: 1.2rem;
    font-weight: 700;
    margin-bottom: 0.375rem;
}

.pr-card-date {
    color: var(--text-muted);
    font-size: 0.85rem;
}

.pr-value {
    font-size: 2rem;
    font-weight: 800;
    background: var(--gold);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.pr-card-stats {
    display: flex;
    gap: 1.5rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
}

.pr-card-stat {
    font-size: 0.9rem;
    color: var(--text-muted);
}

.pr-card-stat strong {
    color: var(--text);
    font-weight: 700;
}

/* Statistics Styles */
.statistics-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
}

.statistics-header h2 {
    margin: 0;
}

.period-buttons {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.period-btn {
    padding: 0.5rem 1rem;
    border: 1px solid var(--border);
    background: var(--dark-card);
    color: var(--text);
    border-radius: 10px;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
    min-height: 44px; /* iOS touch target */
}

.period-btn.active {
    background: var(--primary);
    color: white;
    border-color: var(--primary);
}

.period-btn:hover {
    background: var(--hover);
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 1rem;
    margin-bottom: 2rem;
}

.stat-card {
    background: var(--dark-card);
    border-radius: 20px;
    padding: 1.5rem;
    border: 1px solid var(--border);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    text-align: center;
}

.stat-icon {
    font-size: 2rem;
    margin-bottom: 0.5rem;
}

.stat-value {
    font-size: 2rem;
    font-weight: 800;
    color: var(--gold);
    margin-bottom: 0.5rem;
}

.stat-label {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 0.25rem;
}

.stat-sub {
    font-size: 0.8rem;
    color: var(--text-muted);
}

.charts-section {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 2rem;
}

.chart-container {
    background: var(--dark-card);
    border-radius: 20px;
    padding: 1.5rem;
    border: 1px solid var(--border);
    display: flex;
    align-items: center;
}

.chart-container h3 {
    margin-top: 0;
    margin-bottom: 1rem;
    width: 100%;
}

.chart-container canvas {
        width: 100% !important;
        height: 200px !important;
        max-width: 300px;
    }

.chart-legend {
    margin-top: 0.5rem;
    font-size: 0.9rem;
    color: var(--text-muted);
    text-align: center;
}

.chart-legend-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    margin-left: 1rem;
}

.legend-item {
    display: flex;
    align-items: center;
    font-size: 0.8rem;
    color: var(--text);
}

.legend-color {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 0.5rem;
}

/* Responsive */
@media (max-width: 640px) {
    h1 {
        font-size: 1.75rem;
    }
    
    .timer {
        font-size: 3rem;
    }
    
    .set-row {
        grid-template-columns: 40px 1fr 1fr 40px;
        gap: 0.75rem;
        padding: 0.875rem;
    }
    
    .stats-grid {
        gap: 1rem;
    }
    
    .stat-value {
        font-size: 1.75rem;
    }
    
    .schema-card h3 {
        font-size: 1.5rem;
    }

    /* Sets Layout */
    .sets-container {
        display: grid;
        gap: 0.75rem;
    }

    .set-row {
        display: flex;
        flex-direction: column;
        align-items: stretch;
        gap: 0.6rem;
        padding: 0.9rem;
        background: var(--dark-card);
        border: 1px solid var(--border);
        border-radius: 16px;
    }

    .set-row.completed {
        opacity: 0.92;
        background: var(--dark-elevated);
    }

    .set-input-group {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
    }

    .set-input-group > div {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        flex-wrap: wrap;
    }

    .set-input {
        flex: 1 1 110px;
        min-width: 110px;
        width: auto;
        text-align: center;
        padding: 0.45rem 0.65rem;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--dark-elevated);
        color: var(--text);
        font-weight: 700;
        font-variant-numeric: tabular-nums;
        letter-spacing: 0.02em;
    }

    .set-input-label {
        font-size: 0.78rem;
        color: var(--text-muted);
        font-weight: 600;
    }

    .checkbox {
        width: 32px;
        height: 32px;
        border-radius: 10px;
        border: 2px solid var(--border);
        background: transparent;
        cursor: pointer;
        transition: all 0.2s ease;
        align-self: flex-end;
    }

    .checkbox.checked {
        background: var(--primary);
        border-color: var(--primary);
    }

    /* Settings Styles */
    .settings-container {
        padding: 1.5rem;
        max-width: 700px;
        margin: 0 auto;
    }

    .settings-section {
        background: var(--dark-card);
        border-radius: 20px;
        padding: 2rem;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
    }

    .settings-section h2 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 2rem;
        color: var(--text);
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .settings-section h3 {
        font-size: 1.25rem;
        font-weight: 700;
        margin: 2.5rem 0 1.5rem 0;
        color: var(--text);
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .settings-item {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        padding: 1.5rem 0;
        gap: 2rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .settings-item:first-of-type {
        padding-top: 0;
    }

    .settings-item:last-of-type {
        border-bottom: none;
        padding-bottom: 0;
    }

    .settings-label {
        display: flex;
        flex-direction: column;
        gap: 0.375rem;
        min-width: 0;
    }

    .settings-label > span:first-child {
        font-weight: 600;
        font-size: 1rem;
        color: var(--text);
    }

    .settings-description {
        font-size: 0.875rem;
        color: var(--text-muted);
        line-height: 1.4;
    }

    .settings-divider {
        height: 1px;
        background: var(--border);
        margin: 1.5rem 0;
    }

    .settings-control {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-shrink: 0;
    }

    .settings-input {
        width: 100px;
        padding: 0.625rem 0.875rem;
        border-radius: 12px;
        border: 2px solid var(--border);
        background: var(--dark-elevated);
        color: var(--text);
        font-size: 1rem;
        font-weight: 600;
        text-align: center;
        transition: all 0.2s;
    }

    .settings-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(184, 230, 184, 0.1);
    }

    .settings-counter {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background: var(--dark-elevated);
        border-radius: 12px;
        padding: 0.375rem;
        border: 1px solid var(--border);
        box-shadow: 0 0 0 1px rgba(255,255,255,0.05);
    }

    .settings-counter button {
        width: 38px;
        height: 38px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.25rem;
        font-weight: 600;
        background: var(--dark);
        border: 1px solid var(--border);
        color: var(--text);
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .settings-counter button:hover {
        background: var(--dark-elevated);
        border-color: var(--primary);
        transform: scale(1.05);
    }

    .settings-counter button:active {
        transform: scale(0.95);
    }

    .settings-counter input {
        width: 56px;
        text-align: center;
        border: none;
        background: transparent;
        color: var(--text);
        font-size: 1.125rem;
        font-weight: 700;
        pointer-events: none;
    }

    .settings-backup-grid {
        display: grid;
        gap: 0.875rem;
        margin-bottom: 1.5rem;
    }

    .settings-tip {
        padding: 1rem 1.25rem;
        background: rgba(184, 230, 184, 0.08);
        border-radius: 12px;
        border: 1px solid rgba(184, 230, 184, 0.2);
    }

    .settings-tip p {
        color: var(--text-muted);
        font-size: 0.875rem;
        line-height: 1.6;
        margin: 0;
    }

    .settings-version {
        display: inline-flex;
        align-items: center;
        padding: 0.5rem 0.875rem;
        background: var(--dark-elevated);
        border: 1px solid var(--border);
        border-radius: 10px;
        font-weight: 600;
        color: var(--text-muted);
        font-size: 0.875rem;
    }

    @media (max-width: 640px) {
        .settings-item {
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        .settings-control {
            justify-content: flex-start;
        }
    }

    /* Toggle Switch */
    .toggle-switch {
        position: relative;
        width: 88px;
        height: 38px;
        background: var(--dark-elevated);
        border-radius: 19px;
        cursor: pointer;
        border: 1px solid var(--border);
        box-shadow: 0 0 0 1px rgba(255,255,255,0.08);
        transition: all 0.25s ease;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 4px;
        gap: 4px;
        flex-shrink: 0;
    }

    .toggle-switch.active {
        background: var(--primary);
        border-color: var(--primary);
        box-shadow: 0 0 0 2px rgba(52,199,89,0.3);
    }

    .toggle-slider {
        width: 30px;
        height: 30px;
        background: var(--text);
        border-radius: 14px;
        transition: transform 0.3s ease;
        box-shadow: 0 2px 4px rgba(0,0,0,0.25);
    }

    .toggle-switch.active .toggle-slider {
        transform: translateX(26px);
    }

    .toggle-icon {
        font-size: 1rem;
        color: var(--text-muted);
        line-height: 1;
    }

    .toggle-switch.active .toggle-icon {
        color: var(--dark);
        opacity: 0.9;
    }

}

/* History List Styles */
.history-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding: 1rem 0;
}

.history-item {
    background: var(--dark-card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.history-item:hover {
    background: var(--dark-elevated);
    border-color: var(--primary);
    transform: translateY(-1px);
}

.history-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.history-item-title {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 1.1rem;
}

.schema-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
}

.history-item-actions {
    opacity: 0.7;
}

.history-item:hover .history-item-actions {
    opacity: 1;
}

.history-item-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
    font-size: 0.9rem;
    color: var(--text-muted);
}

.history-date {
    font-weight: 500;
}

.history-duration {
    background: var(--dark-elevated);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    font-size: 0.8rem;
}

.history-item-stats {
    display: flex;
    gap: 1rem;
}

.history-stat {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.history-stat-value {
    font-weight: 600;
    color: var(--primary);
}

.history-stat-label {
    font-size: 0.8rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

/* Workout Details Modal */
.workout-details-modal {
    max-width: 500px;
    width: 90vw;
    max-height: 80vh;
    overflow-y: auto;
}

.workout-summary {
    margin-bottom: 1.5rem;
}

.workout-meta {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem;
    background: var(--dark-elevated);
    border-radius: 8px;
}

.meta-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.meta-label {
    font-weight: 500;
    color: var(--text-muted);
}

.meta-value {
    font-weight: 600;
}

.workout-exercises {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.exercise-details {
    background: var(--dark-elevated);
    border-radius: 8px;
    padding: 1rem;
}

.exercise-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
}

.exercise-header h3 {
    margin: 0;
    color: var(--primary);
}

.exercise-stats {
    display: flex;
    gap: 1rem;
    font-size: 0.9rem;
    color: var(--text-muted);
}

.exercise-sets {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.set-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem;
    background: var(--dark-card);
    border-radius: 6px;
    font-size: 0.9rem;
}

.set-item.completed {
    border-left: 3px solid var(--success);
}

.set-item.incomplete {
    border-left: 3px solid var(--danger);
    opacity: 0.6;
}

.set-number {
    font-weight: 500;
    color: var(--text-muted);
}

.set-details {
    flex: 1;
    text-align: center;
    font-weight: 600;
}

.set-check {
    font-size: 1.2rem;
    font-weight: bold;
}

/* ===== ENHANCED UI/UX IMPROVEMENTS ===== */

/* Global Transitions */
* {
    transition: var(--transition-fast);
}

button, .btn, .tab, .card, .stat-card, .pr-card, .history-item {
    transition: var(--transition-normal);
}

/* Enhanced Button Interactions */
.btn {
    position: relative;
    overflow: hidden;
    transform: translateZ(0); /* Hardware acceleration */
}

.btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.3s ease, height 0.3s ease;
}

.btn:active::before {
    width: 300px;
    height: 300px;
}

.btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}

.btn:active {
    transform: translateY(0);
    transition: var(--transition-fast);
}

/* Card Hover Effects */
.card, .stat-card, .pr-card, .history-item {
    transform: translateZ(0);
}

.card:hover, .stat-card:hover, .pr-card:hover, .history-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
}

/* Tab Animations */
.tab {
    position: relative;
    overflow: hidden;
}

.tab::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    width: 0;
    height: 2px;
    background: var(--primary);
    transition: all 0.3s ease;
    transform: translateX(-50%);
}

.tab.active::after {
    width: 100%;
}

.tab:hover::after {
    width: 60%;
}

/* Loading Animation */
@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.loading {
    animation: pulse 1.5s ease-in-out infinite;
}

/* Success Animation */
@keyframes checkmark {
    0% { transform: scale(0) rotate(45deg); opacity: 0; }
    50% { transform: scale(1.2) rotate(45deg); opacity: 1; }
    100% { transform: scale(1) rotate(45deg); opacity: 1; }
}

.success-check {
    animation: checkmark 0.6s ease-out;
}

/* FAB Button Enhancements */
.fab {
    position: fixed;
    bottom: 24px;
    right: 24px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: var(--primary);
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    box-shadow: 0 4px 20px rgba(74, 144, 226, 0.3);
    transition: var(--transition-normal);
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
}

.fab:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 30px rgba(74, 144, 226, 0.4);
}

.fab:active {
    transform: scale(0.95);
}

/* Multiple FABs Layout */
.fab-voice {
    right: 88px;
    background: var(--secondary);
    box-shadow: 0 4px 20px rgba(123, 123, 123, 0.3);
}

.fab-voice:hover {
    box-shadow: 0 6px 30px rgba(123, 123, 123, 0.4);
}

/* Toast Enhancements */
.toast {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--dark-card);
    color: var(--text);
    padding: 12px 20px;
    border-radius: 25px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    font-weight: 500;
    border: 1px solid var(--border);
    animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
    from {
        transform: translateX(-50%) translateY(100px);
        opacity: 0;
    }
    to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
    }
}

/* Modal Enhancements */
.modal {
    animation: fadeInScale 0.3s ease-out;
}

@keyframes fadeInScale {
    from {
        opacity: 0;
        transform: scale(0.9);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

.modal-content {
    animation: slideIn 0.4s ease-out;
}

@keyframes slideIn {
    from {
        transform: translateY(30px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* Progress Bar Animation */
.progress-bar {
    height: 8px;
    background: var(--dark-elevated);
    border-radius: 4px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary), var(--tertiary));
    border-radius: 4px;
    transition: width 0.8s ease-out;
    position: relative;
}

.progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

/* Enhanced Input Focus */
input:focus, select:focus, textarea:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
    transition: var(--transition-fast);
}

/* Staggered Animation for Lists */
.stagger-item {
    animation: fadeInUp 0.6s ease-out both;
}

.stagger-item:nth-child(1) { animation-delay: 0.1s; }
.stagger-item:nth-child(2) { animation-delay: 0.2s; }
.stagger-item:nth-child(3) { animation-delay: 0.3s; }
.stagger-item:nth-child(4) { animation-delay: 0.4s; }
.stagger-item:nth-child(5) { animation-delay: 0.5s; }

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Enhanced Empty States */
.empty-state {
    text-align: center;
    padding: 3rem 1rem;
    animation: fadeIn 0.8s ease-out;
}

.empty-state-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
    opacity: 0.6;
    animation: bounceIn 0.8s ease-out;
}

@keyframes bounceIn {
    0% { transform: scale(0.3); opacity: 0; }
    50% { transform: scale(1.05); }
    70% { transform: scale(0.9); }
    100% { transform: scale(1); opacity: 1; }
}

/* Mobile Optimizations */
@media (max-width: 768px) {
    .fab {
        bottom: 20px;
        right: 20px;
    }
    
    .fab-voice {
        right: 76px;
    }
    
    .card:hover, .stat-card:hover, .pr-card:hover, .history-item:hover {
        transform: none; /* Disable hover effects on touch devices */
    }
}

/* Reduced Motion Support */
@media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* Enhanced Button States */
.btn-pressed {
    transform: scale(0.95) !important;
    transition: var(--transition-fast) !important;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none !important;
}

/* Form Validation */
input.invalid, select.invalid, textarea.invalid {
    border-color: var(--danger);
    box-shadow: 0 0 0 2px rgba(255, 59, 48, 0.2);
}

input.valid, select.valid, textarea.valid {
    border-color: var(--success);
    box-shadow: 0 0 0 2px rgba(39, 174, 96, 0.2);
}

label.invalid {
    color: var(--danger);
}

/* Enhanced Toast Styles */
.toast {
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 200px;
    justify-content: center;
}

.toast-icon {
    font-size: 1.2rem;
}

.toast-success {
    border-left: 4px solid var(--success);
}

.toast-error {
    border-left: 4px solid var(--danger);
}

.toast-warning {
    border-left: 4px solid var(--warning);
}

.toast-info {
    border-left: 4px solid var(--tertiary);
}

@keyframes slideOut {
    to {
        transform: translateX(-50%) translateY(100px);
        opacity: 0;
    }
}

/* Progressive Enhancement Classes */
.enhanced-ui .card {
    backdrop-filter: blur(10px);
}

.backdrop-filter-supported .modal {
    backdrop-filter: blur(20px);
}

.touch-device .btn:hover {
    transform: none; /* Disable hover effects on touch devices */
}

</style>

<!-- Boot error overlay for diagnosing iOS white screens -->
<div id="boot-error-overlay"><div class="content">
        <h2>Er is een fout opgetreden bij het laden</h2>
        <p id="boot-error-text">Onbekende fout. Probeer de app te herladen.</p>
        <button onclick="location.reload()" style="margin-top:12px;padding:10px 16px;background:#FF3B30;color:#fff;border:none;border-radius:8px;">Herladen</button>
</div></div>

<script>
// APP VERSION
const APP_VERSION = "2026-01-09-13";

// ============================================================================
// FIREBASE CONFIGURATION & INITIALIZATION
// ============================================================================
const firebaseConfig = {
    apiKey: "AIzaSyB_brKEajr99coKNb9_UZQUPIeKD26P5XE",
    authDomain: "gymtracker-68b70.firebaseapp.com",
    projectId: "gymtracker-68b70",
    storageBucket: "gymtracker-68b70.firebasestorage.app",
    messagingSenderId: "347914925318",
    appId: "1:347914925318:web:3391ecd13d94d80d769a87",
    measurementId: "G-8BTS671427"
};

// Initialize Firebase
let db = null;
let firebaseInitialized = false;

function initFirebase() {
    try {
        // Check if Firebase SDK is loaded
        if (typeof firebase === 'undefined') {
            console.error('❌ Firebase SDK not loaded - check internet connection or CDN');
            return false;
        }
        
        if (!firebaseInitialized) {
            console.log('🔥 Initializing Firebase...');
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            
            // Enable offline persistence
            db.enablePersistence({ synchronizeTabs: true })
                .then(() => console.log('🔥 Firebase offline persistence enabled'))
                .catch(err => {
                    if (err.code === 'failed-precondition') {
                        console.warn('⚠️ Multiple tabs open, persistence only in first tab');
                    } else if (err.code === 'unimplemented') {
                        console.warn('⚠️ Browser doesn\'t support persistence');
                    } else {
                        console.error('❌ Persistence error:', err);
                    }
                });
            
            firebaseInitialized = true;
            console.log('✅ Firebase initialized successfully');
            return true;
        }
        return true;
    } catch (error) {
        console.error('❌ Firebase initialization error:', error);
        if (error.code) console.error('Error code:', error.code);
        if (error.message) console.error('Error message:', error.message);
        return false;
    }
}

// ============================================================================
// 1RM CALCULATOR
// ============================================================================
const OneRepMaxCalculator = {
    // Berbagai formulas untuk 1RM calculation
    brzycki: (weight, reps) => weight * (36 / (37 - reps)),
    epley: (weight, reps) => weight * (1 + reps / 30),
    lombardi: (weight, reps) => weight * Math.pow(reps, 0.1),
    
    calculate(weight, reps, formula = 'brzycki') {
        if (reps <= 0 || weight <= 0) return 0;
        if (reps === 1) return weight;
        
        const methods = {
            brzycki: this.brzycki,
            epley: this.epley,
            lombardi: this.lombardi
        };
        
        const calc = methods[formula] || this.brzycki;
        return Math.round(calc(weight, reps) * 10) / 10;
    },
    
    // Estimate back from 1RM to other rep ranges
    estimateWeight(oneRepMax, targetReps, formula = 'brzycki') {
        if (targetReps === 1) return oneRepMax;
        
        // Use inverse calculation (approximation)
        if (formula === 'brzycki') {
            return Math.round(oneRepMax / (36 / (37 - targetReps)) * 10) / 10;
        } else if (formula === 'epley') {
            return Math.round(oneRepMax / (1 + targetReps / 30) * 10) / 10;
        }
        return oneRepMax;
    }
};

// ============================================================================
// WORKOUT STREAKS & STATISTICS
// ============================================================================
const WorkoutStats = {
    // Get all-time statistics
    getStats() {
        const history = getWorkoutHistory();
        const streaks = this.getStreaks();
        
        let totalWorkouts = history.length;
        let totalVolume = 0;
        let totalSets = 0;
        
        history.forEach(workout => {
            workout.exercises.forEach(ex => {
                ex.sets.forEach(set => {
                    totalSets++;
                    if (set.completed) {
                        totalVolume += (set.weight || 0) * (set.reps || 0);
                    }
                });
            });
        });
        
        return {
            totalWorkouts,
            totalVolume: Math.round(totalVolume),
            totalSets,
            currentStreak: streaks.current,
            longestStreak: streaks.longest,
            lastWorkoutDate: history.length > 0 ? history[history.length - 1].startTime : null
        };
    },
    
    // Calculate streaks based on consecutive workouts (not calendar days)
    getStreaks() {
        const history = getWorkoutHistory();
        if (history.length === 0) return { current: 0, longest: 0 };
        
        // Sort by date descending (most recent first)
        const sorted = [...history].sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        let currentStreak = 0;
        let longestStreak = 1;
        let streakCount = 0;
        
        // Group by unique dates to count workout days (not individual workouts)
        const workoutDates = [];
        let lastDate = null;
        
        for (let i = 0; i < sorted.length; i++) {
            const workoutDate = new Date(sorted[i].startTime);
            workoutDate.setHours(0, 0, 0, 0);
            
            // Only count once per date
            if (!lastDate || workoutDate.getTime() !== lastDate.getTime()) {
                workoutDates.push(workoutDate);
                lastDate = workoutDate;
            }
        }
        
        // Calculate current streak: workouts in a row
        streakCount = 1;
        for (let i = 0; i < workoutDates.length - 1; i++) {
            const current = workoutDates[i];
            const next = workoutDates[i + 1];
            const daysDiff = (current - next) / (1000 * 60 * 60 * 24);
            
            // Allow up to 3 days gap (for MWF schedules, allows Fri->Mon with weekend)
            if (daysDiff <= 3) {
                streakCount++;
            } else {
                break;
            }
        }
        
        // Current streak is only if last workout is recent (within last 3 days)
        currentStreak = 0;
        if (workoutDates.length > 0) {
            const lastWorkoutDate = workoutDates[0];
            const daysSinceLastWorkout = (today - lastWorkoutDate) / (1000 * 60 * 60 * 24);
            if (daysSinceLastWorkout <= 3) {
                currentStreak = streakCount;
            }
        }
        
        longestStreak = Math.max(streakCount, 1);
        
        return { current: currentStreak, longest: longestStreak };
    },
    
    // Save stats to localStorage
    saveStats() {
        const stats = this.getStats();
        try {
            localStorage.setItem('workout_stats', JSON.stringify(stats));
        } catch (e) {
            console.warn('Could not save workout stats');
        }
    },
    
    // Update the stats header display on the page
    updateStatsDisplay() {
        const stats = this.getStats();
        
        // Update workout count
        const workoutEl = document.getElementById('statTotalWorkouts');
        if (workoutEl) {
            workoutEl.textContent = stats.totalWorkouts;
        }
        
        // Update volume
        const volumeEl = document.getElementById('statTotalVolume');
        if (volumeEl) {
            volumeEl.textContent = stats.totalVolume + ' kg';
        }
        
        // Update streak badge with smart label
        const streakEl = document.getElementById('streakBadge');
        if (streakEl) {
            let badgeText = '';
            if (stats.currentStreak === 0) {
                badgeText = '💤 Geen serie';
            } else if (stats.currentStreak === 1) {
                badgeText = '🔥 1 workout';
            } else if (stats.currentStreak === 2) {
                badgeText = '⚡ 2 workouts';
            } else if (stats.currentStreak >= 3) {
                badgeText = '🔥 ' + stats.currentStreak + ' workouts';
            }
            streakEl.textContent = badgeText;
        }
    }
};

// ============================================================================
// FIRESTORE SYNC MODULE
// ============================================================================
const FirestoreSync = {
    enabled: false,
    userId: null,
    syncInProgress: false,
    lastSyncTime: null,
    
    // Initialize sync with a unique user ID
    init() {
        // Get or create unique user ID
        this.userId = localStorage.getItem('firebase_user_id');
        if (!this.userId) {
            this.userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('firebase_user_id', this.userId);
        }
        
        // Check if sync is enabled
        const syncEnabled = localStorage.getItem('cloud_sync_enabled');
        this.enabled = syncEnabled === 'true';
        
        if (this.enabled && initFirebase()) {
            console.log('🔄 Cloud Sync enabled for user:', this.userId);
            this.setupRealtimeSync();
        }
    },
    
    // Enable cloud sync
    async enable() {
        console.log('🔄 Attempting to enable Cloud Sync...');
        
        // Check if Firebase SDK is loaded
        if (typeof firebase === 'undefined') {
            console.error('❌ Firebase SDK niet geladen');
            const retry = await this.waitForFirebase();
            if (!retry) {
                alert('❌ Firebase SDK kon niet worden geladen. Check je internetverbinding en herlaad de pagina.');
                return false;
            }
        }
        
        // Try to initialize Firebase
        const initialized = initFirebase();
        if (!initialized) {
            console.error('❌ Firebase initialisatie mislukt');
            alert('❌ Firebase kon niet worden geïnitialiseerd. Controleer:\n\n1. Je internetverbinding\n2. Of Firestore Database is aangemaakt in Firebase Console\n3. Browser console (F12) voor details');
            return false;
        }
        
        this.enabled = true;
        localStorage.setItem('cloud_sync_enabled', 'true');
        
        try {
            // Initial upload of local data
            await this.uploadAllData();
            
            // Setup realtime sync
            this.setupRealtimeSync();
            
            console.log('✅ Cloud Sync ingeschakeld');
            return true;
        } catch (error) {
            console.error('❌ Cloud Sync enable error:', error);
            this.enabled = false;
            localStorage.setItem('cloud_sync_enabled', 'false');
            alert('❌ Fout bij uploaden van data: ' + error.message);
            return false;
        }
    },
    
    // Wait for Firebase SDK to load (with timeout)
    async waitForFirebase(maxWait = 5000) {
        const startTime = Date.now();
        while (typeof firebase === 'undefined' && Date.now() - startTime < maxWait) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        return typeof firebase !== 'undefined';
    },
    
    // Disable cloud sync
    disable() {
        this.enabled = false;
        localStorage.setItem('cloud_sync_enabled', 'false');
        console.log('❌ Cloud Sync uitgeschakeld');
    },
    
    // Upload all local data to Firestore
    async uploadAllData() {
        if (!this.enabled || !db) {
            console.error('❌ Cannot upload: sync not enabled or db not initialized');
            return;
        }
        
        try {
            console.log('☁️ Uploading data to cloud...');
            const userData = {
                workout_history: JSON.parse(localStorage.getItem('workout_history') || '[]'),
                workout_prs: JSON.parse(localStorage.getItem('workout_prs') || '{}'),
                workout_goals: JSON.parse(localStorage.getItem('workout_goals') || '[]'),
                workout_templates: JSON.parse(localStorage.getItem('workout_templates') || '[]'),
                workout_stats: JSON.parse(localStorage.getItem('workout_stats') || '{}'),
                gym_custom_exercises: JSON.parse(localStorage.getItem('gym_custom_exercises') || '[]'),
                gym_custom_schemas: JSON.parse(localStorage.getItem('gym_custom_schemas') || '[]'),
                gym_settings: JSON.parse(localStorage.getItem('gym_settings') || '{}'),
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            console.log('☁️ Data to upload:', {
                workouts: userData.workout_history.length,
                prs: Object.keys(userData.workout_prs).length,
                goals: userData.workout_goals.length,
                templates: userData.workout_templates.length,
                stats: Object.keys(userData.workout_stats).length,
                exercises: userData.gym_custom_exercises.length,
                schemas: userData.gym_custom_schemas.length
            });
            
            await db.collection('users').doc(this.userId).set(userData, { merge: true });
            this.lastSyncTime = Date.now();
            console.log('✅ Data uploaded successfully to cloud');
        } catch (error) {
            console.error('❌ Upload error:', error);
            console.error('Error details:', error.code, error.message);
            throw error; // Re-throw to be caught by enable()
        }
    },
    
    // Download data from Firestore
    async downloadAllData() {
        if (!this.enabled || !db) return;
        
        try {
            const doc = await db.collection('users').doc(this.userId).get();
            if (doc.exists) {
                const data = doc.data();
                
                // Update localStorage with cloud data
                if (data.workout_history) localStorage.setItem('workout_history', JSON.stringify(data.workout_history));
                if (data.workout_prs) localStorage.setItem('workout_prs', JSON.stringify(data.workout_prs));
                if (data.workout_goals) localStorage.setItem('workout_goals', JSON.stringify(data.workout_goals));
                if (data.workout_templates) localStorage.setItem('workout_templates', JSON.stringify(data.workout_templates));
                if (data.workout_stats) localStorage.setItem('workout_stats', JSON.stringify(data.workout_stats));
                if (data.gym_custom_exercises) localStorage.setItem('gym_custom_exercises', JSON.stringify(data.gym_custom_exercises));
                if (data.gym_custom_schemas) localStorage.setItem('gym_custom_schemas', JSON.stringify(data.gym_custom_schemas));
                if (data.gym_settings) localStorage.setItem('gym_settings', JSON.stringify(data.gym_settings));
                
                this.lastSyncTime = Date.now();
                console.log('☁️ Data downloaded from cloud');
                return true;
            }
        } catch (error) {
            console.error('❌ Download error:', error);
        }
        return false;
    },
    
    // Setup realtime sync listener
    setupRealtimeSync() {
        if (!this.enabled || !db) return;
        
        // Listen for remote changes
        db.collection('users').doc(this.userId).onSnapshot(snapshot => {
            if (snapshot.exists && !this.syncInProgress) {
                const data = snapshot.data();
                const remoteTimestamp = data.lastUpdated?.toMillis() || 0;
                
                // Only sync if remote is newer
                if (!this.lastSyncTime || remoteTimestamp > this.lastSyncTime) {
                    console.log('🔄 Remote changes detected, syncing...');
                    this.syncInProgress = true;
                    
                    // Update local data
                    if (data.workout_history) localStorage.setItem('workout_history', JSON.stringify(data.workout_history));
                    if (data.workout_prs) localStorage.setItem('workout_prs', JSON.stringify(data.workout_prs));
                    if (data.workout_goals) localStorage.setItem('workout_goals', JSON.stringify(data.workout_goals));
                    if (data.workout_templates) localStorage.setItem('workout_templates', JSON.stringify(data.workout_templates));
                    if (data.gym_custom_exercises) localStorage.setItem('gym_custom_exercises', JSON.stringify(data.gym_custom_exercises));
                    if (data.gym_custom_schemas) localStorage.setItem('gym_custom_schemas', JSON.stringify(data.gym_custom_schemas));
                    if (data.gym_settings) localStorage.setItem('gym_settings', JSON.stringify(data.gym_settings));
                    
                    this.lastSyncTime = remoteTimestamp;
                    this.syncInProgress = false;
                    
                    // Refresh UI if needed
                    if (typeof loadWorkoutHistory === 'function') loadWorkoutHistory();
                    if (typeof renderPRs === 'function') renderPRs();
                }
            }
        }, error => {
            console.error('❌ Realtime sync error:', error);
        });
    },
    
    // Sync after local changes
    async syncAfterChange() {
        if (!this.enabled || this.syncInProgress) return;
        
        // Debounce: wait 2 seconds before syncing
        clearTimeout(this.syncTimeout);
        this.syncTimeout = setTimeout(async () => {
            await this.uploadAllData();
        }, 2000);
    }
};

// Initialize Firebase Sync on load
window.addEventListener('load', () => {
    FirestoreSync.init();
});

// AUDIO CONTEXT for haptic feedback fallbacks
let audioContext = null;

function initAudioContext() {
    if (!audioContext) {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            console.log('🔊 Audio context initialized');
        } catch (error) {
            console.error('❌ Failed to initialize audio context:', error);
        }
    }

    // Resume context if suspended (required by browser autoplay policies)
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
            console.log('🔊 Audio context resumed');
        }).catch(error => {
            console.error('❌ Failed to resume audio context:', error);
        });
    }

    return audioContext;
}

// Voeg automatisch een test custom schema toe als er nog geen custom schemas zijn
document.addEventListener('DOMContentLoaded', function() {
    try {
        const stored = localStorage.getItem('gym_custom_schemas');
        if (!stored || stored === '{}' || stored === '[]') {
            const testSchema = {
                id: 'test-1',
                name: 'Voorbeeld schema',
                description: 'Dit is een automatisch toegevoegd testschema.',
                color: '#4A90E2',
                muscleGroups: [
                    { id: 'custom', name: 'Custom', exercises: [
                        { id: 1, name: 'Push-up', met: 4.5 },
                        { id: 2, name: 'Squat', met: 4.5 }
                    ]}
                ]
            };
            // Opslaan als object (oude code gebruikt object, sommige als array)
            localStorage.setItem('gym_custom_schemas', JSON.stringify({ [testSchema.id]: testSchema }));
            console.log('[init] Test custom schema toegevoegd aan localStorage');
        }
    } catch (e) {
        console.error('[init] Fout bij toevoegen test custom schema:', e);
    }

    // Check PWA status and show hint for iOS users
    setTimeout(() => {
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isPWA = window.navigator.standalone === true ||
                     window.matchMedia('(display-mode: standalone)').matches ||
                     document.referrer.includes('android-app://') ||
                     window.location.search.includes('pwa=true');

        if (isIOS && !isPWA && 'vibrate' in navigator) {
            showToast('📱 Installeer als PWA voor vibratie ondersteuning', 'warning', 5000);
            console.log('[PWA] iOS device detected without PWA - vibration may not work');
        }
    }, 2000);

    // Touch event voor lang-tap om console te openen (voor mobiele debugging)
    let touchStartTime = 0;
    let touchStartX = 0;
    let touchStartY = 0;

    document.body.addEventListener('touchstart', function(e) {
        touchStartTime = Date.now();
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    });

    document.body.addEventListener('touchend', function(e) {
        const touchEndTime = Date.now();
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;

        // Controleer of het een lang-tap is (500ms) en weinig beweging (< 10px)
        const duration = touchEndTime - touchStartTime;
        const distance = Math.sqrt(Math.pow(touchEndX - touchStartX, 2) + Math.pow(touchEndY - touchStartY, 2));

        if (duration > 500 && distance < 10) {
            // Toon console overlay
            document.getElementById('console-log-overlay').style.display = 'block';
            console.log('[touch] Console geopend via lang-tap');
            e.preventDefault();
        }
    });
});
// Console log overlay logic - moved after getSettings definition
// Basic boot error capture to reveal white-screen causes
(function(){
    function showBootError(msg){
        var el = document.getElementById('boot-error-overlay');
        var txt = document.getElementById('boot-error-text');
        if(el && txt){ txt.textContent = String(msg || 'Onbekende fout'); el.style.display = 'flex'; }
    }
    window.addEventListener('error', function(e){
        // Only show early boot errors (first 5s)
        if(performance.now() < 5000){ showBootError(e.message || 'Scriptfout'); }
    });
    window.addEventListener('unhandledrejection', function(e){
        if(performance.now() < 5000){ showBootError((e.reason && e.reason.message) || 'Promise fout'); }
    });
})();
</script>

<div class="container">
    <div class="header">
        <div class="header-top">
            <h1> Gym Tracker</h1>
        </div>
        <div class="header-tabs">
            <button class="tab active" data-view="workout" onclick="switchView('workout')"> Workout</button>
            <button class="tab" data-view="history" onclick="switchView('history')"> Historie</button>
            <button class="tab" data-view="progress" onclick="switchView('progress')"> Progressie</button>
            <button class="tab" data-view="prs" onclick="switchView('prs')"> 🏆 PRs</button>
            <button class="tab" data-view="beheer" onclick="switchView('beheer')"> 🛠️ Beheer</button>
            <button class="tab" data-view="settings" onclick="switchView('settings')"> ⚙️ Instellingen</button>
        </div>
        <!-- Schema beheer View wordt verplaatst naar buiten de header, op gelijk niveau met andere views -->
    <!-- Schema beheer View (verplaatst) -->
    <div id="schemasView" class="view">
        <div class="settings-container">
            <div class="settings-section">
                <h2>📋 Schema beheer</h2>
                <p style="color: var(--text-muted); margin-bottom: 1.5rem;">Overzicht van alle beschikbare schemas (standaard + eigen)</p>
                <div id="customSchemasList"></div>
                <div style="margin-top: 2rem;">
                    <button id="addSchemaBtn" onclick="showAddSchemaForm()" style="width: 100%; padding: 0.75rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">➕ Nieuw Schema Toevoegen</button>
                </div>
                <div id="addSchemaForm" style="display:none; margin-top: 2rem; padding: 1.5rem; background: var(--dark-card); border-radius: 12px; border: 1px solid var(--border);">
                    <h3 id="schemaFormTitle">Nieuw schema</h3>
                    <div style="display: grid; gap: 1rem; margin-top: 1rem;">
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Schema Naam *</label>
                            <input id="schemaNameInput" type="text" placeholder="bijv. Full Body" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-lighter); color: var(--text);">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Beschrijving</label>
                            <input id="schemaDescInput" type="text" placeholder="bijv. Complete workout" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-lighter); color: var(--text);">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Kleur *</label>
                            <input id="schemaColorInput" type="color" value="#4A90E2" style="width: 100%; height: 3rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-lighter);">
                        </div>
                        <div id="schemaExercisesSection" style="display:none;">
                            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Oefeningen</label>
                            <div id="schemaExercisesList" style="max-height: 200px; overflow-y: auto; margin-bottom: 1rem;"></div>
                            <div style="display: flex; gap: 0.5rem;">
                                <select id="exerciseNameInput" style="flex: 1; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-lighter); color: var(--text);">
                                    <option value="">-- Selecteer oefening --</option>
                                </select>
                                <button onclick="addExerciseToSchemaForm()" style="padding: 0.75rem 1rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">Toevoegen</button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                            <button id="schemaSaveBtn" onclick="saveNewSchema()" style="flex: 1; padding: 0.75rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">Opslaan</button>
                            <button onclick="hideAddSchemaForm()" style="flex: 1; padding: 0.75rem; background: var(--dark-lighter); color: var(--text); border: 1px solid var(--border); border-radius: 8px; font-weight: 600;">Annuleren</button>
                        </div>
                    </div>
                </div>
                <div id="schemaUiError" style="display:none;color:#FF3B30;margin-top:10px;"></div>
            </div>
        </div>
    </div>
    <script>
    // UI logica voor Schema beheer tabblad
    let schemaFormMode = 'add'; // 'add' of 'edit'
    let editingSchemaId = null;
    let editingExercises = [];

    function switchView(view) {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.querySelectorAll('.view').forEach(v => v.style.display = 'none');
        const el = document.getElementById(view + 'View');
        if (el) {
            el.classList.add('active');
            el.style.display = '';
            if (view === 'schemas') renderCustomSchemasList();
            if (view === 'settings') initCloudSyncUI();
            if (view === 'workout') updateWorkoutStatsDisplay();
        }
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        const tab = document.querySelector('.tab[data-view="' + view + '"]');
        if (tab) tab.classList.add('active');
    }
    
    // Update stats display when viewing workout
    function updateWorkoutStatsDisplay() {
        WorkoutStats.updateStatsDisplay();
    }
    // Fallback: altijd een view tonen na laden
    document.addEventListener('DOMContentLoaded', function() {
        const anyActive = document.querySelector('.view.active');
        if (!anyActive) {
            switchView('workout');
        }
    });

    function renderCustomSchemasList() {
        console.log('[renderCustomSchemasList] called');
        const list = document.getElementById('customSchemasList');
        const errorDiv = document.getElementById('schemaUiError');
        if (!list) {
            console.error('[renderCustomSchemasList] customSchemasList element not found');
            if (errorDiv) {
                errorDiv.style.display = '';
                errorDiv.textContent = 'Kan lijst van schemas niet tonen (UI-fout). Probeer te herladen.';
            }
            return;
        } else if (errorDiv) {
            errorDiv.style.display = 'none';
        }
        const allSchemas = getAllSchemas();
        console.log('[renderCustomSchemasList] all schemas:', allSchemas);
        list.innerHTML = '';
        allSchemas.forEach(schema => {
            const isDefault = schema.id.startsWith('schema');
            const oefList = (schema.muscleGroups && schema.muscleGroups.length > 0)
                ? schema.muscleGroups.map(g => g.exercises.map(e => e.name).join(", ")).join(" | ")
                : '';
            const actions = isDefault 
                ? '<small style="color: var(--text-muted);">(standaard - niet aanpasbaar)</small>'
                : `<button onclick=\"editSchemaForm('${schema.id}')\" style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600; margin-right: 0.5rem;">Bewerken</button> <button onclick=\"deleteCustomSchemaUI('${schema.id}')\" style="padding: 0.5rem 1rem; background: var(--danger); color: white; border: none; border-radius: 8px; font-weight: 600;">Verwijderen</button>`;
            list.innerHTML += `<div style="background: ${schema.color}; color: white; padding: 1rem; border-radius: 12px; margin-bottom: 1rem; border: 1px solid var(--border);">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
                    <h3 style="margin: 0; font-size: 1.2rem; font-weight: 700;">${schema.name}</h3>
                </div>
                ${schema.description ? `<p style="margin: 0.5rem 0; color: rgba(255,255,255,0.9);">${schema.description}</p>` : ''}
                <p style="margin: 0.5rem 0; font-size: 0.9rem; color: rgba(255,255,255,0.8);"><strong>Oefeningen:</strong> ${oefList || 'geen'}</p>
                <div style="margin-top: 1rem;">${actions}</div>
            </div>`;
        });
        // Zorg dat de "Nieuw schema toevoegen" knop altijd zichtbaar is
        const addBtn = document.getElementById('addSchemaBtn');
        if (addBtn) addBtn.style.display = '';
    }

    function showAddSchemaForm() {
            console.log('[showAddSchemaForm] called');
        schemaFormMode = 'add';
        editingSchemaId = null;
        editingExercises = [];
        if (document.getElementById('schemaFormTitle')) document.getElementById('schemaFormTitle').innerText = 'Nieuw schema';
        if (document.getElementById('schemaNameInput')) document.getElementById('schemaNameInput').value = '';
        if (document.getElementById('schemaDescInput')) document.getElementById('schemaDescInput').value = '';
        if (document.getElementById('schemaColorInput')) document.getElementById('schemaColorInput').value = getNextSchemaColor();
        populateExerciseSelect();
        if (document.getElementById('schemaExercisesSection')) document.getElementById('schemaExercisesSection').style.display = '';
        renderSchemaExercisesList();
        if (document.getElementById('addSchemaForm')) document.getElementById('addSchemaForm').style.display = '';
        if (document.getElementById('schemaSaveBtn')) document.getElementById('schemaSaveBtn').onclick = saveNewSchema;
        // Zorg dat de form altijd zichtbaar is als de knop is gebruikt
        const addBtn = document.getElementById('addSchemaBtn');
        if (addBtn) addBtn.style.display = '';
    }
    function hideAddSchemaForm() {
            console.log('[hideAddSchemaForm] called');
        if (document.getElementById('addSchemaForm')) document.getElementById('addSchemaForm').style.display = 'none';
        // Reset save knop naar saveNewSchema na sluiten
        if (document.getElementById('schemaSaveBtn')) document.getElementById('schemaSaveBtn').onclick = saveNewSchema;
        // Zorg dat de "Nieuw schema toevoegen" knop altijd zichtbaar blijft
        const addBtn = document.getElementById('addSchemaBtn');
        if (addBtn) addBtn.style.display = '';
    }
    function saveNewSchema() {
            console.log('[saveNewSchema] called');
        const name = (document.getElementById('schemaNameInput')||{}).value ? document.getElementById('schemaNameInput').value.trim() : '';
        const desc = (document.getElementById('schemaDescInput')||{}).value ? document.getElementById('schemaDescInput').value.trim() : '';
        const color = (document.getElementById('schemaColorInput')||{}).value || '#4A90E2';
        if (!name) return alert('Naam is verplicht');
        if (!Array.isArray(editingExercises)) editingExercises = [];
        const muscleGroups = groupExercisesByMuscleGroup(editingExercises);
        addCustomSchema({ name, description: desc, color, icon: "💪", muscleGroups });
        hideAddSchemaForm();
        renderCustomSchemasList();
    }
    function deleteCustomSchemaUI(id) {
            console.log('[deleteCustomSchemaUI] called for id:', id);
        if (id.startsWith('schema')) {
            alert('Standaard schemas kunnen niet worden verwijderd.');
            return;
        }
        if (confirm('Weet je zeker dat je dit schema wilt verwijderen?')) {
            deleteCustomSchema(id);
            renderCustomSchemasList();
        }
    }
    function editSchemaForm(id) {
            console.log('[editSchemaForm] called for id:', id);
        if (id.startsWith('schema')) {
            alert('Standaard schemas kunnen niet worden bewerkt.');
            return;
        }
        schemaFormMode = 'edit';
        editingSchemaId = id;
        const custom = getCustomSchemas();
        const schema = custom.find(s => s.id === id);
        if (!schema) return;
        if (document.getElementById('schemaFormTitle')) document.getElementById('schemaFormTitle').innerText = 'Schema bewerken';
        if (document.getElementById('schemaNameInput')) document.getElementById('schemaNameInput').value = schema.name;
        if (document.getElementById('schemaDescInput')) document.getElementById('schemaDescInput').value = schema.description;
        if (document.getElementById('schemaColorInput')) document.getElementById('schemaColorInput').value = schema.color;
        populateExerciseSelect();
        // Oefeningen laden - alle oefeningen uit alle groepen
        editingExercises = [];
        if (schema.muscleGroups) {
            schema.muscleGroups.forEach(group => {
                if (group.exercises) {
                    editingExercises.push(...group.exercises.map(e => ({ ...e })));
                }
            });
        }
        if (document.getElementById('schemaExercisesSection')) document.getElementById('schemaExercisesSection').style.display = '';
        renderSchemaExercisesList();
        if (document.getElementById('addSchemaForm')) document.getElementById('addSchemaForm').style.display = '';
        if (document.getElementById('schemaSaveBtn')) document.getElementById('schemaSaveBtn').onclick = saveEditSchema;
    }
    function saveEditSchema() {
            console.log('[saveEditSchema] called');
        const name = (document.getElementById('schemaNameInput')||{}).value ? document.getElementById('schemaNameInput').value.trim() : '';
        const desc = (document.getElementById('schemaDescInput')||{}).value ? document.getElementById('schemaDescInput').value.trim() : '';
        const color = (document.getElementById('schemaColorInput')||{}).value || '#4A90E2';
        if (!name) return alert('Naam is verplicht');
        if (!Array.isArray(editingExercises)) editingExercises = [];
        const muscleGroups = groupExercisesByMuscleGroup(editingExercises);
        updateCustomSchema(editingSchemaId, { name, description: desc, color, icon: "💪", muscleGroups });
        hideAddSchemaForm();
        renderCustomSchemasList();
    }
    function populateExerciseSelect() {
        const select = document.getElementById('exerciseNameInput');
        if (!select) return;
        select.innerHTML = '<option value="">-- Selecteer oefening --</option>';
        const allExercises = getAllExercises();
        allExercises.forEach(exercise => {
            const option = document.createElement('option');
            option.value = exercise.name;
            option.textContent = `${exercise.name} (${exercise.muscleGroup || 'Custom'})`;
            select.appendChild(option);
        });
    }
    function addExerciseToSchemaForm() {
            console.log('[addExerciseToSchemaForm] called');
        const name = (document.getElementById('exerciseNameInput')||{}).value ? document.getElementById('exerciseNameInput').value.trim() : '';
        if (!name) return;
        if (!Array.isArray(editingExercises)) editingExercises = [];
        // Find the exercise to get met and muscleGroup
        const allExercises = getAllExercises();
        const exercise = allExercises.find(e => e.name === name);
        if (!exercise) return alert('Oefening niet gevonden');
        // Check if already added
        if (editingExercises.some(e => e.name === name)) return alert('Oefening al toegevoegd');
        // Uniek id genereren
        const id = Date.now() + Math.floor(Math.random()*1000);
        editingExercises.push({ id, name, met: exercise.met, muscleGroup: exercise.muscleGroup || 'Custom' });
        if (document.getElementById('exerciseNameInput')) document.getElementById('exerciseNameInput').value = '';
        renderSchemaExercisesList();
    }
    function removeExerciseFromSchemaForm(idx) {
            console.log('[removeExerciseFromSchemaForm] called for idx:', idx);
        if (!Array.isArray(editingExercises)) editingExercises = [];
        editingExercises.splice(idx, 1);
        renderSchemaExercisesList();
    }
    function renderSchemaExercisesList() {
            console.log('[renderSchemaExercisesList] called');
        const list = document.getElementById('schemaExercisesList');
        if (!list) return;
        if (!Array.isArray(editingExercises)) editingExercises = [];
        list.innerHTML = '';
        editingExercises.forEach((ex, idx) => {
            list.innerHTML += `<div style='display:flex;align-items:center;gap:8px;margin:2px 0;'>
                <span>${ex.name}</span>
                <button onclick="removeExerciseFromSchemaForm(${idx})" style='font-size:0.9em;'>Verwijder</button>
            </div>`;
        });
    }
    </script>
    </div>

    <!-- Workout View -->
    <div id="workoutView" class="view active">
        <!-- Workout Selection Header -->
        <div class="workout-selection-header">
            <h2>🏋️‍♂️ Kies je Workout</h2>
            <div class="workout-selection-tabs">
                <button id="schemaTab" class="selection-tab active" onclick="showSchemaSelection()">Schema's</button>
                <button id="templateTab" class="selection-tab" onclick="showTemplatesView()">Templates</button>
            </div>
        </div>
        
        <div id="schemaSelection" class="schema-grid">
            <!-- Dynamically filled -->
        </div>

        <!-- Workout Templates Section -->
        <div id="templateSelection" class="template-grid" style="display: none;">
            <div class="template-header">
                <h2>📋 Mijn Workout Templates</h2>
                <p style="color: var(--text-muted); margin: 0.5rem 0 1rem 0;">Snel starten met je favoriete routines</p>
                <button onclick="showTemplateSelection()" style="padding: 0.5rem 1rem; background: var(--dark-lighter); color: var(--text); border: 1px solid var(--border); border-radius: 8px; font-weight: 600;">← Terug naar Schema's</button>
            </div>
            <div id="templateList" class="template-list">
                <!-- Templates will be populated here -->
            </div>
        </div>

        <div id="activeWorkout" style="display: none;">
            <!-- Workout Stats Header -->
            <div style="background: var(--dark-card); border-radius: 12px; padding: 1rem; margin-bottom: 1rem; border-left: 4px solid #4A90E2;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                    <h3 style="margin: 0; font-size: 1rem;">📊 Workout Stats</h3>
                    <span id="streakBadge" style="background: linear-gradient(135deg, #FF6B35, #FF8C42); padding: 0.35rem 0.75rem; border-radius: 20px; font-size: 0.85rem; font-weight: bold; color: white;">🔥 0 dagen</span>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; font-size: 0.9rem;">
                    <div>
                        <span style="color: var(--text-muted);">Totaal Workouts</span>
                        <div style="font-size: 1.5rem; font-weight: bold; color: #4A90E2;" id="statTotalWorkouts">0</div>
                    </div>
                    <div>
                        <span style="color: var(--text-muted);">Totaal Volume</span>
                        <div style="font-size: 1.5rem; font-weight: bold; color: #50C878;" id="statTotalVolume">0 kg</div>
                    </div>
                </div>
            </div>

            <div class="timer-card" id="timerCard">
                <div class="timer-content">
                    <div class="timer-label">Workout Tijd</div>
                    <div class="timer" id="timer">00:00</div>
                    <div class="timer-meta" id="exerciseMeta">Oefeningen: 0/0</div>
                    <div class="timer-inline-stats">
                        <div class="timer-stat">
                            <span class="timer-stat-label">Sets</span>
                            <span class="timer-stat-value" id="statSets">0</span>
                        </div>
                        <div class="timer-stat">
                            <span class="timer-stat-label">Kcal 🔥</span>
                            <span class="timer-stat-value" id="statKcal">0</span>
                        </div>
                    </div>
                    <div class="timer-controls">
                        <button class="btn btn-secondary" onclick="toggleTimer()" id="timerBtn">
                            <span id="timerIcon"></span>
                            <span id="timerText">Start</span>
                        </button>
                        <button class="btn btn-secondary" onclick="resetTimer()"> Reset</button>
                    </div>
                </div>
            </div>

            <!-- Rest Timer Overlay -->
            <div class="rest-timer-overlay" id="restTimerOverlay">
                <div class="rest-timer-card" id="restTimerCard">
                    <div class="rest-timer-header">
                        <div class="rest-timer-title" id="restTimerLabel">Rust: 1:30</div>
                        <div class="rest-timer-actions">
                            <button class="btn btn-secondary" style="padding:0.35rem 0.75rem; font-size:0.85rem;" onclick="refreshRestTimer()">Refresh</button>
                            <button class="btn btn-secondary" style="padding:0.35rem 0.75rem; font-size:0.85rem;" onclick="stopRestTimer()">Stop</button>
                        </div>
                    </div>
                    <div class="rest-timer-progress">
                        <div id="restTimerProgress"></div>
                    </div>
                </div>
            </div>

            <div id="exercisesContainer"></div>
        </div>
    </div>

    <!-- History View -->
    <div id="historyView" class="view">
        <div class="calendar-container" id="calendarContainer"></div>
        <div id="historyContainer"></div>
    </div>

    <!-- Progress View -->
    <div id="progressView" class="view">
        <div id="progressContainer"></div>
    </div>

    <!-- PRs View -->
    <div id="prsView" class="view">
        <div class="prs-header">
            <h2>🏆 Persoonlijke Records</h2>
            <p style="color: var(--text-muted); margin: 0.5rem 0 1rem 0;">Je beste prestaties per oefening</p>
            <div class="prs-controls" style="display: flex; gap: 1rem; align-items: center;">
                <select id="prsSortSelect" onchange="renderPRs()" style="padding: 0.5rem; border-radius: 8px; border: 1px solid var(--border); background: var(--dark-card); color: var(--text); flex: 1;">
                    <option value="date">Sorteren op datum</option>
                    <option value="name">Sorteren op naam</option>
                    <option value="weight">Sorteren op gewicht</option>
                    <option value="onerm">Sorteren op 1RM</option>
                </select>
                <button onclick="openOneRMModal()" style="padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid var(--border); background: var(--primary); color: white; font-weight: 600; white-space: nowrap;">💪 1RM Calc</button>
            </div>
        </div>
        <div id="prsContainer"></div>
    </div>

    <!-- Beheer View -->
    <div id="beheerView" class="view">
        <div class="beheer-container">
            <div class="beheer-tabs-container">
                <div class="beheer-tabs">
                    <button class="beheer-tab active" data-beheer-view="goals" onclick="switchBeheerView('goals')">🎯 Doelen</button>
                    <button class="beheer-tab" data-beheer-view="statistics" onclick="switchBeheerView('statistics')">📊 Statistieken</button>
                    <button class="beheer-tab" data-beheer-view="exercises" onclick="switchBeheerView('exercises')">💪 Oefeningen</button>
                    <button class="beheer-tab" data-beheer-view="schemas" onclick="switchBeheerView('schemas')">📋 Schema beheer</button>
                </div>
                <div class="beheer-tabs-indicator"></div>
            </div>
            <div class="beheer-content">
                <!-- Content will be switched here -->
            </div>
        </div>
    </div>

    <!-- Goals View -->
    <div id="goalsView" class="view">
        <div class="goals-header">
            <h2>🎯 Workout Doelen</h2>
            <p style="color: var(--text-muted); margin: 0.5rem 0 1rem 0;">Stel doelen en volg je vooruitgang</p>
            <button onclick="showAddGoalModal()" style="padding: 0.75rem 1.5rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">➕ Nieuw Doel</button>
        </div>
        <div id="goalsContainer"></div>
    </div>

    <!-- Analytics View -->
    <div id="analyticsView" class="view">
        <div class="analytics-header">
            <h2>📊 Workout Analytics</h2>
            <p style="color: var(--text-muted); margin: 0.5rem 0 1rem 0;">Diepe inzichten in je workout patronen</p>
            <div class="analytics-controls">
                <select id="analyticsPeriodSelect" onchange="renderAnalytics()" style="padding: 0.5rem; border-radius: 8px; border: 1px solid var(--border); background: var(--dark-card); color: var(--text);">
                    <option value="30">Laatste 30 dagen</option>
                    <option value="90">Laatste 90 dagen</option>
                    <option value="180">Laatste 6 maanden</option>
                    <option value="365">Laatste jaar</option>
                </select>
            </div>
        </div>
        <div id="analyticsContainer"></div>
    </div>

    <!-- Statistics View -->
    <div id="statisticsView" class="view">
        <div class="statistics-header">
            <h2>📊 Statistieken</h2>
            <input type="hidden" id="periodSelector" value="week">
            <div class="period-buttons" role="group" aria-label="Selecteer periode">
                <button type="button" class="period-btn active" data-period="week" onclick="setPeriod('week')">Deze week</button>
                <button type="button" class="period-btn" data-period="month" onclick="setPeriod('month')">Deze maand</button>
                <button type="button" class="period-btn" data-period="year" onclick="setPeriod('year')">Dit jaar</button>
                <button type="button" class="period-btn" data-period="all" onclick="setPeriod('all')">Alles</button>
            </div>
        </div>
        <div id="statisticsContainer"></div>
    </div>

    <!-- Settings View -->
    <div id="settingsView" class="view">
        <div class="settings-container">
            <div class="settings-section">
                <h2>⚙️ Instellingen</h2>

                <div class="settings-item">
                    <div class="settings-label">
                        <span>App Versie</span>
                        <span class="settings-description">Actieve build op dit device</span>
                    </div>
                    <div class="settings-control">
                        <span id="appVersionText" class="settings-version">…</span>
                    </div>
                </div>

                <div class="settings-item">
                    <div class="settings-label">
                        <span>Cache Opnieuw Laden</span>
                        <span class="settings-description">Forceer herladen naar nieuwste versie</span>
                    </div>
                    <button class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.875rem;" onclick="forceReload()">
                        🔄 Herladen
                    </button>
                </div>

                <div class="settings-divider"></div>
                
                <div class="settings-item">
                    <div class="settings-label">
                        <span>Donker Thema</span>
                        <span class="settings-description">Schakel tussen donker en licht thema</span>
                    </div>
                    <div class="settings-control">
                        <div class="toggle-switch" id="themeToggle" onclick="toggleDarkMode()" title="Toggle dark/light mode">
                            <span class="toggle-icon">🌙</span>
                            <div class="toggle-slider"></div>
                            <span class="toggle-icon">☀️</span>
                        </div>
                    </div>
                </div>

                <div class="settings-item">
                    <div class="settings-label">
                        <span>Debug Logging</span>
                        <span class="settings-description">Toon console logs voor debugging</span>
                    </div>
                    <div class="settings-control">
                        <div class="toggle-switch" id="loggingToggle" onclick="toggleLogging()" title="Toggle debug logging">
                            <span class="toggle-icon">🔇</span>
                            <div class="toggle-slider"></div>
                            <span class="toggle-icon">🔊</span>
                        </div>
                    </div>
                </div>

                <div class="settings-item">
                    <div class="settings-label">
                        <span>Test Modus</span>
                        <span class="settings-description">Korte timer (3 sec) voor testing</span>
                    </div>
                    <div class="settings-control">
                        <div class="toggle-switch" id="testModeToggle" onclick="toggleTestMode()" title="Toggle test mode">
                            <span class="toggle-icon">⏱️</span>
                            <div class="toggle-slider"></div>
                            <span class="toggle-icon">⚡</span>
                        </div>
                    </div>
                </div>

                <div class="settings-item">
                    <div class="settings-label">
                        <span>Spraakherkenning</span>
                        <span class="settings-description">Microfoonknop voor gesproken oefeningen</span>
                    </div>
                    <div class="settings-control">
                        <div class="toggle-switch" id="voiceRecognitionToggle" onclick="toggleVoiceRecognition()" title="Toggle voice recognition">
                            <span class="toggle-icon">🔇</span>
                            <div class="toggle-slider"></div>
                            <span class="toggle-icon">🎤</span>
                        </div>
                    </div>
                </div>

                <div class="settings-divider"></div>

                <h3>📦 Backup & Synchronisatie</h3>
                
                <div class="settings-backup-grid">
                    <button class="btn btn-primary" onclick="exportBackup()" style="width: 100%;">
                        ⬇️ Export Data
                    </button>
                    <button class="btn btn-primary" onclick="exportWorkoutsJSON()" style="width: 100%;">
                        ⬇️ Export Workouts (JSON, 180d)
                    </button>
                    <button class="btn btn-secondary" onclick="importBackup()" style="width: 100%;">
                        ⬆️ Import Data
                    </button>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                    <div class="settings-tip">
                        <p>
                            💡 Tip: Backup bevat al je workouts, PRs en instellingen. Bewaar in OneDrive voor sync tussen apparaten.
                        </p>
                    </div>
                </div>

                <div class="settings-divider"></div>

                <h3>☁️ Cloud Synchronisatie (Firebase)</h3>
                
                <div class="setting-row">
                    <div class="setting-label">
                        <div class="setting-title">Cloud Sync</div>
                        <div class="setting-description">Automatische sync tussen al je apparaten via Firebase</div>
                    </div>
                    <div class="setting-control">
                        <label class="toggle">
                            <input type="checkbox" id="cloudSyncToggle" onchange="toggleCloudSync(this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>

                <div class="settings-backup-grid">
                    <button class="btn btn-secondary" onclick="manualCloudSync()" style="width: 100%;" id="manualSyncBtn" disabled>
                        🔄 Handmatig Synchroniseren
                    </button>
                    <div class="settings-tip" id="cloudSyncStatus">
                        <p id="cloudSyncStatusText">
                            ℹ️ Cloud Sync is uitgeschakeld. Zet aan voor automatische backup en sync tussen devices.
                        </p>
                    </div>
                </div>

                <div class="settings-divider"></div>

                <h3>🔑 Sync Key (Koppel Devices)</h3>
                
                <div class="settings-backup-grid">
                    <div class="settings-tip" style="grid-column: 1 / -1;">
                        <p>
                            💡 <strong>Gebruik dezelfde Sync Key op al je devices om data te synchroniseren!</strong><br>
                            1️⃣ Genereer of kopieer je Sync Key hieronder<br>
                            2️⃣ Voer deze key in op je andere devices<br>
                            3️⃣ Alle devices syncen nu naar dezelfde account
                        </p>
                    </div>
                    
                    <div style="grid-column: 1 / -1; display: flex; gap: 0.5rem; align-items: center;">
                        <input type="text" id="syncKeyInput" readonly 
                               style="flex: 1; padding: 0.75rem; border-radius: 8px; border: 1px solid var(--border); 
                                      background: var(--dark-card); color: var(--text); font-family: monospace; font-size: 0.9rem;"
                               placeholder="Je huidige Sync Key...">
                        <button class="btn btn-secondary" onclick="copySyncKey()" style="min-width: auto; padding: 0.75rem 1rem;">
                            📋 Kopieer
                        </button>
                    </div>
                    
                    <button class="btn btn-primary" onclick="showChangeSyncKeyDialog()" style="width: 100%;">
                        🔄 Wijzig/Voer Sync Key In
                    </button>
                    
                    <button class="btn btn-secondary" onclick="generateNewSyncKey()" style="width: 100%;">
                        ✨ Nieuwe Key Genereren
                    </button>
                </div>

                <div class="settings-divider"></div>

                <div class="settings-item">
                    <div class="settings-label">
                        <span>Lichaamsgewicht</span>
                        <span class="settings-description">Gebruikt voor calorieberekening (kg)</span>
                    </div>
                    <div class="settings-counter">
                        <button onclick="updateBodyWeight((parseInt(document.getElementById('bodyWeightInput').value) || 75) - 1)">−</button>
                        <input type="number" id="bodyWeightInput" min="30" max="200" value="75" readonly>
                        <button onclick="updateBodyWeight((parseInt(document.getElementById('bodyWeightInput').value) || 75) + 1)">+</button>
                    </div>
                </div>

                <div class="settings-item">
                    <div class="settings-label">
                        <span>MET Waarde</span>
                        <span class="settings-description">Intensiteit voor calorieberekening</span>
                    </div>
                    <div class="settings-counter">
                        <button onclick="updateMETValue((parseFloat(document.getElementById('metValueInput').value) || 4.5) - 0.1)">−</button>
                        <input type="number" id="metValueInput" min="1.0" max="15.0" step="0.1" value="4.5" readonly>
                        <button onclick="updateMETValue((parseFloat(document.getElementById('metValueInput').value) || 4.5) + 0.1)">+</button>
                    </div>
                </div>

                <div class="settings-item">
                    <div class="settings-label">
                        <span>Standaard Sets</span>
                        <span class="settings-description">Aantal sets per oefening</span>
                    </div>
                    <div class="settings-counter">
                        <button onclick="updateDefaultSets((parseInt(document.getElementById('defaultSetsInput').value) || 3) - 1)">−</button>
                        <input type="number" id="defaultSetsInput" min="1" max="10" value="3" readonly>
                        <button onclick="updateDefaultSets((parseInt(document.getElementById('defaultSetsInput').value) || 3) + 1)">+</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Exercises View -->
    <div id="exercisesView" class="view">
        <div class="settings-container">
            <div class="settings-section">
                <h2>💪 Oefeningen</h2>
                <p style="color: var(--text-muted); margin-bottom: 1.5rem;">Overzicht van alle beschikbare oefeningen (standaard + eigen)</p>
                <div style="margin-bottom: 1rem;">
                    <button onclick="showInlineExerciseForm()" style="width: 100%; padding: 0.75rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">➕ Nieuwe Oefening Toevoegen</button>
                </div>
                <div id="exercisesList"></div>
            </div>
        </div>
    </div>
</div>

<!-- Inline Add Exercise Form (shown when FAB clicked) -->
<div id="inlineAddExercise" style="display: none; margin: 1rem 0; padding: 1rem; background: var(--dark-card); border-radius: 12px; border: 1px solid var(--border); position: relative; z-index: 1000; margin-bottom: 120px;">
    <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
        <button id="addNewExerciseBtn" onclick="showNewExerciseForm()" style="flex: 1; padding: 0.5rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">Nieuwe oefening</button>
        <button id="addExistingExerciseBtn" onclick="showExistingExerciseForm()" style="flex: 1; padding: 0.5rem; background: var(--dark-lighter); color: var(--text); border: 1px solid var(--border); border-radius: 8px; font-weight: 600;">Bestaande oefening</button>
    </div>
    
    <!-- New Exercise Form -->
    <div id="newExerciseForm" style="display: block;">
        <h3 style="margin: 0 0 1rem 0; color: var(--primary);">➕ Voeg Nieuwe Oefening Toe</h3>
        <div style="display: grid; gap: 1rem;">
            <div>
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Oefening Naam *</label>
                <input type="text" id="inlineExerciseName" placeholder="bijv. Bicep Curls" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-lighter); color: var(--text);">
            </div>
            <div>
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Spiergroep *</label>
                <select id="inlineMuscleGroup" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-lighter); color: var(--text);">
                    <option value="">-- Selecteer spiergroep --</option>
                </select>
            </div>
            <div>
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">MET Waarde *</label>
                <input type="number" id="inlineExerciseMET" placeholder="bijv. 4.5" step="0.1" min="1" max="15" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-lighter); color: var(--text);">
            </div>
            <div>
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">📹 Instructie Video URL (optioneel)</label>
                <input type="url" id="inlineExerciseVideoUrl" placeholder="bijv. https://www.youtube.com/watch?v=..." style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-lighter); color: var(--text);">
                <small style="display: block; margin-top: 0.25rem; color: var(--text-muted); font-size: 0.8rem;">💡 YouTube, Vimeo of directe video link</small>
            </div>
            <div style="display: flex; gap: 0.5rem;">
                <button onclick="saveInlineExercise()" style="flex: 1; padding: 0.75rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">Toevoegen</button>
                <button onclick="hideInlineExerciseForm()" style="flex: 1; padding: 0.75rem; background: var(--dark-lighter); color: var(--text); border: 1px solid var(--border); border-radius: 8px; font-weight: 600;">Annuleren</button>
            </div>
        </div>
    </div>
    
    <!-- Existing Exercise Form -->
    <div id="existingExerciseForm" style="display: none;">
        <h3 style="margin: 0 0 1rem 0; color: var(--primary);">📚 Voeg Bestaande Oefening Toe</h3>
        <div id="existingExercisesList" style="max-height: 300px; overflow-y: auto; margin-bottom: 1rem;">
            <!-- Exercises will be populated here -->
        </div>
        <div style="display: flex; gap: 0.5rem;">
            <button onclick="hideInlineExerciseForm()" style="flex: 1; padding: 0.75rem; background: var(--dark-lighter); color: var(--text); border: 1px solid var(--border); border-radius: 8px; font-weight: 600;">Annuleren</button>
        </div>
    </div>
</div>

<!-- Floating Button for Adding Custom Exercise -->
<button class="fab-add-exercise" id="fabAddExercise" onclick="showInlineExerciseForm()" title="Voeg oefening toe">
    <span>+</span>
</button>

<!-- Floating Button for Voice Adding Exercise -->
<button class="fab-voice-add" id="fabVoiceAdd" onclick="startVoiceAdd()" title="Spraakherkenning - zeg een oefening">
    <span>🎤</span>
</button>

<div class="bottom-actions" id="bottomActions">
    <button class="btn btn-secondary" onclick="cancelWorkout()"> Annuleren</button>
    <button class="btn btn-outline" onclick="showSaveTemplateDialog()" title="Sla deze workout op als template">📋 Template</button>
    <button class="btn btn-primary" onclick="finishWorkout()"> Voltooien</button>
</div>

<div class="pr-celebration" id="prCelebration">
    <div class="pr-content">
        <div class="pr-emoji"></div>
        <div class="pr-title">NIEUW PR!</div>
        <div class="pr-detail" id="prDetail"></div>
        <div class="pr-sub" id="prSub"></div>
        <button class="btn btn-primary" onclick="closePRCelebration()">Awesome! </button>
    </div>
</div>

<!-- Add Custom Exercise Modal -->
<div class="modal" id="addExerciseModal">
    <div class="modal-content" style="max-width: 500px;">
        <div class="modal-header">
            <h2>➕ Voeg Oefening Toe</h2>
            <button class="modal-close" onclick="closeAddExerciseModal()">✕</button>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>Oefening Naam *</label>
                <input type="text" id="customExerciseName" placeholder="bijv. Bicep Curls" class="form-input">
            </div>
            <div class="form-group">
                <label>Spiergroep *</label>
                <select id="customMuscleGroup" class="form-input">
                    <option value="">-- Selecteer spiergroep --</option>
                </select>
            </div>
            <div class="form-group">
                <label>MET Waarde * (Metabolic Equivalent)</label>
                <input type="number" id="customExerciseMET" placeholder="bijv. 4.5" step="0.1" min="1" max="15" class="form-input">
            </div>
            <div class="form-group">
                <label>📹 Instructie Video URL (optioneel)</label>
                <input type="url" id="customExerciseVideoUrl" placeholder="bijv. https://www.youtube.com/watch?v=..." class="form-input">
                <small style="display: block; margin-top: 0.25rem; color: var(--text-muted); font-size: 0.85rem;">💡 YouTube, Vimeo of directe video link</small>
            </div>
            <div class="form-group">
                <label style="font-size: 0.85rem; color: var(--text-muted);">💡 MET bepaalt calorieverbruik. Typische waarden: 3-5 (cardio), 5-8 (kracht)</label>
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeAddExerciseModal()">Annuleren</button>
            <button class="btn btn-primary" onclick="saveCustomExercise()">Toevoegen</button>
        </div>
    </div>
</div>

<!-- Finish Workout Confirmation Modal -->
<div class="modal" id="finishWorkoutModal">
    <div class="modal-content" style="max-width: 400px;">
        <div class="modal-header">
            <h2>🏁 Workout Voltooien</h2>
            <button class="modal-close" onclick="closeFinishWorkoutModal()">✕</button>
        </div>
        <div class="modal-body">
            <div style="text-align: center; padding: 1rem 0;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">🎯</div>
                <p style="margin: 0; font-size: 1.1rem; color: var(--text);">Weet je zeker dat je deze workout wilt voltooien?</p>
                <p style="margin: 1rem 0 0 0; font-size: 0.9rem; color: var(--text-muted);">Dit kan niet ongedaan worden gemaakt.</p>
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeFinishWorkoutModal()">Annuleren</button>
            <button class="btn btn-primary" onclick="confirmFinishWorkout()">Ja, Voltooien</button>
        </div>
    </div>
</div>

<!-- 1RM Calculator Modal -->
<div class="modal" id="oneRMModal">
    <div class="modal-content" style="max-width: 400px;">
        <div class="modal-header">
            <h2>💪 1RM Calculator</h2>
            <button class="modal-close" onclick="closeOneRMModal()">✕</button>
        </div>
        <div class="modal-body">
            <div style="display: grid; gap: 1rem;">
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-muted); font-size: 0.9rem;">Gewicht (kg)</label>
                    <input type="number" id="oneRMWeight" placeholder="Bijv. 100" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-card); color: var(--text); box-sizing: border-box;" />
                </div>
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-muted); font-size: 0.9rem;">Reps</label>
                    <input type="number" id="oneRMReps" placeholder="Bijv. 5" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-card); color: var(--text); box-sizing: border-box;" />
                </div>
                <div>
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-muted); font-size: 0.9rem;">Formule</label>
                    <select id="oneRMFormula" style="width: 100%; padding: 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--dark-card); color: var(--text); box-sizing: border-box;">
                        <option value="brzycki">Brzycki</option>
                        <option value="epley">Epley</option>
                        <option value="lombardi">Lombardi</option>
                    </select>
                </div>
                <div id="oneRMResult" style="text-align: center; padding: 1rem; background: var(--dark-card); border-radius: 8px; display: none;">
                    <div style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 0.5rem;">Geschatte 1RM</div>
                    <div id="oneRMResultValue" style="font-size: 2rem; font-weight: bold; color: #4A90E2;">-</div>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="closeOneRMModal()">Sluiten</button>
            <button class="btn btn-primary" onclick="calculateAndShowOneRM()">Bereken</button>
        </div>
    </div>
</div>

<!-- Video Player Modal -->
<div class="modal" id="videoModal">
    <div class="modal-content" style="max-width: 900px;">
        <div class="modal-header">
            <h2>📹 <span id="videoModalTitle">Instructie Video</span></h2>
            <button class="modal-close" onclick="closeVideoModal()">✕</button>
        </div>
        <div class="modal-body" style="padding: 0;">
            <div id="videoPlayerContainer" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; background: #000; border-radius: 12px;">
                <iframe 
                    id="videoPlayer" 
                    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 12px;" 
                    frameborder="0" 
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                    allowfullscreen
                    sandbox="allow-scripts allow-same-origin allow-presentation"
                ></iframe>
            </div>
            <div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.85rem;">
                💡 Als de video niet wordt afgespeeld, kan het zijn dat embedden door de eigenaar is uitgeschakeld. Probeer de video op YouTube te openen.
            </div>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="openVideoInNewTab()" id="openVideoBtn">Open op YouTube</button>
            <button class="btn btn-primary" onclick="closeVideoModal()">Sluiten</button>
        </div>
    </div>
</div>

<div class="toast" id="toast"></div>

<script>// WORKOUT DATA
// App version for cache-busting (always bump by 1)
// Enforce versioned URL so clients always fetch the latest build
(async function enforceVersionedUrl() {
    try {
        const storedVersion = localStorage.getItem("app_version");
        const url = new URL(location.href);
        const currentV = url.searchParams.get("v");
        
        // Version mismatch detected - force clear cache and reload
        if (storedVersion && storedVersion !== APP_VERSION) {
            console.log(`🔄 Version upgrade: ${storedVersion} → ${APP_VERSION}`);
            
            // In secure contexts, clear SW and caches; else skip to avoid SecurityError
            const isSecure = (window.isSecureContext && (location.protocol === 'https:' || location.hostname === 'localhost'));
            if (isSecure) {
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    for (let registration of registrations) {
                        await registration.unregister();
                        console.log("🗑️ Service worker unregistered");
                    }
                }
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    await Promise.all(cacheNames.map(name => caches.delete(name)));
                    console.log("🗑️ Caches cleared");
                }
            } else {
                // console.info("ℹ️ Skipping SW/caches clear in insecure context");
            }
            
            // Update version and force reload with cache bust
            localStorage.setItem("app_version", APP_VERSION);
            url.searchParams.set("v", APP_VERSION);
            url.searchParams.set("t", Date.now().toString());
            location.replace(url.toString());
            return;
        }
        
        // First visit or URL param mismatch
        if (currentV !== APP_VERSION) {
            url.searchParams.set("v", APP_VERSION);
            url.searchParams.set("t", Date.now().toString());
            localStorage.setItem("app_version", APP_VERSION);
            location.replace(url.toString());
            return;
        }
        
        localStorage.setItem("app_version", APP_VERSION);
        console.log("✅ App loaded:", APP_VERSION);
    } catch (e) {
        console.error("⚠️ Version check error:", e);
    }
})();

// Default schemas (niet aanpasbaar)
const DEFAULT_SCHEMAS = [
    {
        id: "schema1",
        name: "Schema 1",
        description: "Upper Body Push/Pull",
        color: "#B8E6B8",
        icon: "🏋️‍♂️",
        muscleGroups: [
            {
                id: "borst",
                name: "Borst",
                icon: "💪",
                exercises: [
                    { id: 101, name: "Chest Press", met: 4.5, icon: "🏋️‍♂️" },
                    { id: 102, name: "DB Press", met: 4.5, icon: "🏋️‍♀️" },
                    { id: 118, name: "DB Chest Turn Shoulder Press", met: 4.5, icon: "🤸‍♂️" }
                ]
            },
            {
                id: "schouder",
                name: "Schouder",
                icon: "🤸‍♀️",
                exercises: [
                    { id: 103, name: "Flyes", met: 4.5, icon: "🦅" },
                    { id: 104, name: "Pull Down", met: 4.5, icon: "🏗️" },
                    { id: 107, name: "Shoulder Press", met: 4.5, icon: "🤸‍♀️" }
                ]
            },
            {
                id: "rug",
                name: "Rug",
                icon: "🚣‍♂️",
                exercises: [
                    { id: 105, name: "Seated Row", met: 4.5, icon: "🚣‍♂️" }
                ]
            },
            {
                id: "triceps_biceps",
                name: "Triceps / Biceps",
                icon: "💪",
                exercises: [
                    { id: 106, name: "One Arm Row", met: 4.5, icon: "🚣‍♀️" },
                    { id: 108, name: "Front Side Raise", met: 4.5, icon: "🤾‍♂️" }
                ]
            }
        ]
    },
    {
        id: "schema2",
        name: "Schema 2",
        description: "Legs & Arms - Lower Body Focus",
        color: "#F4C2A1",
        icon: "🦵",
        muscleGroups: [
            {
                id: "benen",
                name: "Benen",
                icon: "🦵",
                exercises: [
                    { id: 109, name: "Leg Press", met: 4.5, icon: "🦵" },
                    { id: 110, name: "Leg Curl", met: 4.5, icon: "🦵" },
                    { id: 111, name: "Hack Squad", met: 4.5, icon: "🦵" }
                ]
            },
            {
                id: "triceps_biceps_2",
                name: "Triceps / Biceps",
                icon: "💪",
                exercises: [
                    { id: 112, name: "French Press", met: 4.5, icon: "💪" },
                    { id: 113, name: "Biceps Barbell Curl", met: 4.5, icon: "💪" },
                    { id: 114, name: "Incl. Dumbbell Curl", met: 4.5, icon: "💪" },
                    { id: 115, name: "Reverse Curl", met: 4.5, icon: "💪" },
                    { id: 116, name: "Triceps Extension", met: 4.5, icon: "💪" },
                    { id: 117, name: "Hammer Curl DB", met: 4.5, icon: "💪" }
                ]
            }
        ]
    }
];

// CRUD voor custom schemas (opgeslagen als array in localStorage)
function getCustomSchemas() {
        console.log('[getCustomSchemas] called');
    try {
        const stored = localStorage.getItem("gym_custom_schemas");
        const parsed = stored ? JSON.parse(stored) : [];
        return Array.isArray(parsed) ? parsed : [];
    } catch (e) {
        return [];
    }
}

function saveCustomSchemas(schemas) {
    try {
        localStorage.setItem("gym_custom_schemas", JSON.stringify(schemas));
    } catch (e) {}
}

function getNextCustomSchemaId() {
    const custom = getCustomSchemas();
    let maxId = 0;
    custom.forEach(s => {
        const n = parseInt((s.id||'').replace('custom',''));
        if (!isNaN(n) && n > maxId) maxId = n;
    });
    return `custom${maxId+1}`;
}

function getNextSchemaColor() {
    const colorPalette = [
        "#B8E6B8", // Pastel Green (schema1)
        "#F4C2A1", // Pastel Orange (schema2)
        "#5AC8FA", // Blue
        "#FF3B30", // Red
        "#AF52DE", // Purple
        "#FFCC00", // Yellow
        "#32D74B", // Light Green
        "#FF9F0A", // Dark Orange
        "#64D2FF", // Light Blue
        "#FF453A"  // Light Red
    ];
    const allSchemas = getAllSchemas();
    const usedColors = allSchemas.map(s => s.color);
    for (const color of colorPalette) {
        if (!usedColors.includes(color)) {
            return color;
        }
    }
    // If all used, return first
    return colorPalette[0];
}

function groupExercisesByMuscleGroup(exercises) {
    const groups = {};
    exercises.forEach(ex => {
        const groupName = ex.muscleGroup || 'Custom';
        if (!groups[groupName]) {
            groups[groupName] = [];
        }
        groups[groupName].push(ex);
    });
    return Object.entries(groups).map(([name, exs]) => ({
        id: name.toLowerCase().replace(/\s+/g, '_'),
        name: name,
        icon: "💪",
        exercises: exs
    }));
}

function getAllSchemas() {
    const custom = getCustomSchemas();
    if (!Array.isArray(custom)) {
        console.error('getCustomSchemas did not return an array:', custom);
        return [...DEFAULT_SCHEMAS];
    }
    return [...DEFAULT_SCHEMAS, ...custom];
}

function addCustomSchema(schema) {
    const custom = getCustomSchemas();
    const id = getNextCustomSchemaId();
    custom.push({ ...schema, id });
    saveCustomSchemas(custom);
}

function updateCustomSchema(id, updates) {
    const custom = getCustomSchemas();
    const idx = custom.findIndex(s => s.id === id);
    if (idx !== -1) {
        custom[idx] = { ...custom[idx], ...updates };
        saveCustomSchemas(custom);
    }
}

function deleteCustomSchema(id) {
    let custom = getCustomSchemas();
    custom = custom.filter(s => s.id !== id);
    saveCustomSchemas(custom);
}

const WORKOUT_DATA = {
    get schemas() {
        return getAllSchemas();
    }
};

// STATE
let currentView = "workout";
const collapsedExercises = {};
let currentWorkout = null;
let timerInterval = null;
let timerSeconds = 0;
let timerStartMs = null;
let timerAccumulatedMs = 0;
let timerRunning = false;
let restTimerInterval = null;
let restTimerRemaining = 0;
let restTimerTotal = 0;
let restTimerEndAt = null;
const getRestDuration = () => getSettings().testMode ? 10 : 90;
let progressState = { schemaId: null, exerciseId: null };
let currentRestExerciseId = null;

// CUSTOM EXERCISES MANAGEMENT
function getCustomExercises() {
    try {
        const stored = localStorage.getItem("gym_custom_exercises");
        return stored ? JSON.parse(stored) : {};
    } catch (e) {
        return {};
    }
}

function saveCustomExercises(exercises) {
    try {
        localStorage.setItem("gym_custom_exercises", JSON.stringify(exercises));
    } catch (e) {}
}

function getAllExercises() {
    const allExercises = [];
    
    // Add standard exercises
    WORKOUT_DATA.schemas.forEach(schema => {
        schema.muscleGroups.forEach(group => {
            group.exercises.forEach(exercise => {
                allExercises.push({
                    ...exercise,
                    muscleGroup: group.name
                });
            });
        });
    });
    
    // Add custom exercises
    const custom = getCustomExercises();
    Object.values(custom).forEach(exercise => {
        allExercises.push({
            ...exercise,
            custom: true
        });
    });
    
    // Sort by name
    allExercises.sort((a, b) => a.name.localeCompare(b.name));
    
    return allExercises;
}

function getNextCustomExerciseId() {
    const custom = getCustomExercises();
    const existingIds = Object.keys(custom).map(k => parseInt(k));
    const maxId = Math.max(0, ...existingIds);
    return 9000 + (maxId >= 9000 ? maxId - 9000 + 1 : 1);
}

// SETTINGS
function getSettings() {
    const defaults = {
        bodyWeight: 75,
        metValue: 4.5,
        defaultSets: 3,
        loggingEnabled: false,
        testMode: false,
        voiceRecognitionEnabled: false
    };
    const stored = localStorage.getItem("gym_settings");
    return stored ? { ...defaults, ...JSON.parse(stored) } : defaults;
}

function saveSettings(settings) {
    try {
        localStorage.setItem("gym_settings", JSON.stringify(settings));
    } catch (e) {}
}

// Console log overlay logic
(function(){
    const overlay = document.getElementById('console-log-overlay');
    const content = document.getElementById('console-log-content');
    if (!overlay || !content) return;
    function appendLog(msg, type) {
        if (!getSettings().loggingEnabled) return;
        const el = document.createElement('div');
        el.textContent = `[${type}] ${msg}`;
        el.style.marginBottom = '2px';
        if(type==='error') el.style.color = '#FF3B30';
        if(type==='warn') el.style.color = '#FFCC00';
        content.appendChild(el);
        overlay.style.display = 'block';
        // Scroll to bottom
        content.scrollTop = content.scrollHeight;
    }
    const origLog = console.log;
    const origErr = console.error;
    const origWarn = console.warn;
    console.log = function(...args){ appendLog(args.join(' '), 'log'); origLog.apply(console, args); };
    console.error = function(...args){ appendLog(args.join(' '), 'error'); origErr.apply(console, args); };
    console.warn = function(...args){ appendLog(args.join(' '), 'warn'); origWarn.apply(console, args); };
    window.addEventListener('error', function(e){ appendLog(e.message + ' @ ' + (e.filename||'') + ':' + (e.lineno||''), 'error'); });
    window.addEventListener('unhandledrejection', function(e){ appendLog('Unhandled promise rejection: ' + (e.reason && e.reason.message ? e.reason.message : e.reason), 'error'); });
})();

// COLOR HELPERS
function shadeColor(hex, percent) {
    if (typeof hex !== "string" || !/^#([0-9A-Fa-f]{6})$/.test(hex)) return hex || "#4A90E2";
    const num = parseInt(hex.slice(1), 16);
    const amt = Math.round(2.55 * percent);
    const r = (num >> 16) + amt;
    const g = ((num >> 8) & 0x00FF) + amt;
    const b = (num & 0x0000FF) + amt;
    return '#' + (
        0x1000000 +
        (r < 255 ? (r < 0 ? 0 : r) : 255) * 0x10000 +
        (g < 255 ? (g < 0 ? 0 : g) : 255) * 0x100 +
        (b < 255 ? (b < 0 ? 0 : b) : 255)
    ).toString(16).slice(1);
}

function getSchemaAccentPair(color) {
    const accent = (typeof color === "string" && color.startsWith("#")) ? color : "#4A90E2";
    return {
        accent,
        accent2: shadeColor(accent, -12)
    };
}

function getSchemaColor(schemaId) {
    const schema = getAllSchemas().find(s => s.id === schemaId);
    return (schema && schema.color) ? schema.color : "#4A90E2";
}

function hexToRgba(hex, alpha = 0.35) {
    if (typeof hex !== "string" || !/^#([0-9A-Fa-f]{6})$/.test(hex)) return 'rgba(74, 144, 226, ' + alpha + ')';
    const num = parseInt(hex.slice(1), 16);
    const r = (num >> 16) & 255;
    const g = (num >> 8) & 255;
    const b = num & 255;
    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
}

// CUSTOM EXERCISE MANAGEMENT
function getAllMuscleGroups() {
    const muscleGroups = new Map();
    
    getAllSchemas().forEach(schema => {
        schema.muscleGroups.forEach(group => {
            if (!muscleGroups.has(group.id)) {
                muscleGroups.set(group.id, group.name);
            }
        });
    });
    
    return Array.from(muscleGroups.entries()).sort((a, b) => a[1].localeCompare(b[1]));
}

function showInlineExerciseForm() {
    const form = document.getElementById('inlineAddExercise');
    if (!form) return;
    
    // Show new exercise form by default
    showNewExerciseForm();
    form.style.display = 'block';
    form.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function showNewExerciseForm() {
    document.getElementById('newExerciseForm').style.display = 'block';
    document.getElementById('existingExerciseForm').style.display = 'none';
    document.getElementById('addNewExerciseBtn').style.background = 'var(--primary)';
    document.getElementById('addNewExerciseBtn').style.color = 'white';
    document.getElementById('addExistingExerciseBtn').style.background = 'var(--dark-lighter)';
    document.getElementById('addExistingExerciseBtn').style.color = 'var(--text)';
    
    // Populate muscle groups for new exercise form
    const selectEl = document.getElementById('inlineMuscleGroup');
    selectEl.innerHTML = '<option value="">-- Selecteer spiergroep --</option>';
    getAllMuscleGroups().forEach(([id, name]) => {
        const option = document.createElement('option');
        option.value = id;
        option.textContent = name;
        selectEl.appendChild(option);
    });
}

function showExistingExerciseForm() {
    document.getElementById('newExerciseForm').style.display = 'none';
    document.getElementById('existingExerciseForm').style.display = 'block';
    document.getElementById('addNewExerciseBtn').style.background = 'var(--dark-lighter)';
    document.getElementById('addNewExerciseBtn').style.color = 'var(--text)';
    document.getElementById('addExistingExerciseBtn').style.background = 'var(--primary)';
    document.getElementById('addExistingExerciseBtn').style.color = 'white';
    
    // Populate existing exercises list
    populateExistingExercises();
}

function populateExistingExercises() {
    const container = document.getElementById('existingExercisesList');
    if (!container) return;
    
    // Get all exercises (standard + custom)
    const allExercises = [];
    
    // Add standard exercises from schemas
    getAllSchemas().forEach(schema => {
        schema.muscleGroups.forEach(group => {
            group.exercises.forEach(exercise => {
                allExercises.push({
                    ...exercise,
                    muscleGroup: group.name,
                    muscleGroupIcon: group.icon,
                    isCustom: false
                });
            });
        });
    });
    
    // Add custom exercises
    const customExercises = getCustomExercises();
    Object.values(customExercises).forEach(exercise => {
        // Find the muscle group info
        let muscleGroup = null;
        for (const schema of getAllSchemas()) {
            const group = schema.muscleGroups.find(g => g.id === exercise.muscleGroupId);
            if (group) {
                muscleGroup = group;
                break;
            }
        }
        
        if (muscleGroup) {
            allExercises.push({
                ...exercise,
                muscleGroup: muscleGroup.name,
                muscleGroupIcon: muscleGroup.icon,
                isCustom: true
            });
        }
    });
    
    // Sort exercises alphabetically
    allExercises.sort((a, b) => a.name.localeCompare(b.name));
    
    // Group by muscle group
    const groupedExercises = {};
    allExercises.forEach(exercise => {
        if (!groupedExercises[exercise.muscleGroup]) {
            groupedExercises[exercise.muscleGroup] = {
                icon: exercise.muscleGroupIcon,
                exercises: []
            };
        }
        groupedExercises[exercise.muscleGroup].exercises.push(exercise);
    });
    
    // Render the list
    container.innerHTML = Object.entries(groupedExercises).map(([groupName, data]) => `
        <div style="margin-bottom: 1rem;">
            <div style="display: flex; align-items: center; margin-bottom: 0.5rem; padding: 0.5rem; background: var(--dark-lighter); border-radius: 8px;">
                <span style="font-size: 1.2rem; margin-right: 0.5rem;">${data.icon}</span>
                <h4 style="margin: 0; font-size: 0.9rem; font-weight: 600;">${groupName}</h4>
            </div>
            <div style="display: grid; gap: 0.5rem;">
                ${data.exercises.map(exercise => `
                    <button onclick="addExistingExerciseToWorkout(${exercise.id})" 
                            style="display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; background: var(--dark-lighter); border: 1px solid var(--border); border-radius: 8px; color: var(--text); text-align: left; cursor: pointer;">
                        <div>
                            <div style="font-weight: 600;">${exercise.name}</div>
                            <div style="font-size: 0.8rem; color: var(--text-muted);">MET: ${exercise.met}</div>
                        </div>
                        <div style="font-size: 1.2rem;">${exercise.isCustom ? '⭐' : '📚'}</div>
                    </button>
                `).join('')}
            </div>
        </div>
    `).join('');
}

function addExistingExerciseToWorkout(exerciseId) {
    if (!currentWorkout) {
        showToast('❌ Geen actieve workout');
        return;
    }
    
    // Find the exercise in standard exercises or custom exercises
    let exercise = null;
    
    // Check standard exercises
    for (const schema of getAllSchemas()) {
        for (const group of schema.muscleGroups) {
            exercise = group.exercises.find(e => e.id === exerciseId);
            if (exercise) {
                exercise = {
                    ...exercise,
                    muscleGroup: group.name,
                    muscleGroupIcon: group.icon
                };
                break;
            }
        }
        if (exercise) break;
    }
    
    // Check custom exercises if not found
    if (!exercise) {
        const customExercises = getCustomExercises();
        const customExercise = customExercises[exerciseId];
        if (customExercise) {
            // Find muscle group info
            let muscleGroup = null;
            for (const schema of getAllSchemas()) {
                const group = schema.muscleGroups.find(g => g.id === customExercise.muscleGroupId);
                if (group) {
                    muscleGroup = group;
                    break;
                }
            }
            
            if (muscleGroup) {
                exercise = {
                    ...customExercise,
                    muscleGroup: muscleGroup.name,
                    muscleGroupIcon: muscleGroup.icon
                };
            }
        }
    }
    
    if (!exercise) {
        showToast('❌ Oefening niet gevonden');
        return;
    }
    
    // Check if exercise is already in the workout
    const existingExercise = currentWorkout.exercises.find(e => e.id === exerciseId);
    if (existingExercise) {
        showToast('⚠️ Oefening staat al in deze workout');
        return;
    }
    
    // Add exercise to current workout
    const settings = getSettings();
    const sets = [];
    for (let i = 0; i < settings.defaultSets; i++) {
        sets.push({
            reps: 12,
            weight: getInitialWeight(exercise.id),
            completed: false
        });
    }
    
    currentWorkout.exercises.push({
        ...exercise,
        sets
    });
    
    renderExercises();
    hideInlineExerciseForm();
    showToast(`✅ Oefening '${exercise.name}' toegevoegd aan workout!`);
}

function hideInlineExerciseForm() {
    const form = document.getElementById('inlineAddExercise');
    if (form) {
        form.style.display = 'none';
        // Clear form
        document.getElementById('inlineExerciseName').value = '';
        document.getElementById('inlineMuscleGroup').value = '';
        document.getElementById('inlineExerciseMET').value = '';
        document.getElementById('inlineExerciseVideoUrl').value = '';
    }
}

function saveInlineExercise() {
    const name = document.getElementById('inlineExerciseName').value.trim();
    const muscleGroupId = document.getElementById('inlineMuscleGroup').value;
    const met = parseFloat(document.getElementById('inlineExerciseMET').value) || 0;
    const videoUrl = document.getElementById('inlineExerciseVideoUrl').value.trim();
    
    // Validation
    if (!name) {
        showToast('❌ Vul oefening naam in');
        return;
    }
    if (!muscleGroupId) {
        showToast('❌ Selecteer spiergroep');
        return;
    }
    if (met < 1 || met > 15) {
        showToast('❌ MET waarde moet tussen 1 en 15 zijn');
        return;
    }
    
    // Zoek spiergroep naam uit alle schemas
    let muscleGroup = null;
    for (const schema of getAllSchemas()) {
        const group = schema.muscleGroups.find(g => g.id === muscleGroupId);
        if (group) {
            muscleGroup = group;
            break;
        }
    }
    if (!muscleGroup) {
        showToast('❌ Spiergroep niet gevonden');
        return;
    }
    
    // Maak custom oefening aan
    const id = getNextCustomExerciseId();
    const custom = getCustomExercises();
    custom[id] = {
        id,
        name,
        met,
        muscleGroupId,
        muscleGroupName: muscleGroup.name,
        icon: "💪",
        custom: true,
        videoUrl: videoUrl || null
    };
    saveCustomExercises(custom);
    
    // Als er een actieve workout is, voeg de oefening toe aan de huidige workout
    console.log('currentWorkout exists:', !!currentWorkout);
    if (currentWorkout) {
        console.log('Adding exercise to current workout');
        const settings = getSettings();
        const sets = [];
        for (let i = 0; i < settings.defaultSets; i++) {
            sets.push({
                reps: 12,
                weight: 0, // Start with 0 for custom exercises
                completed: false
            });
        }
        
        currentWorkout.exercises.push({
            id,
            name,
            met,
            muscleGroup: muscleGroup.name,
            muscleGroupIcon: muscleGroup.icon,
            sets
        });
        
        renderExercises();
        showToast(`✅ Oefening '${name}' toegevoegd aan workout!`);
    } else {
        console.log('No active workout, saving to library only');
        // Update lijst als je in oefeningen-tab zit
        const exercisesView = document.getElementById("exercisesView");
        if (exercisesView && exercisesView.style.display !== "none") {
            renderExercisesList();
        }
        showToast(`✅ Oefening '${name}' opgeslagen in bibliotheek!`);
    }
    
    hideInlineExerciseForm();
}

function closeAddExerciseModal() {
    const modal = document.getElementById('addExerciseModal');
    if (modal) modal.classList.remove('active');
    // Clear form
    const nameInput = document.getElementById('customExerciseName');
    const groupInput = document.getElementById('customMuscleGroup');
    const metInput = document.getElementById('customExerciseMET');
    const videoInput = document.getElementById('customExerciseVideoUrl');

    if(nameInput) nameInput.value = '';
    if(groupInput) groupInput.value = '';
    if(metInput) metInput.value = '';
    if(videoInput) videoInput.value = '';
    
    // Reset Edit State
    currentEditingExerciseId = null;
    const modalTitle = document.querySelector('#addExerciseModal h2');
    const submitBtn = document.querySelector('#addExerciseModal .modal-footer .btn-primary');
    
    if(modalTitle) modalTitle.textContent = '➕ Voeg Oefening Toe';
    if(submitBtn) submitBtn.textContent = 'Toevoegen';
}

function showFinishWorkoutModal() {
    const modal = document.getElementById('finishWorkoutModal');
    modal.classList.add('active');
}

function closeFinishWorkoutModal() {
    const modal = document.getElementById('finishWorkoutModal');
    modal.classList.remove('active');
}

function confirmFinishWorkout() {
    closeFinishWorkoutModal();
    proceedFinishWorkout();
}

// 1RM Calculator Modal Functions
function openOneRMModal() {
    const modal = document.getElementById('oneRMModal');
    modal.classList.add('active');
    document.getElementById('oneRMWeight').value = '';
    document.getElementById('oneRMReps').value = '';
    document.getElementById('oneRMResult').style.display = 'none';
}

function closeOneRMModal() {
    const modal = document.getElementById('oneRMModal');
    modal.classList.remove('active');
}

// Video Modal Functions
let currentVideoUrl = null;

function openVideoModal(exerciseName, videoUrl) {
    if (!videoUrl) {
        showToast('Geen video beschikbaar', 'error');
        return;
    }
    
    const modal = document.getElementById('videoModal');
    const titleEl = document.getElementById('videoModalTitle');
    const playerEl = document.getElementById('videoPlayer');
    
    titleEl.textContent = exerciseName;
    currentVideoUrl = videoUrl;
    
    // Convert YouTube/Vimeo URLs to embed URLs
    const embedUrl = convertToEmbedUrl(videoUrl);
    playerEl.src = embedUrl;
    
    modal.classList.add('active');
}

function closeVideoModal() {
    const modal = document.getElementById('videoModal');
    const playerEl = document.getElementById('videoPlayer');
    
    // Stop video playback
    playerEl.src = '';
    currentVideoUrl = null;
    
    modal.classList.remove('active');
}

function openVideoInNewTab() {
    if (currentVideoUrl) {
        window.open(currentVideoUrl, '_blank');
    }
}

function convertToEmbedUrl(url) {
    // YouTube - support various URL formats
    const youtubeRegex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/;
    const youtubeMatch = url.match(youtubeRegex);
    if (youtubeMatch && youtubeMatch[1]) {
        // Add parameters to allow embedding and avoid restrictions
        return `https://www.youtube-nocookie.com/embed/${youtubeMatch[1]}?autoplay=0&rel=0&modestbranding=1`;
    }
    
    // Vimeo
    const vimeoRegex = /vimeo\.com\/(?:.*\/)?(\d+)/;
    const vimeoMatch = url.match(vimeoRegex);
    if (vimeoMatch && vimeoMatch[1]) {
        return `https://player.vimeo.com/video/${vimeoMatch[1]}?title=0&byline=0&portrait=0`;
    }
    
    // Direct video or already embed URL
    return url;
}

function calculateAndShowOneRM() {
    const weight = parseFloat(document.getElementById('oneRMWeight').value);
    const reps = parseInt(document.getElementById('oneRMReps').value);
    const formula = document.getElementById('oneRMFormula').value;
    
    if (!weight || weight <= 0 || !reps || reps <= 0) {
        showToast('Voer geldige waarden in', 'error');
        return;
    }
    
    const oneRM = OneRepMaxCalculator.calculate(weight, reps, formula);
    const resultEl = document.getElementById('oneRMResult');
    const resultValueEl = document.getElementById('oneRMResultValue');
    
    resultValueEl.textContent = oneRM.toFixed(1) + ' kg';
    resultEl.style.display = 'block';
}

let currentEditingExerciseId = null;

function editCustomExercise(id) {
    const custom = getCustomExercises();
    const exercise = custom[id];
    if (!exercise) return;

    currentEditingExerciseId = id;
    
    // Populate muscle groups dropdown first
    const groupInput = document.getElementById('customMuscleGroup');
    if (groupInput) {
        groupInput.innerHTML = '<option value="">-- Selecteer spiergroep --</option>';
        getAllMuscleGroups().forEach(([groupId, groupName]) => {
            const option = document.createElement('option');
            option.value = groupId;
            option.textContent = groupName;
            groupInput.appendChild(option);
        });
    }
    
    const nameInput = document.getElementById('customExerciseName');
    const metInput = document.getElementById('customExerciseMET');
    const videoInput = document.getElementById('customExerciseVideoUrl');

    if(nameInput) nameInput.value = exercise.name;
    if(metInput) metInput.value = exercise.met;
    if(groupInput) groupInput.value = exercise.muscleGroupId;
    if(videoInput) videoInput.value = exercise.videoUrl || '';
    
    const modalTitle = document.querySelector('#addExerciseModal h2');
    const submitBtn = document.querySelector('#addExerciseModal .modal-footer .btn-primary');

    if(modalTitle) modalTitle.textContent = '✏️ Oefening Aanpassen';
    if(submitBtn) submitBtn.textContent = 'Opslaan';
    
    const modal = document.getElementById('addExerciseModal');
    if(modal) modal.classList.add('active');
}

function saveCustomExercise() {
    const name = document.getElementById('customExerciseName').value.trim();
    const muscleGroupId = document.getElementById('customMuscleGroup').value;
    const met = parseFloat(document.getElementById('customExerciseMET').value) || 0;
    const videoUrl = document.getElementById('customExerciseVideoUrl').value.trim();
    
    console.log('Form values:', { name, muscleGroupId, met, videoUrl });
    
    // Validation
    if (!name) {
        showToast('❌ Vul oefening naam in');
        return;
    }
    if (!muscleGroupId) {
        showToast('❌ Selecteer spiergroep');
        return;
    }
    if (met < 1 || met > 15) {
        showToast('❌ MET waarde moet tussen 1 en 15 zijn');
        return;
    }
    
    // Zoek spiergroep naam uit alle schemas
    let muscleGroup = null;
    for (const schema of getAllSchemas()) {
        const group = schema.muscleGroups.find(g => g.id === muscleGroupId);
        if (group) {
            muscleGroup = group;
            break;
        }
    }
    if (!muscleGroup) {
        showToast('❌ Spiergroep niet gevonden');
        return;
    }
    // Maak custom oefening aan of update bestaande
    const custom = getCustomExercises();
    let id;
    let isUpdate = false;

    if (currentEditingExerciseId) {
        id = currentEditingExerciseId;
        isUpdate = true;
        if (custom[id]) {
            custom[id] = {
                ...custom[id],
                name,
                met,
                muscleGroupId,
                muscleGroupName: muscleGroup.name,
                videoUrl: videoUrl || null
            };
        }
    } else {
        id = getNextCustomExerciseId();
        custom[id] = {
            id,
            name,
            met,
            muscleGroupId,
            muscleGroupName: muscleGroup.name,
            icon: "💪",
            custom: true,
            videoUrl: videoUrl || null
        };
    }
    
    saveCustomExercises(custom);
    
    if (isUpdate) {
        renderExercisesList();
        showToast(`✅ Oefening '${name}' bijgewerkt!`);
        currentEditingExerciseId = null;
    } else {
        // Als er een actieve workout is, voeg de oefening toe aan de huidige workout (alleen bij nieuw)
        console.log('currentWorkout exists:', !!currentWorkout);
        if (currentWorkout) {
            console.log('Adding exercise to current workout');
            const settings = getSettings();
            const sets = [];
            for (let i = 0; i < settings.defaultSets; i++) {
                sets.push({
                    reps: 12,
                    weight: 0, // Start with 0 for custom exercises
                    completed: false
                });
            }
            
            currentWorkout.exercises.push({
                id,
                name,
                met,
                muscleGroup: muscleGroup.name,
                muscleGroupIcon: muscleGroup.icon,
                sets
            });
            
            renderExercises();
            showToast(`✅ Oefening '${name}' toegevoegd aan workout!`);
        } else {
            console.log('No active workout, saving to library only');
            // Update lijst als je in oefeningen-tab zit
            const exercisesView = document.getElementById("exercisesView");
            if (exercisesView && exercisesView.style.display !== "none") {
                renderExercisesList();
            }
            showToast(`✅ Oefening '${name}' opgeslagen in bibliotheek!`);
        }
    }
    
    closeAddExerciseModal();

}

// App initialisatie
function init() {
    loadTheme();
    setAppVersionLabel();
    renderSchemaSelection();
    loadSettings();
    // Normalize historical data to canonical exercise ids/names
    migrateNormalizeExercises();
    migrateHackSquatToHackSquadToday();
    migratePRsHackSquatToHackSquad();
    migrateUnifyHackSquadIds();
    renderHistory();
    // renderStatistics() called on view switch
    
    // Initialize mobile enhancements
    initSwipeGestures();
    
    // Initialize voice recognition only if enabled in settings
    const settings = getSettings();
    if (settings.voiceRecognitionEnabled) {
        initSpeechRecognition();
    }
    
    // Set voice FAB visibility based on settings
    updateVoiceFABVisibility(settings.voiceRecognitionEnabled);

    // Initialize iOS 17+ features
    console.log('🚀 Initializing iOS 17+ features...');
    setupActionButton();
    setupCameraControl();

    // Check for iOS 17+ features with improved detection
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const iOSVersion = navigator.userAgent.match(/OS (\d+)_/)?.[1];
    const isIOS17Plus = isIOS && iOSVersion && parseInt(iOSVersion) >= 17;
    const isDynamicIslandDevice = isIOS && /iPhone1[4-9]|iPhone2[0-9]/.test(navigator.userAgent); // iPhone 14 Pro+
    const isPWA = window.navigator.standalone === true ||
                 window.matchMedia('(display-mode: standalone)').matches ||
                 document.referrer.includes('android-app://') ||
                 window.location.search.includes('pwa=true') ||
                 (window.location.protocol === 'file:' && window.cordova);

    console.log('📱 Device detection:');
    console.log('  - iOS:', isIOS);
    console.log('  - iOS Version:', iOSVersion);
    console.log('  - iOS 17+:', isIOS17Plus);
    console.log('  - Dynamic Island device:', isDynamicIslandDevice);
    console.log('  - PWA mode:', isPWA);
    console.log('  - Vibration API:', 'vibrate' in navigator);
    console.log('🌐 Full User Agent:', navigator.userAgent);

    if (isIOS17Plus && isDynamicIslandDevice) {
        console.log('✅ iOS 17+ on Dynamic Island device - all features enabled');
        showToast('🏝️ Dynamic Island actief', 'success');
    } else if (isIOS17Plus) {
        console.log('✅ iOS 17+ detected - advanced features enabled');
    } else if (isIOS) {
        console.log('📱 iOS detected but not 17+ - limited features available');
    } else {
        console.log('💻 Non-iOS device detected');
    }

    // Check for PWA installation prompt
    checkPWAInstall();
    
        // Initialize stats display
        updateWorkoutStatsDisplay();
}

function renderSchemaSelection() {
    const container = document.getElementById("schemaSelection");
    container.innerHTML = getAllSchemas().map(schema => {
        const muscleGroups = schema.muscleGroups || [];
        const totalExercises = muscleGroups.reduce((sum, g) => sum + (g.exercises ? g.exercises.length : 0), 0);
        const classType = schema.id === "schema1" ? "push" : schema.id === "schema2" ? "legs" : "custom";
        const badgeText = schema.id === "schema1" ? "Upper" : schema.id === "schema2" ? "Lower" : "Custom";
        const { accent, accent2 } = getSchemaAccentPair(schema.color);
        const styleVars = `--schema-accent:${accent}; --schema-accent-2:${accent2};`;
        
        return `
            <div class="schema-card ${classType}" onclick="selectSchema('${schema.id}')" style="${styleVars}">
                <div class="schema-content">
                    <div class="schema-header">
                        <div class="schema-icon">${schema.icon || "💪"}</div>
                        <div class="schema-badge">${badgeText}</div>
                    </div>
                    <h3>${schema.name}</h3>
                    <p>${schema.description}</p>
                    <div class="schema-stats">
                        <div class="schema-stat">
                            <span class="schema-stat-value">${muscleGroups.length}</span>
                            <span class="schema-stat-label">Groepen</span>
                        </div>
                        <div class="schema-stat">
                            <span class="schema-stat-value">${totalExercises}</span>
                            <span class="schema-stat-label">Oefeningen</span>
                        </div>
                        <div class="schema-stat">
                            <span class="schema-stat-value">${totalExercises * 3}</span>
                            <span class="schema-stat-label">Sets</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }).join("");
}

function renderTemplateSelection() {
    const container = document.getElementById("templateList");
    const templates = getWorkoutTemplates();
    
    if (templates.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 3rem 1rem; color: var(--text-muted);">
                <div style="font-size: 3rem; margin-bottom: 1rem;">📋</div>
                <h3 style="margin-bottom: 0.5rem;">Geen templates gevonden</h3>
                <p>Voltooi eerst een workout en sla deze op als template om snel te kunnen starten.</p>
                <button onclick="showSchemaSelection()" style="margin-top: 1rem; padding: 0.75rem 1.5rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">
                    Bekijk Schema's
                </button>
            </div>
        `;
        return;
    }
    
    container.innerHTML = templates.map(template => {
        const totalExercises = template.exercises.length;
        const totalSets = template.exercises.reduce((sum, ex) => sum + ex.sets.length, 0);
        const totalVolume = template.exercises.reduce((sum, ex) => 
            sum + ex.sets.reduce((s, set) => s + (set.weight * set.reps), 0), 0);
        
        return `
            <div class="template-card" onclick="selectTemplate('${template.id}')">
                <div class="template-card-header">
                    <h3 class="template-card-title">${template.name}</h3>
                    <div class="template-card-actions">
                        <button class="btn-icon" onclick="event.stopPropagation(); deleteTemplate('${template.id}')" title="Verwijder template">
                            🗑️
                        </button>
                    </div>
                </div>
                ${template.description ? `<p class="template-card-description">${template.description}</p>` : ''}
                <div class="template-card-stats">
                    <div class="template-card-stat">
                        <span class="template-card-stat-value">${totalExercises}</span>
                        <span class="template-card-stat-label">Oefeningen</span>
                    </div>
                    <div class="template-card-stat">
                        <span class="template-card-stat-value">${totalSets}</span>
                        <span class="template-card-stat-label">Sets</span>
                    </div>
                    <div class="template-card-stat">
                        <span class="template-card-stat-value">${totalVolume}kg</span>
                        <span class="template-card-stat-label">Volume</span>
                    </div>
                </div>
            </div>
        `;
    }).join("");
}

function showTemplateSelection() {
    document.getElementById("schemaSelection").style.display = "grid";
    document.getElementById("templateSelection").style.display = "none";
    document.getElementById("schemaTab").classList.add("active");
    document.getElementById("templateTab").classList.remove("active");
}

function showSchemaSelection() {
    document.getElementById("schemaSelection").style.display = "grid";
    document.getElementById("templateSelection").style.display = "none";
    document.getElementById("schemaTab").classList.add("active");
    document.getElementById("templateTab").classList.remove("active");
}

function showTemplatesView() {
    document.getElementById("schemaSelection").style.display = "none";
    document.getElementById("templateSelection").style.display = "block";
    renderTemplateSelection();
}

function selectTemplate(templateId) {
    const workout = loadWorkoutFromTemplate(templateId);
    if (!workout) {
        showToast("Template niet gevonden", "error");
        return;
    }
    
    currentWorkout = workout;
    
    document.getElementById("schemaSelection").style.display = "none";
    document.getElementById("templateSelection").style.display = "none";
    document.getElementById("activeWorkout").style.display = "block";
    document.getElementById("bottomActions").classList.add("active");
    document.getElementById("fabAddExercise").classList.add("visible");
    document.getElementById("fabVoiceAdd").classList.add("visible");
    
    // Set schema colors for the workout
    const schema = WORKOUT_DATA.schemas.find(s => s.id === workout.schemaId);
    if (schema) {
        const { accent, accent2 } = getSchemaAccentPair(schema.color);
        const timerCard = document.getElementById("timerCard");
        timerCard.style.setProperty("--schema-accent", accent);
        timerCard.style.setProperty("--schema-accent-2", accent2);
        
        const activeWorkout = document.getElementById("activeWorkout");
        activeWorkout.style.setProperty("--schema-accent", accent);
        activeWorkout.style.setProperty("--schema-accent-2", accent2);
        activeWorkout.style.setProperty("--schema-accent-rgba", hexToRgba(accent, 0.4));
        activeWorkout.style.setProperty("--schema-accent-rgba-bg", hexToRgba(accent, 0.15));
        activeWorkout.style.setProperty("--schema-accent-rgba-shadow", hexToRgba(accent, 0.2));
    }
    
    renderExercises();
    startTimer();
}

function deleteTemplate(templateId) {
    if (confirm("Weet je zeker dat je deze template wilt verwijderen?")) {
        deleteWorkoutTemplate(templateId);
        renderTemplateSelection();
        showToast("Template verwijderd", "success");
    }
}

function showSaveTemplateDialog() {
    const templateName = prompt("Geef je template een naam:", `Workout ${new Date().toLocaleDateString('nl-NL')}`);
    if (!templateName || !templateName.trim()) return;
    
    const description = prompt("Beschrijving (optioneel):", "");
    
    if (currentWorkout) {
        const template = saveWorkoutAsTemplate(currentWorkout, templateName.trim(), description.trim());
        showToast(`Template "${template.name}" opgeslagen!`, "success");
    }
}

function selectSchema(schemaId) {
    const schema = WORKOUT_DATA.schemas.find(s => s.id === schemaId);
    if (!schema) return;
    
    const settings = getSettings();
    
    currentWorkout = {
        schemaId: schema.id,
        schemaName: schema.name,
        startTime: new Date().toISOString(),
        exercises: [],
        notes: ''
    };
    
    (schema.muscleGroups || []).forEach(group => {
        (group.exercises || []).forEach(exercise => {
            const sets = [];
            for (let i = 0; i < settings.defaultSets; i++) {
                sets.push({
                    reps: 12,
                    weight: getInitialWeight(exercise.id),
                    completed: false
                });
            }
            
            currentWorkout.exercises.push({
                ...exercise,
                muscleGroup: group.name,
                muscleGroupIcon: group.icon || "💪",
                sets
            });
        });
    });
    
    document.getElementById("schemaSelection").style.display = "none";
    document.getElementById("activeWorkout").style.display = "block";
    document.getElementById("bottomActions").classList.add("active");
    document.getElementById("fabAddExercise").classList.add("visible");
    document.getElementById("fabVoiceAdd").classList.add("visible");
    
    // Update timer card color based on schema
    const timerCard = document.getElementById("timerCard");
    const { accent, accent2 } = getSchemaAccentPair(schema.color);
    timerCard.style.setProperty("--schema-accent", accent);
    timerCard.style.setProperty("--schema-accent-2", accent2);
    
    // Load workout notes into textarea
    loadWorkoutNotes();
    
    // Set schema colors for the workout
    const activeWorkout = document.getElementById("activeWorkout");
    activeWorkout.style.setProperty("--schema-accent", accent);
    activeWorkout.style.setProperty("--schema-accent-2", accent2);
    activeWorkout.style.setProperty("--schema-accent-rgba", hexToRgba(accent, 0.4));
    activeWorkout.style.setProperty("--schema-accent-rgba-bg", hexToRgba(accent, 0.15));
    activeWorkout.style.setProperty("--schema-accent-rgba-shadow", hexToRgba(accent, 0.2));
    
    renderExercises();
    loadWorkoutNotes();
    startTimer();
}

function renderExercises() {
    if (!currentWorkout) return;
    updateExerciseMeta();
    updateStats();
    
    const container = document.getElementById("exercisesContainer");
    const visibleExercises = currentWorkout.exercises.filter(ex => !ex.sets.every(s => s.completed));

    // Default: only the first visible exercise expanded, others collapsed unless user toggled
    visibleExercises.forEach((ex, idx) => {
        if (collapsedExercises[ex.id] === undefined) {
            collapsedExercises[ex.id] = idx === 0 ? false : true;
        }
    });

    if (visibleExercises.length === 0) {
        container.innerHTML = `
            <div class="empty-state" style="margin-top:1rem;">
                <div class="empty-state-icon"></div>
                <h3>Alle oefeningen voltooid</h3>
                <p>Top! Voltooi de workout of voeg een set toe als je wilt doorgaan.</p>
            </div>
        `;
        return;
    }

    const groupedExercises = {};
    
    visibleExercises.forEach(ex => {
        if (!groupedExercises[ex.muscleGroup]) {
            groupedExercises[ex.muscleGroup] = {
                icon: ex.muscleGroupIcon || "💪",
                exercises: []
            };
        }
        groupedExercises[ex.muscleGroup].exercises.push(ex);
    });
    
    container.innerHTML = Object.entries(groupedExercises).map(([groupName, data]) => {
        const completed = data.exercises.filter(ex => ex.sets.some(s => s.completed)).length;
        const total = data.exercises.length;
        
        return `
            <div class="muscle-group">
                <div class="muscle-group-header">
                    <div class="muscle-group-title">
                        <span class="muscle-group-icon">${data.icon}</span>
                        <h3>${groupName}</h3>
                    </div>
                    <div class="progress-badge">${completed}/${total}</div>
                </div>
                ${data.exercises.map(ex => renderExerciseCard(ex)).join("")}
            </div>
        `;
    }).join("");
}

function updateExerciseMeta() {
    const el = document.getElementById("exerciseMeta");
    if (!el) return;
    if (!currentWorkout) {
        el.textContent = "Oefeningen: 0/0";
        return;
    }
    const total = currentWorkout.exercises.length;
    const completed = currentWorkout.exercises.filter(ex => ex.sets.every(s => s.completed)).length;
    el.textContent = `Oefeningen: ${completed}/${total}`;
}

function renderExerciseCard(exercise) {
    const previousBest = getPreviousBest(exercise.id);
    const hasPR = checkIfPR(exercise);
    const collapsed = collapsedExercises[exercise.id];
    const setsDisplay = collapsed ? 'style="display:none;"' : '';
    const collapseClass = collapsed ? 'collapse-btn collapsed' : 'collapse-btn';
    
    // Check if exercise has video URL (for custom exercises)
    const customExercises = getCustomExercises();
    const customExercise = customExercises[exercise.id];
    const videoUrl = customExercise?.videoUrl || null;
    
    return `
        <div class="exercise-card" data-exercise-id="${exercise.id}" ontouchstart="handleSwipeStart(event, ${exercise.id})" ontouchmove="handleSwipeMove(event, ${exercise.id})" ontouchend="handleSwipeEnd(event, ${exercise.id})">
            <div class="exercise-card-delete-bg">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14M10 11v6m4-6v6"/>
                </svg>
                <span style="margin-left: 0.5rem;">Verwijderen</span>
            </div>
            <div class="exercise-header">
                <div class="exercise-title">
                    <div class="exercise-name">
                        ${exercise.icon || "💪"} ${exercise.name}
                        ${hasPR ? '<span class="pr-badge-inline"> PR!</span>' : ""}
                        ${videoUrl ? '<span style="color: var(--success); margin-left: 0.5rem; cursor: pointer;" onclick="openVideoModal(\'' + exercise.name.replace(/'/g, "\\'") + '\', \'' + videoUrl + '\')" title="Bekijk instructie video">📹</span>' : ''}
                    </div>
                    <div class="exercise-meta">
                        <span class="exercise-meta-item"> MET ${exercise.met.toFixed(1)}</span>
                        ${previousBest ? `<span class="exercise-meta-item"> Best: ${previousBest.weight}kg × ${previousBest.reps}</span>` : ""}
                    </div>
                </div>
                <div class="exercise-actions">
                    <button class="exercise-btn ${collapseClass}" onclick="toggleExercise(${exercise.id})" title="Toon/Verberg sets" aria-label="Toon/Verberg sets"></button>
                    <button class="exercise-btn progress-btn" onclick="openExerciseProgress(${exercise.id})" title="Bekijk progressie" aria-label="Bekijk progressie"></button>
                </div>
            </div>
            <div class="sets-container" id="sets-${exercise.id}" ${setsDisplay}>
                ${previousBest ? `
                    <div class="previous-best">
                        <span class="previous-best-label"> Vorige Beste</span>
                        <span class="previous-best-value">${previousBest.weight}kg × ${previousBest.reps} reps</span>
                    </div>
                ` : ""}
                ${exercise.sets.map((set, idx) => `
                    <div class="set-row ${set.completed ? "completed" : ""}" data-exercise-id="${exercise.id}" data-set-index="${idx}">
                        <div class="set-input-group">
                            <div style="display:flex; align-items:center; gap:0.5rem;">
                                <button class="btn btn-secondary" style="padding:0.4rem 0.6rem" onclick="adjustSet(${exercise.id}, ${idx}, 'reps', -1)">−</button>
                                <input 
                                    type="number" 
                                    class="set-input" 
                                    placeholder="12" 
                                    value="${set.reps ?? 12}"
                                    onchange="updateSet(${exercise.id}, ${idx}, 'reps', this.value)"
                                    min="0"
                                    max="100"
                                    step="1"
                                >
                                <button class="btn btn-secondary" style="padding:0.4rem 0.6rem" onclick="adjustSet(${exercise.id}, ${idx}, 'reps', 1)">+</button>
                            </div>
                            <div class="set-input-label">Reps</div>
                        </div>
                        <div class="set-input-group">
                            <div style="display:flex; align-items:center; gap:0.5rem;">
                                <button class="btn btn-secondary" style="padding:0.4rem 0.6rem" onclick="adjustSet(${exercise.id}, ${idx}, 'weight', -1)">−</button>
                                <input 
                                    type="number" 
                                    class="set-input" 
                                    placeholder="0" 
                                    value="${set.weight ?? getLastWeight(exercise.id) ?? 0}"
                                    onchange="updateSet(${exercise.id}, ${idx}, 'weight', this.value)"
                                    min="0"
                                    max="500"
                                    step="1"
                                    inputmode="numeric"
                                >
                                <button class="btn btn-secondary" style="padding:0.4rem 0.6rem" onclick="adjustSet(${exercise.id}, ${idx}, 'weight', 1)">+</button>
                            </div>
                            <div class="set-input-label">KG</div>
                        </div>
                        <div 
                            class="checkbox ${set.completed ? "checked" : ""}"
                            onclick="toggleSet(${exercise.id}, ${idx})"
                        ></div>
                    </div>
                `).join("")}
            </div>
        </div>
    `;
}

function updateSet(exerciseId, setIndex, field, value) {
    const exercise = currentWorkout.exercises.find(ex => ex.id === exerciseId);
    if (!exercise) return;
    
    const num = parseFloat(value);
    exercise.sets[setIndex][field] = isNaN(num) ? 0 : num;
    if (field === 'weight') {
        saveLastWeight(exerciseId, exercise.sets[setIndex].weight);
    }
    updateStats();
    
    // Check for PR
    if (field === "weight" && exercise.sets[setIndex].completed) {
        checkAndShowPR(exercise, setIndex);
    }
}

function toggleSet(exerciseId, setIndex) {
    console.log("toggleSet called", exerciseId, setIndex);
    const exercise = currentWorkout.exercises.find(ex => ex.id === exerciseId);
    if (!exercise) return;
    
    const set = exercise.sets[setIndex];

    if (!set.completed && (!set.reps || !set.weight)) {
        showToast("Vul eerst reps en gewicht in", "error");
        return;
    }

    const wasCompleted = set.completed;
    set.completed = !set.completed;

    if (set.completed && !wasCompleted) {
        console.log("Starting rest timer");
        // hapticFeedback([30, 50, 30]); // Short vibration pattern for set completion - REMOVED
        currentRestExerciseId = exerciseId;
        startRestTimer();
        checkAndShowPR(exercise, setIndex);
        focusOnTimer();
    }
    
    renderExercises();
    updateStats();
}

function toggleExercise(exerciseId) {
    const el = document.getElementById(`sets-${exerciseId}`);
    if (!el) return;
    const isHidden = el.style.display === 'none';
    const nextHidden = !isHidden;
    el.style.display = nextHidden ? 'none' : 'grid';
    collapsedExercises[exerciseId] = nextHidden;
    const card = el.closest('.exercise-card');
    if (card) {
        const btn = card.querySelector('.exercise-btn.collapse-btn');
        if (btn) btn.classList.toggle('collapsed', nextHidden);
    }
}

// Swipe to delete functionality
let swipeState = {
    startX: 0,
    startY: 0,
    currentX: 0,
    isDragging: false,
    exerciseId: null,
    card: null
};

function handleSwipeStart(event, exerciseId) {
    const touch = event.touches[0];
    swipeState.startX = touch.clientX;
    swipeState.startY = touch.clientY;
    swipeState.isDragging = false;
    swipeState.exerciseId = exerciseId;
    swipeState.card = event.currentTarget;
}

function handleSwipeMove(event, exerciseId) {
    if (swipeState.exerciseId !== exerciseId) return;
    
    const touch = event.touches[0];
    const deltaX = touch.clientX - swipeState.startX;
    const deltaY = touch.clientY - swipeState.startY;
    
    // Only allow left swipe and ignore vertical scrolling
    if (Math.abs(deltaY) > Math.abs(deltaX)) return;
    if (deltaX > 0) return; // No right swipe
    
    if (Math.abs(deltaX) > 10 && !swipeState.isDragging) {
        swipeState.isDragging = true;
        swipeState.card.classList.add('swiping');
    }
    
    if (swipeState.isDragging) {
        event.preventDefault();
        swipeState.currentX = deltaX;
        const translateX = Math.max(deltaX, -120); // Max 120px to the left
        swipeState.card.style.transform = `translateX(${translateX}px)`;
    }
}

function handleSwipeEnd(event, exerciseId) {
    if (swipeState.exerciseId !== exerciseId || !swipeState.isDragging) {
        resetSwipe();
        return;
    }
    
    const threshold = -80; // Swipe threshold in pixels
    
    if (swipeState.currentX < threshold) {
        // Delete the exercise
        deleteExerciseFromWorkout(exerciseId);
    } else {
        // Reset position
        swipeState.card.style.transform = '';
        swipeState.card.classList.remove('swiping');
    }
    
    resetSwipe();
}

function resetSwipe() {
    swipeState = {
        startX: 0,
        startY: 0,
        currentX: 0,
        isDragging: false,
        exerciseId: null,
        card: null
    };
}

function deleteExerciseFromWorkout(exerciseId) {
    if (!currentWorkout) return;
    
    const exerciseIndex = currentWorkout.exercises.findIndex(ex => ex.id === exerciseId);
    if (exerciseIndex === -1) return;
    
    const exercise = currentWorkout.exercises[exerciseIndex];
    const exerciseName = exercise.name;
    
    // Add deleting animation
    const card = document.querySelector(`[data-exercise-id="${exerciseId}"]`);
    if (card) {
        card.classList.add('deleting');
        
        setTimeout(() => {
            // Remove from workout
            currentWorkout.exercises.splice(exerciseIndex, 1);
            
            // Clear collapsed state
            delete collapsedExercises[exerciseId];
            
            // Re-render
            renderExercises();
            updateStats();
            
            showToast(`${exerciseName} verwijderd`, 'success');
        }, 300);
    } else {
        // Fallback without animation
        currentWorkout.exercises.splice(exerciseIndex, 1);
        delete collapsedExercises[exerciseId];
        renderExercises();
        updateStats();
        showToast(`${exerciseName} verwijderd`, 'success');
    }
}

function openExerciseProgress(exerciseId) {
    // switch to progress view and set exercise selection
    const history = getWorkoutHistory();
    // find schema and exercise names
    let targetSchemaId = null;
    let exerciseName = null;
    history.some(w => {
        const ex = w.exercises.find(e => e.id === exerciseId);
        if (ex) {
            targetSchemaId = w.schemaId;
            exerciseName = ex.name;
            return true;
        }
        return false;
    });
    if (!targetSchemaId) {
        showToast("Geen progressiedata voor deze oefening", "error");
        return;
    }
    progressState.schemaId = targetSchemaId;
    progressState.exerciseId = exerciseId;
    switchView('progress');
    // update the dropdowns if they exist after render
    setTimeout(() => {
        const schemaSelect = document.getElementById('progressSchemaSelect');
        const exSelect = document.getElementById('progressExerciseSelect');
        if (schemaSelect) schemaSelect.value = targetSchemaId;
        if (exSelect) exSelect.value = exerciseId;
        updateProgressChart();
        addBackToWorkoutButton();
    }, 120);
}

function addBackToWorkoutButton() {
    const container = document.getElementById('progressContainer');
    if (!container) return;
    let backBtn = document.getElementById('backToWorkoutBtn');
    if (!backBtn) {
        backBtn = document.createElement('button');
        backBtn.id = 'backToWorkoutBtn';
        backBtn.className = 'btn btn-secondary';
        backBtn.style.marginTop = '1rem';
        backBtn.textContent = '← Terug naar workout';
        backBtn.onclick = () => switchView('workout');
        container.appendChild(backBtn);
    }
}

function focusOnTimer() {
    const timerCard = document.getElementById("timerCard");
    if (timerCard) {
        timerCard.scrollIntoView({ behavior: "smooth", block: "start" });
    }
}

function addSet(exerciseId) {
    const exercise = currentWorkout.exercises.find(ex => ex.id === exerciseId);
    if (!exercise) return;
    
    exercise.sets.push({
        reps: 12,
        weight: getInitialWeight(exerciseId),
        completed: false
    });
    
    renderExercises();
}

function removeSet(exerciseId) {
    const exercise = currentWorkout.exercises.find(ex => ex.id === exerciseId);
    if (!exercise || exercise.sets.length <= 1) return;
    
    exercise.sets.pop();
    renderExercises();
    updateStats();
}

function updateStats() {
    if (!currentWorkout) return;
    
    let totalSets = 0;
    let totalVolume = 0;
    
    currentWorkout.exercises.forEach(ex => {
        ex.sets.forEach(set => {
            if (set.completed) {
                totalSets++;
                totalVolume += (set.weight * set.reps);
            }
        });
    });
    
    const settings = getSettings();
    const durationMinutes = timerSeconds / 60;
    const totalKcal = calculateKcal(totalVolume, durationMinutes, settings.bodyWeight);
    
    const statSetsEl = document.getElementById("statSets");
    if (statSetsEl) statSetsEl.textContent = totalSets;
    const statVolumeEl = document.getElementById("statVolume");
    if (statVolumeEl) statVolumeEl.textContent = totalVolume.toFixed(0);
    const statKcalEl = document.getElementById("statKcal");
    if (statKcalEl) statKcalEl.textContent = totalKcal.toFixed(0);
}

function calculateKcal(volume, durationMinutes, bodyWeight) {
    const settings = getSettings();
    const met = settings.metValue || 4.5;
    return (met * bodyWeight * (durationMinutes / 60)) * 1.2;
}

// SET ADJUST HELPERS & LAST WEIGHT PERSISTENCE
function adjustSet(exerciseId, setIndex, field, delta) {
    const exercise = currentWorkout?.exercises.find(ex => ex.id === exerciseId);
    if (!exercise) return;
    const set = exercise.sets[setIndex];
    if (field === 'reps') {
        const next = Math.max(0, Math.min(100, (parseInt(set.reps || 0) + delta)));
        set.reps = next;
    } else if (field === 'weight') {
        const next = Math.max(0, Math.min(500, (parseInt(set.weight || 0) + delta)));
        set.weight = next;
        saveLastWeight(exerciseId, next);
    }
    renderExercises();
    updateStats();
}

function saveLastWeight(exerciseId, weight) {
    try {
        localStorage.setItem(`last_weight_${exerciseId}`, JSON.stringify(weight));
    } catch (e) {}
}

function getLastWeight(exerciseId) {
    try {
        const v = localStorage.getItem(`last_weight_${exerciseId}`);
        return v ? JSON.parse(v) : 0;
    } catch (e) { return 0; }
}

function getInitialWeight(exerciseId) {
    const last = getLastWeight(exerciseId);
    if (last && last > 0) return last;
    const prev = getPreviousBest(exerciseId);
    return prev ? prev.weight : 0;
}

// TIMER
function getTimerSeconds() {
    const now = Date.now();
    const runningMs = (timerRunning && timerStartMs) ? (now - timerStartMs) : 0;
    const totalMs = timerAccumulatedMs + runningMs;
    return Math.max(0, Math.floor(totalMs / 1000));
}

function syncTimerState() {
    timerSeconds = getTimerSeconds();
    updateTimerDisplay();
    updateStats();
}

function startTimer() {
    if (timerRunning) return;
    timerRunning = true;
    timerStartMs = Date.now();
    document.getElementById("timerCard").classList.add("running");
    document.getElementById("timerIcon").textContent = "";
    document.getElementById("timerText").textContent = "Pause";
    
    syncTimerState();
    timerInterval = setInterval(syncTimerState, 1000);

    // Start Dynamic Island workout tracking
    updateDynamicIsland();
}

function toggleTimer() {
    if (timerRunning) {
        pauseTimer();
    } else {
        resumeTimer();
    }
}

function pauseTimer() {
    if (!timerRunning) return;
    timerAccumulatedMs += Date.now() - (timerStartMs || Date.now());
    timerStartMs = null;
    timerRunning = false;
    clearInterval(timerInterval);
    timerInterval = null;
    document.getElementById("timerCard").classList.remove("running");
    document.getElementById("timerIcon").textContent = "";
    document.getElementById("timerText").textContent = "Hervatten";
    syncTimerState();

    // Clear Dynamic Island when paused
    const isIOS17 = navigator.userAgent.includes('iPhone') && navigator.userAgent.includes('17');
    if (isIOS17) {
        console.log('🏝️ Dynamic Island cleared (timer paused)');
    }
}

function resumeTimer() {
    startTimer();
}

function resetTimer() {
    if (!confirm("Timer resetten? Je workout blijft bewaard.")) return;
    
    pauseTimer();
    timerSeconds = 0;
    timerAccumulatedMs = 0;
    timerStartMs = null;
    syncTimerState();
}

function updateTimerDisplay() {
    const hours = Math.floor(timerSeconds / 3600);
    const minutes = Math.floor((timerSeconds % 3600) / 60);
    const seconds = timerSeconds % 60;

    const display = hours > 0
        ? `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`
        : `${pad(minutes)}:${pad(seconds)}`;

    document.getElementById("timer").textContent = display;

    // Update Dynamic Island for iPhone 14 Pro+
    updateDynamicIsland();
}

// REST TIMER
// Global helpers for workout notes and quick rest presets
function saveWorkoutNotes() {
    if (!currentWorkout) return;
    const notes = document.getElementById('workoutNotes');
    if (notes) {
        currentWorkout.notes = notes.value;
    }
}

function loadWorkoutNotes() {
    const notes = document.getElementById('workoutNotes');
    if (notes && currentWorkout) {
        notes.value = currentWorkout.notes || '';
    }
}

function quickRestTimer(seconds) {
    startRestTimer(seconds);
}

function startRestTimer(seconds = getRestDuration()) {
    console.log("startRestTimer called with", seconds, "seconds");
    stopRestTimer(true);
    restTimerRemaining = seconds;
    restTimerTotal = seconds;
    restTimerEndAt = Date.now() + (seconds * 1000);
    restTimerInterval = setInterval(syncRestTimer, 100);
    updateRestTimerUI();
    const overlay = document.getElementById("restTimerOverlay");
    console.log("Overlay element:", overlay);
    if (overlay) {
        console.log("Setting overlay to display: flex");
        overlay.style.display = "flex";
        setTimeout(() => {
            overlay.classList.add("active");
        }, 50);
    }

}

function refreshRestTimer() {
    startRestTimer(getRestDuration());
}

function stopRestTimer(auto = false) {
    if (restTimerInterval) {
        clearInterval(restTimerInterval);
        restTimerInterval = null;
    }
    restTimerEndAt = null;
    if (!auto) {
        restTimerRemaining = 0;
        const overlay = document.getElementById("restTimerOverlay");
        if (overlay) {
            overlay.classList.remove("active");
            overlay.style.display = "none"; // Direct hide without timeout
        }
    } else {
        // Timer finished automatically, return to the exercise
        hapticFeedback([200, 100, 200]); // Double vibration for timer completion
        
        if (currentRestExerciseId) {
            const exercise = currentWorkout?.exercises.find(ex => ex.id === currentRestExerciseId);
            if (exercise) {
                // Scroll to the exercise
                const exerciseCard = document.querySelector(`[data-exercise-id="${currentRestExerciseId}"]`);
                if (exerciseCard) {
                    exerciseCard.scrollIntoView({ behavior: "smooth", block: "center" });
                }
            }
        }
        restTimerRemaining = 0;
        const overlay = document.getElementById("restTimerOverlay");
        if (overlay) {
            overlay.classList.remove("active");
            overlay.style.display = "none"; // Direct hide without timeout
        }
    }
    updateRestTimerUI();
}

function syncRestTimer() {
    if (!restTimerEndAt) {
        restTimerRemaining = 0;
        updateRestTimerUI();
        return;
    }
    const remainingMs = restTimerEndAt - Date.now();
    restTimerRemaining = Math.max(0, Math.ceil(remainingMs / 1000));
    updateRestTimerUI();
    if (restTimerRemaining <= 0) {
        stopRestTimer(true);
    }
}

function updateRestTimerUI() {
    const progress = document.getElementById("restTimerProgress");
    const label = document.getElementById("restTimerLabel");
    if (!progress || !label) return;
    const remaining = Math.max(0, restTimerRemaining || 0);
    const pct = Math.max(0, Math.min(100, restTimerTotal > 0 ? (remaining / restTimerTotal) * 100 : 0));
    progress.style.width = `${pct}%`;
    const m = Math.floor(remaining / 60);
    const s = remaining % 60;
    label.textContent = `Rust: ${m}:${s.toString().padStart(2, '0')}`;
}

function pad(num) {
    return num.toString().padStart(2, "0");
}

// WORKOUT COMPLETION
function finishWorkout() {
    if (!currentWorkout) return;
    showFinishWorkoutModal();
}

function proceedFinishWorkout() {
    const completedSets = currentWorkout.exercises.reduce((sum, ex) => {
        return sum + ex.sets.filter(s => s.completed).length;
    }, 0);
    
    if (completedSets === 0) {
        if (!confirm("Je hebt geen sets voltooid. Toch afsluiten?")) return;
    }
    
    pauseTimer();
    const elapsedSeconds = getTimerSeconds();
    timerSeconds = elapsedSeconds;
    
    currentWorkout.endTime = new Date().toISOString();
    currentWorkout.duration = elapsedSeconds;
    
    // Save workout
    saveWorkout(currentWorkout);
    
    // Update PRs
    updatePRs(currentWorkout);
    
    // Update and save stats
    WorkoutStats.saveStats();
    
    showToast(`Workout voltooid! ${completedSets} sets in ${formatDuration(elapsedSeconds)}`, "success");
    
    // Reset
    resetWorkout();
}

function cancelWorkout() {
    if (!confirm("Workout annuleren? Je voortgang gaat verloren.")) return;
    
    pauseTimer();
    resetWorkout();
}

function resetWorkout() {
    currentWorkout = null;
    timerSeconds = 0;
    timerAccumulatedMs = 0;
    timerStartMs = null;
    timerRunning = false;
    clearInterval(timerInterval);
    timerInterval = null;
    
    document.getElementById("schemaSelection").style.display = "grid";
    document.getElementById("activeWorkout").style.display = "none";
    document.getElementById("bottomActions").classList.remove("active");
    document.getElementById("timerCard").classList.remove("running");
    document.getElementById("fabAddExercise").classList.remove("visible");
    document.getElementById("fabVoiceAdd").classList.remove("visible");
    hideInlineExerciseForm();
    closeAddExerciseModal();
    
    updateTimerDisplay();
    updateStats();
    updateExerciseMeta();
    renderHistory();
    renderPRs();
        updateWorkoutStatsDisplay();
}

// WORKOUT STORAGE
function saveWorkout(workout) {
    const history = getWorkoutHistory();
    history.unshift(workout);
    
    // Keep last 100 workouts
    if (history.length > 100) {
        history.splice(100);
    }
    
    localStorage.setItem("workout_history", JSON.stringify(history));
    
    // Trigger cloud sync if enabled
    if (FirestoreSync.enabled) {
        FirestoreSync.syncAfterChange();
    }
}

function getWorkoutHistory() {
    const stored = localStorage.getItem("workout_history");
    return stored ? JSON.parse(stored) : [];
}

// WORKOUT TEMPLATES
function getWorkoutTemplates() {
    const stored = localStorage.getItem("workout_templates");
    return stored ? JSON.parse(stored) : [];
}

function saveWorkoutTemplates(templates) {
    localStorage.setItem("workout_templates", JSON.stringify(templates));
}

function saveWorkoutAsTemplate(workout, templateName, description = "") {
    const templates = getWorkoutTemplates();
    
    // Create template from current workout (without completed status and start time)
    const template = {
        id: `template_${Date.now()}`,
        name: templateName,
        description: description,
        createdAt: new Date().toISOString(),
        schemaId: workout.schemaId,
        schemaName: workout.schemaName,
        exercises: workout.exercises.map(ex => ({
            id: ex.id,
            name: ex.name,
            met: ex.met,
            muscleGroup: ex.muscleGroup,
            muscleGroupIcon: ex.muscleGroupIcon,
            sets: ex.sets.map(set => ({
                reps: set.reps,
                weight: set.weight,
                completed: false // Always start fresh
            }))
        }))
    };
    
    templates.push(template);
    saveWorkoutTemplates(templates);
    return template;
}

function loadWorkoutFromTemplate(templateId) {
    const templates = getWorkoutTemplates();
    const template = templates.find(t => t.id === templateId);
    if (!template) return null;
    
    // Convert template back to workout format
    return {
        schemaId: template.schemaId,
        schemaName: template.schemaName,
        startTime: new Date().toISOString(),
        exercises: template.exercises.map(ex => ({
            ...ex,
            sets: ex.sets.map(set => ({ ...set })) // Deep copy
        }))
    };
}

function deleteWorkoutTemplate(templateId) {
    const templates = getWorkoutTemplates();
    const filtered = templates.filter(t => t.id !== templateId);
    saveWorkoutTemplates(filtered);
}

// DATA MIGRATION: Move today's "Hack Squat" entries to "Hack Squad"
function migrateHackSquatToHackSquadToday() {
    try {
        const history = getWorkoutHistory();
        if (!Array.isArray(history) || history.length === 0) return;
        const todayStr = new Date().toDateString();
        let changed = false;
        history.forEach(w => {
            const d = new Date(w.startTime).toDateString();
            if (d !== todayStr || !Array.isArray(w.exercises)) return;
            w.exercises.forEach(ex => {
                if (ex && typeof ex.name === 'string' && ex.name.trim().toLowerCase() === 'hack squat') {
                    ex.name = 'Hack Squad';
                    // keep id if present, otherwise set to 111
                    if (!ex.id) ex.id = 111;
                    changed = true;
                }
            });
        });
        if (changed) {
            localStorage.setItem('workout_history', JSON.stringify(history));
        }
    } catch (e) { /* ignore */ }
}

function deleteWorkoutByTime(startTime, schemaName) {
    if (!confirm('Weet je zeker dat je deze workout wilt verwijderen?')) {
        return;
    }
    
    const history = getWorkoutHistory();
    const index = history.findIndex(w => w.startTime === startTime && w.schemaName === schemaName);
    
    if (index === -1) return;
    
    history.splice(index, 1);
    localStorage.setItem("workout_history", JSON.stringify(history));
    
    showToast("Workout verwijderd", "success");
    renderHistory(); // Re-render the history view
    renderPRs(); // Re-render PRs as they might be affected
    
    // Trigger cloud sync if enabled
    if (typeof FirestoreSync !== 'undefined' && FirestoreSync.enabled) {
        FirestoreSync.syncAfterChange();
    }
}

// Delete workout by global index in history (used by calendar day list)
function deleteWorkout(globalIndex) {
    if (!confirm('Weet je zeker dat je deze workout wilt verwijderen?')) {
        return;
    }
    const history = getWorkoutHistory();
    if (globalIndex < 0 || globalIndex >= history.length) return;
    history.splice(globalIndex, 1);
    localStorage.setItem('workout_history', JSON.stringify(history));
    showToast('Workout verwijderd', 'success');
    // Re-render both calendar and list views
    renderHistory();
    renderPRs();
    // Trigger cloud sync if enabled
    if (typeof FirestoreSync !== 'undefined' && FirestoreSync.enabled) {
        FirestoreSync.syncAfterChange();
    }
}

// Expose for inline onclick usage
window.deleteWorkout = deleteWorkout;

// PR TRACKING
function getPRs() {
    const stored = localStorage.getItem("workout_prs");
    return stored ? JSON.parse(stored) : {};
}

// DATA MIGRATION: General normalization of exercises in history and PRs
function migrateNormalizeExercises() {
    try {
        // Build canonical maps from WORKOUT_DATA
        const canonicalById = {};
        const canonicalByName = {};
        WORKOUT_DATA.schemas.forEach(s => {
            s.muscleGroups.forEach(g => {
                g.exercises.forEach(ex => {
                    canonicalById[ex.id] = ex.name;
                    const key = ex.name.trim().toLowerCase();
                    canonicalByName[key] = { id: ex.id, name: ex.name };
                });
            });
        });
        // Known synonyms (left lowercased) → canonical id
        const synonyms = {
            "hack squat": 111,
            "hack squad": 111
        };
        Object.keys(synonyms).forEach(n => {
            const id = synonyms[n];
            if (canonicalById[id]) {
                canonicalByName[n] = { id, name: canonicalById[id] };
            }
        });

        // Normalize workout history
        let history = getWorkoutHistory();
        let histChanged = false;
        history.forEach(w => {
            if (!Array.isArray(w.exercises)) return;
            w.exercises.forEach(ex => {
                if (!ex) return;
                // Prefer id mapping if valid
                if (ex.id && canonicalById[ex.id]) {
                    ex.name = canonicalById[ex.id];
                    return;
                }
                // Else try name mapping
                const key = (ex.name || '').toString().trim().toLowerCase();
                const canon = canonicalByName[key];
                if (canon) {
                    if (ex.id !== canon.id || ex.name !== canon.name) {
                        ex.id = canon.id;
                        ex.name = canon.name;
                        histChanged = true;
                    }
                }
            });
        });
        if (histChanged) {
            localStorage.setItem('workout_history', JSON.stringify(history));
        }

        // Normalize and merge PRs by canonical id
        const prs = getPRs();
        if (prs && typeof prs === 'object') {
            const merged = {};
            Object.keys(prs).forEach(key => {
                const pr = prs[key];
                if (!pr) return;
                let targetId = pr.exerciseId;
                let targetName = pr.exerciseName;
                if (targetId && canonicalById[targetId]) {
                    targetName = canonicalById[targetId];
                } else {
                    const nk = (pr.exerciseName || '').toString().trim().toLowerCase();
                    const canon = canonicalByName[nk];
                    if (canon) {
                        targetId = canon.id;
                        targetName = canon.name;
                    }
                }
                if (!targetId) return; // skip unknowns
                const newKey = String(targetId);
                const next = { ...pr, exerciseId: targetId, exerciseName: targetName };
                const cur = merged[newKey];
                if (!cur || (next.oneRM || 0) > (cur.oneRM || 0)) {
                    merged[newKey] = next;
                }
            });
            localStorage.setItem('workout_prs', JSON.stringify(merged));
        }
    } catch (e) { /* ignore */ }
}

// DATA MIGRATION: Rename PR entries from "Hack Squat" to "Hack Squad"
function migratePRsHackSquatToHackSquad() {
    try {
        const prs = getPRs();
        if (!prs || typeof prs !== 'object') return;
        let changed = false;
        Object.keys(prs).forEach(key => {
            const pr = prs[key];
            if (!pr || typeof pr.exerciseName !== 'string') return;
            if (pr.exerciseName.trim().toLowerCase() === 'hack squat') {
                pr.exerciseName = 'Hack Squad';
                if (!pr.exerciseId) pr.exerciseId = 111;
                changed = true;
            }
        });
        if (changed) {
            localStorage.setItem('workout_prs', JSON.stringify(prs));
        }
    } catch (e) { /* ignore */ }
}

// DATA MIGRATION: Unify all history exercises named Hack Squat/Squad to id=111, name="Hack Squad"
function migrateUnifyHackSquadIds() {
    try {
        const history = getWorkoutHistory();
        if (!Array.isArray(history) || history.length === 0) return;
        let changed = false;
        history.forEach(w => {
            if (!Array.isArray(w.exercises)) return;
            w.exercises.forEach(ex => {
                if (!ex || typeof ex.name !== 'string') return;
                const nm = ex.name.trim().toLowerCase();
                if (nm === 'hack squat' || nm === 'hack squad') {
                    if (ex.id !== 111 || ex.name !== 'Hack Squad') {
                        ex.id = 111;
                        ex.name = 'Hack Squad';
                        changed = true;
                    }
                }
            });
        });
        if (changed) {
            localStorage.setItem('workout_history', JSON.stringify(history));
        }

        // Also merge PRs under key 111 to ensure previous best is consistent
        const prs = getPRs();
        if (prs && typeof prs === 'object') {
            let newPrs = {};
            let merged = false;
            Object.keys(prs).forEach(key => {
                const pr = prs[key];
                if (!pr) return;
                const nm = (pr.exerciseName || '').toString().trim().toLowerCase();
                if (nm === 'hack squat' || nm === 'hack squad' || pr.exerciseId === 111) {
                    const unified = {
                        ...pr,
                        exerciseId: 111,
                        exerciseName: 'Hack Squad'
                    };
                    const existing = newPrs['111'];
                    if (!existing || (unified.oneRM || 0) > (existing.oneRM || 0)) {
                        newPrs['111'] = unified;
                    }
                    merged = true;
                } else {
                    newPrs[key] = pr;
                }
            });
            if (merged) {
                localStorage.setItem('workout_prs', JSON.stringify(newPrs));
            }
        }
    } catch (e) { /* ignore */ }
}

function updatePRs(workout) {
    const prs = getPRs();
    let newPRs = [];
    
    workout.exercises.forEach(exercise => {
        exercise.sets.forEach(set => {
            if (!set.completed) return;
            
            const key = exercise.id.toString();
            const currentPR = prs[key];
            
            const oneRM = calculateOneRM(set.weight, set.reps);
            
            if (!currentPR || oneRM > currentPR.oneRM) {
                prs[key] = {
                    exerciseId: exercise.id,
                    exerciseName: exercise.name,
                    weight: set.weight,
                    reps: set.reps,
                    oneRM: oneRM,
                    date: new Date().toISOString()
                };
                newPRs.push(prs[key]);
            }
        });
    });
    
    localStorage.setItem("workout_prs", JSON.stringify(prs));
    
    // Trigger cloud sync if enabled
    if (FirestoreSync.enabled) {
        FirestoreSync.syncAfterChange();
    }
    
    return newPRs;
}

function calculateOneRM(weight, reps) {
    if (reps === 1) return Math.round(weight * 10) / 10;
    return Math.round((weight * (1 + reps / 30)) * 10) / 10;
}

function getPreviousBest(exerciseId) {
    const prs = getPRs();
    return prs[exerciseId.toString()];
}

function checkIfPR(exercise) {
    const previousBest = getPreviousBest(exercise.id);
    if (!previousBest) return false;
    
    return exercise.sets.some(set => {
        if (!set.completed) return false;
        const oneRM = calculateOneRM(set.weight, set.reps);
        return oneRM > previousBest.oneRM;
    });
}

function checkAndShowPR(exercise, setIndex) {
    const set = exercise.sets[setIndex];
    if (!set.completed) return;
    
    const previousBest = getPreviousBest(exercise.id);
    const oneRM = calculateOneRM(set.weight, set.reps);
    
    if (!previousBest || oneRM > previousBest.oneRM) {
        setTimeout(() => {
            showPRCelebration(exercise.name, set.weight, set.reps, previousBest);
        }, 300);
    }
}

function showPRCelebration(exerciseName, weight, reps, previousBest) {
    document.getElementById("prDetail").textContent = `${exerciseName}: ${weight}kg × ${reps} reps`;
    
    if (previousBest) {
        const improvement = ((calculateOneRM(weight, reps) / previousBest.oneRM - 1) * 100).toFixed(1);
        document.getElementById("prSub").textContent = `+${improvement}% sterker dan je vorige PR!`;
    } else {
        document.getElementById("prSub").textContent = "Je eerste PR voor deze oefening!";
    }
    
    document.getElementById("prCelebration").classList.add("active");
}

function closePRCelebration() {
    document.getElementById("prCelebration").classList.remove("active");
}

// HISTORY RENDERING
function renderHistory() {
    renderCalendar();
    renderHistoryList();
}

function renderCalendar() {
    const container = document.getElementById('calendarContainer');
    if (!container) return;
    
    const today = new Date();
    const year = currentCalendarYear || today.getFullYear();
    const month = currentCalendarMonth !== undefined ? currentCalendarMonth : today.getMonth();
    
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    
    // Start from Monday before first day
    const startDate = new Date(firstDay);
    const dayOfWeek = firstDay.getDay();
    const daysToSubtract = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    startDate.setDate(startDate.getDate() - daysToSubtract);
    
    const history = getWorkoutHistory();
    const workoutsByDate = {};
    
    history.forEach(w => {
        const date = new Date(w.startTime).toDateString();
        if (!workoutsByDate[date]) workoutsByDate[date] = [];
        workoutsByDate[date].push(w);
    });
    
    let html = `
        <div class="calendar-header">
            <button class="calendar-nav-btn" onclick="previousMonth()">◀</button>
            <div class="calendar-month-year">${firstDay.toLocaleDateString('nl-NL', { month: 'long', year: 'numeric' })}</div>
            <button class="calendar-nav-btn" onclick="nextMonth()">▶</button>
        </div>
        <div class="calendar-grid">
            <div class="calendar-weekday">Ma</div>
            <div class="calendar-weekday">Di</div>
            <div class="calendar-weekday">Wo</div>
            <div class="calendar-weekday">Do</div>
            <div class="calendar-weekday">Vr</div>
            <div class="calendar-weekday">Za</div>
            <div class="calendar-weekday">Zo</div>
    `;
    
    const currentDate = new Date(startDate);
    const today_str = today.toDateString();
    
    // Render 6 weeks (42 days)
    for (let i = 0; i < 42; i++) {
        const dateStr = currentDate.toDateString();
        const hasWorkout = workoutsByDate[dateStr] ? true : false;
        const isToday = dateStr === today_str;
        const isOtherMonth = currentDate.getMonth() !== month;
        let dayStyle = "";
        if (hasWorkout && !isOtherMonth) {
            const schemaId = workoutsByDate[dateStr][0].schemaId;
            const accent = getSchemaColor(schemaId);
            const border = shadeColor(accent, -14);
            const shadow = hexToRgba(accent, 0.35);
            dayStyle = `style="background:${accent}; color:#000; border:1px solid ${border}; box-shadow:0 0 12px ${shadow};"`;
        }
        
        const classes = [
            'calendar-day',
            hasWorkout && !isOtherMonth ? 'has-workout' : '',
            isToday ? 'today' : '',
            isOtherMonth ? 'other-month' : ''
        ].filter(c => c).join(' ');
        
        html += `<div class="${classes}" ${dayStyle} onclick="selectCalendarDay('${dateStr}')">${currentDate.getDate()}</div>`;
        
        currentDate.setDate(currentDate.getDate() + 1);
    }
    
    html += '</div>';
    
    container.innerHTML = html;
}

let currentCalendarMonth = new Date().getMonth();
let currentCalendarYear = new Date().getFullYear();

function previousMonth() {
    currentCalendarMonth--;
    if (currentCalendarMonth < 0) {
        currentCalendarMonth = 11;
        currentCalendarYear--;
    }
    renderCalendar();
}

function nextMonth() {
    currentCalendarMonth++;
    if (currentCalendarMonth > 11) {
        currentCalendarMonth = 0;
        currentCalendarYear++;
    }
    renderCalendar();
}

function selectCalendarDay(dateStr) {
    const history = getWorkoutHistory();
    const dayWorkouts = history.filter(w => {
        const workoutDate = new Date(w.startTime);
        return workoutDate.toDateString() === dateStr;
    });
    
    if (dayWorkouts.length === 0) return;
    
    const historyContainer = document.getElementById('historyContainer');
    
    let html = `
        <div class="calendar-workouts" id="calendarWorkouts">
            <div class="calendar-workouts-title">${new Date(dateStr).toLocaleDateString('nl-NL', { weekday: 'long', day: 'numeric', month: 'long' })}</div>
    `;
    
    dayWorkouts.forEach((workout, idx) => {
        const completedSets = workout.exercises.reduce((sum, ex) => sum + ex.sets.filter(s => s.completed).length, 0);
        const totalVolume = workout.exercises.reduce((sum, ex) => sum + ex.sets.reduce((s, set) => set.completed ? s + (set.weight * set.reps) : s, 0), 0);
        
        // Find the global index of this workout in full history
        const allHistory = getWorkoutHistory();
        const globalIdx = allHistory.findIndex(w => w.startTime === workout.startTime && w.schemaName === workout.schemaName);
        
        html += `
            <div class="calendar-workout-item">
                <div style="display:flex; justify-content:space-between; margin-bottom:0.5rem; align-items:center;">
                    <strong>${workout.schemaName}</strong>
                    <div style="display:flex; gap:0.5rem; align-items:center;">
                        <span style="font-size:0.85rem; color:var(--text-muted);">${formatDuration(workout.duration)}</span>
                        <button class="btn-icon delete-btn" onclick="deleteWorkout(${globalIdx})" title="Verwijderen">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14M10 11v6m4-6v6"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div style="font-size:0.85rem; color:var(--text-muted); margin-bottom:0.75rem;">
                    ${completedSets} sets • ${totalVolume.toFixed(0)} kg
                </div>
                <button class="btn btn-secondary" style="width:100%; padding:0.5rem; font-size:0.9rem;" onclick="expandWorkoutDetails(${idx}, '${dateStr}')">
                    Oefeningen tonen
                </button>
            </div>
            <div id="workout-details-${idx}" style="display:none; margin-top:0.5rem; padding:0.75rem; background:var(--dark-elevated); border-radius:12px;"></div>
        `;
    });
    
    html += '</div>';
    historyContainer.innerHTML = html;
    // Smooth scroll the workouts block into view
    setTimeout(() => {
        const listEl = document.getElementById('calendarWorkouts');
        if (listEl) {
            listEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }, 0);
    window.selectedDayWorkouts = dayWorkouts;
}

function expandWorkoutDetails(workoutIdx, dateStr) {
    const dayWorkouts = window.selectedDayWorkouts || [];
    const workout = dayWorkouts[workoutIdx];
    if (!workout) return;
    
    const detailsDiv = document.getElementById(`workout-details-${workoutIdx}`);
    if (detailsDiv.style.display === 'block') {
        detailsDiv.style.display = 'none';
        return;
    }
    
    let html = '';
    const groupedByMuscle = {};
    
    workout.exercises.forEach(ex => {
        const mg = ex.muscleGroup || 'Overig';
        if (!groupedByMuscle[mg]) groupedByMuscle[mg] = [];
        groupedByMuscle[mg].push(ex);
    });
    
    Object.entries(groupedByMuscle).forEach(([muscle, exercises]) => {
        html += `<div style="margin-bottom:0.75rem;">
            <strong style="color:var(--primary); display:block; margin-bottom:0.5rem;">${muscle}</strong>`;
        
        exercises.forEach(ex => {
            const completedSets = ex.sets.filter(s => s.completed).length;
            const totalSets = ex.sets.length;
            html += `<div style="font-size:0.85rem; margin-bottom:0.25rem; padding:0.35rem 0;">
                ${ex.name} • ${completedSets}/${totalSets} sets
            </div>`;
            
            ex.sets.forEach((set, sidx) => {
                html += `<div style="font-size:0.8rem; color:var(--text-muted); margin-left:1rem; ${set.completed ? 'opacity:0.7;' : ''}">
                    Set ${sidx + 1}: ${set.reps} × ${set.weight}kg ${set.completed ? '✓' : ''}
                </div>`;
            });
        });
        
        html += '</div>';
    });
    
    detailsDiv.innerHTML = html;
    detailsDiv.style.display = 'block';
}

function renderHistoryList() {
    const history = getWorkoutHistory();
    const container = document.getElementById('historyContainer');
    
    if (history.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"></div>
                <h3>Geen Workouts</h3>
                <p>Start je eerste workout om geschiedenis te zien!</p>
            </div>
        `;
        return;
    }
    
    // Sort history by date (newest first)
    const sortedHistory = [...history].sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
    
    container.innerHTML = `
        <div class="history-list">
            ${sortedHistory.map((workout, index) => {
                const completedSets = workout.exercises.reduce((sum, ex) => sum + ex.sets.filter(s => s.completed).length, 0);
                const totalSets = workout.exercises.reduce((sum, ex) => sum + ex.sets.length, 0);
                const totalVolume = workout.exercises.reduce((sum, ex) => sum + ex.sets.reduce((s, set) => set.completed ? s + (set.weight * set.reps) : s, 0), 0);
                const workoutDate = new Date(workout.startTime);
                const schemaColor = getSchemaColor(workout.schemaId);
                
                return `
                    <div class="history-item" onclick="showWorkoutDetails('${workout.startTime}', '${workout.schemaName}')">
                        <div class="history-item-header">
                            <div class="history-item-title">
                                <div class="schema-indicator" style="background: ${schemaColor};"></div>
                                <strong>${workout.schemaName}</strong>
                            </div>
                            <div class="history-item-actions">
                                <button class="btn-icon delete-btn" onclick="event.stopPropagation(); deleteWorkoutByTime('${workout.startTime}', '${workout.schemaName}')" title="Verwijderen">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14M10 11v6m4-6v6"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="history-item-meta">
                            <span class="history-date">${workoutDate.toLocaleDateString('nl-NL', { weekday: 'short', day: 'numeric', month: 'short' })}</span>
                            <span class="history-duration">${formatDuration(workout.duration)}</span>
                        </div>
                        <div class="history-item-stats">
                            <div class="history-stat">
                                <span class="history-stat-value">${completedSets}/${totalSets}</span>
                                <span class="history-stat-label">sets</span>
                            </div>
                            <div class="history-stat">
                                <span class="history-stat-value">${totalVolume.toFixed(0)}kg</span>
                                <span class="history-stat-label">volume</span>
                            </div>
                            <div class="history-stat">
                                <span class="history-stat-value">${workout.exercises.length}</span>
                                <span class="history-stat-label">oefeningen</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join("")}
        </div>
    `;
}

function showWorkoutDetails(startTime, schemaName) {
    const history = getWorkoutHistory();
    const workout = history.find(w => w.startTime === startTime && w.schemaName === schemaName);
    
    if (!workout) return;
    
    const workoutDate = new Date(workout.startTime);
    const schemaColor = getSchemaColor(workout.schemaId);
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.onclick = () => modal.remove();
    
    modal.innerHTML = `
        <div class="modal-content workout-details-modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">
                    <div class="schema-indicator" style="background: ${schemaColor};"></div>
                    <h2>${workout.schemaName}</h2>
                </div>
                <button class="modal-close" onclick="this.closest('.modal').remove()">×</button>
            </div>
            <div class="modal-body">
                <div class="workout-summary">
                    <div class="workout-meta">
                        <div class="meta-item">
                            <span class="meta-label">Datum:</span>
                            <span class="meta-value">${workoutDate.toLocaleDateString('nl-NL', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Duur:</span>
                            <span class="meta-value">${formatDuration(workout.duration)}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Tijd:</span>
                            <span class="meta-value">${workoutDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' })}</span>
                        </div>
                    </div>
                </div>
                
                <div class="workout-exercises">
                    ${workout.exercises.map(ex => {
                        const completedSets = ex.sets.filter(s => s.completed).length;
                        const totalSets = ex.sets.length;
                        const exerciseVolume = ex.sets.reduce((sum, set) => set.completed ? sum + (set.weight * set.reps) : sum, 0);
                        
                        return `
                            <div class="exercise-details">
                                <div class="exercise-header">
                                    <h3>${ex.name}</h3>
                                    <div class="exercise-stats">
                                        <span>${completedSets}/${totalSets} sets</span>
                                        <span>${exerciseVolume.toFixed(0)}kg</span>
                                    </div>
                                </div>
                                <div class="exercise-sets">
                                    ${ex.sets.map((set, sidx) => `
                                        <div class="set-item ${set.completed ? 'completed' : 'incomplete'}">
                                            <span class="set-number">Set ${sidx + 1}</span>
                                            <span class="set-details">${set.reps} × ${set.weight}kg</span>
                                            ${set.completed ? '<span class="set-check">✓</span>' : '<span class="set-check">○</span>'}
                                        </div>
                                    `).join("")}
                                </div>
                            </div>
                        `;
                    }).join("")}
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    modal.classList.add('active');
}

// PRS RENDERING
function renderStatistics() {
    const period = document.getElementById('periodSelector').value;
    const history = getWorkoutHistory();
    const filteredHistory = filterHistoryByPeriod(history, period);
    
    const stats = calculateStatistics(filteredHistory);
    
    const container = document.getElementById("statisticsContainer");
    
    if (filteredHistory.length === 0) {
        container.innerHTML = '<div class="empty-state"><div class="empty-state-icon"></div><h3>Geen workouts</h3><p>Voltooi workouts om statistieken te zien!</p></div>';
        return;
    }
    
    container.innerHTML =
        '<div class="stats-grid" role="grid" aria-label="Workout statistieken">' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">⏱️</div>' +
                '<div class="stat-value" aria-label="Totale workout tijd">' + stats.totalTime.hours + 'h ' + stats.totalTime.minutes + 'm</div>' +
                '<div class="stat-label">Totale workout tijd</div>' +
                '<div class="stat-sub">Gemiddeld ' + stats.avgTime + ' min/workout</div>' +
            '</div>' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">🔥</div>' +
                '<div class="stat-value" aria-label="Geschatte calorieën">' + stats.totalCalories + '</div>' +
                '<div class="stat-label">Geschatte kcal</div>' +
                '<div class="stat-sub">Gemiddeld ' + stats.avgCalories + ' kcal/workout</div>' +
            '</div>' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">🏋️</div>' +
                '<div class="stat-value" aria-label="Aantal workouts">' + stats.totalWorkouts + '</div>' +
                '<div class="stat-label">Workouts voltooid</div>' +
                '<div class="stat-sub">' + stats.frequency + ' per week</div>' +
            '</div>' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">💪</div>' +
                '<div class="stat-value" aria-label="Totaal volume">' + stats.totalVolume + 'kg</div>' +
                '<div class="stat-label">Totaal volume</div>' +
                '<div class="stat-sub">Gewicht × reps</div>' +
            '</div>' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">🔄</div>' +
                '<div class="stat-value" aria-label="Langste streak">' + stats.longestStreak + '</div>' +
                '<div class="stat-label">Langste streak</div>' +
                '<div class="stat-sub">Huidig: ' + stats.currentStreak + ', Gem: ' + stats.avgStreak + ' dagen</div>' +
            '</div>' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">📈</div>' +
                '<div class="stat-value" aria-label="Progressie">' + stats.progress + '%</div>' +
                '<div class="stat-label">Progressie</div>' +
                '<div class="stat-sub">Vs vorige periode</div>' +
            '</div>' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">🎯</div>' +
                '<div class="stat-value" aria-label="Totaal sets">' + stats.totalSets + '</div>' +
                '<div class="stat-label">Totaal sets</div>' +
                '<div class="stat-sub">Voltooid in periode</div>' +
            '</div>' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">🔢</div>' +
                '<div class="stat-value" aria-label="Gemiddelde reps">' + stats.avgReps + '</div>' +
                '<div class="stat-label">Gemiddelde reps</div>' +
                '<div class="stat-sub">Per set</div>' +
            '</div>' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">🏆</div>' +
                '<div class="stat-value" aria-label="Meest getrainde oefening">' + stats.topExercise + '</div>' +
                '<div class="stat-label">Meest getraind</div>' +
                '<div class="stat-sub">Oefening (sets)</div>' +
            '</div>' +
            '<div class="stat-card" role="gridcell" tabindex="0">' +
                '<div class="stat-icon" aria-hidden="true">⚖️</div>' +
                '<div class="stat-value" aria-label="Gewicht balans">' + stats.weightDistribution.light + '% / ' + stats.weightDistribution.medium + '% / ' + stats.weightDistribution.heavy + '%</div>' +
                '<div class="stat-label">Gewicht balans</div>' +
                '<div class="stat-sub">Licht / Medium / Zwaar</div>' +
            '</div>' +
        '</div>' +
        '<div class="charts-section">' +
            '<div class="chart-container">' +
                '<h3>Volume Progressie</h3>' +
                '<select id="exerciseSelector" onchange="renderVolumeChart(filterHistoryByPeriod(getWorkoutHistory(), document.getElementById(\'periodSelector\').value))">' +
                    '<option value="total">Totaal Volume</option>' +
                '</select>' +
                '<canvas id="volumeChart" width="350" height="200"></canvas>' +
                '<div class="chart-legend">Totaal gewicht × reps per workout over tijd</div>' +
            '</div>' +
            '<div class="chart-container">' +
                '<h3>Workout Frequentie</h3>' +
                '<canvas id="frequencyChart" width="350" height="200"></canvas>' +
                '<div class="chart-legend">Aantal workouts per periode (bij week: per kalenderweek, bij maand: per maand)</div>' +
            '</div>' +
            '<div class="chart-container">' +
                '<h3>Workout Duur Distributie</h3>' +
                '<canvas id="durationChart" width="350" height="200"></canvas>' +
                '<div class="chart-legend">Verdeling van workout lengtes</div>' +
            '</div>' +
            '<div class="chart-container">' +
                '<h3>Spiergroepen</h3>' +
                '<canvas id="muscleChart" width="200" height="200"></canvas>' +
                '<div class="chart-legend-list"><!-- legend here --></div>' +
            '</div>' +
        '</div>';
    
    // Fill exercise selector
    const exerciseSelector = document.getElementById('exerciseSelector');
    exerciseSelector.innerHTML = '<option value="total">Totaal Volume</option>';
    const exerciseCount = {};
    filteredHistory.forEach(w => {
        if (w.exercises) {
            w.exercises.forEach(ex => {
                const name = ex.name || 'Unknown';
                exerciseCount[name] = (exerciseCount[name] || 0) + 1;
            });
        }
    });
    Object.entries(exerciseCount).sort((a, b) => b[1] - a[1]).slice(0, 3).forEach(([name]) => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        exerciseSelector.appendChild(option);
    });
    renderVolumeChart(filteredHistory);
    renderFrequencyChart(filteredHistory, period);
    renderDurationChart(stats.durationBins);
    renderMuscleChart(filteredHistory, stats.kcalPerMuscle);
}

function setPeriod(period) {
    document.getElementById('periodSelector').value = period;
    document.querySelectorAll('.period-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.period === period);
    });
    renderStatistics();
}

function filterHistoryByPeriod(history, period) {
    const now = new Date();
    let startDate;
    switch (period) {
        case 'week':
            startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            break;
        case 'month':
            startDate = new Date(now.getFullYear(), now.getMonth(), 1);
            break;
        case 'year':
            startDate = new Date(now.getFullYear(), 0, 1);
            break;
        default:
            return history; // 'all'
    }
    return history.filter(w => new Date(w.startTime) >= startDate);
}

function calculateStatistics(history) {
    if (history.length === 0) return {
        totalTime: { hours: 0, minutes: 0 },
        totalCalories: 0,
        totalWorkouts: 0,
        totalVolume: 0,
        longestStreak: 0,
        progress: 0,
        avgTime: 0,
        avgCalories: 0,
        frequency: 0,
        totalSets: 0,
        avgReps: 0,
        topExercise: 'Geen',
        weightDistribution: { light: 0, medium: 0, heavy: 0 },
        durationBins: { '0-30': 0, '30-60': 0, '60-90': 0, '90+': 0 },
        currentStreak: 0,
        avgStreak: 0,
        kcalPerMuscle: {}
    };
    
    let totalTime = 0;
    let totalCalories = 0;
    let totalVolume = 0;
    let totalSets = 0;
    let totalReps = 0;
    let exerciseCount = {};
    let weightDist = { light: 0, medium: 0, heavy: 0 };
    let durationBins = { '0-30': 0, '30-60': 0, '60-90': 0, '90+': 0 };
    let kcalPerMuscle = {};
    let dates = history.map(w => new Date(w.startTime).toDateString()).sort();
    let uniqueDates = [...new Set(dates)];
    let longestStreak = 0;
    let currentStreak = 0;
    let streakSum = 0;
    let streakCount = 0;
    
    // Calculate streaks
    for (let i = 0; i < uniqueDates.length; i++) {
        if (i === 0 || new Date(uniqueDates[i]).getTime() - new Date(uniqueDates[i-1]).getTime() === 24 * 60 * 60 * 1000) {
            currentStreak++;
        } else {
            if (currentStreak > 0) {
                longestStreak = Math.max(longestStreak, currentStreak);
                streakSum += currentStreak;
                streakCount++;
            }
            currentStreak = 1;
        }
    }
    if (currentStreak > 0) {
        longestStreak = Math.max(longestStreak, currentStreak);
        streakSum += currentStreak;
        streakCount++;
    }
    let avgStreak = streakCount > 0 ? Math.round(streakSum / streakCount) : 0;
    
    history.forEach(w => {
        totalTime += w.duration || 0;
        totalCalories += estimateCalories(w);
        const durationMin = Math.floor((w.duration || 0) / 60);
        if (durationMin < 30) durationBins['0-30']++;
        else if (durationMin < 60) durationBins['30-60']++;
        else if (durationMin < 90) durationBins['60-90']++;
        else durationBins['90+']++;
        
        if (w.exercises) {
            w.exercises.forEach(ex => {
                const muscle = ex.muscleGroup || 'Other';
                kcalPerMuscle[muscle] = (kcalPerMuscle[muscle] || 0) + estimateCalories({ exercises: [ex], duration: w.duration });
                if (ex.sets) {
                    ex.sets.forEach(set => {
                        totalSets++;
                        totalReps += set.reps || 0;
                        totalVolume += (set.weight || 0) * (set.reps || 0);
                        const weight = set.weight || 0;
                        if (weight < 50) weightDist.light++;
                        else if (weight <= 100) weightDist.medium++;
                        else weightDist.heavy++;
                    });
                }
                const exName = ex.name || 'Unknown';
                exerciseCount[exName] = (exerciseCount[exName] || 0) + (ex.sets ? ex.sets.length : 0);
            });
        }
    });
    
    const topExercise = Object.entries(exerciseCount).sort((a, b) => b[1] - a[1])[0] || ['Geen', 0];
    const avgReps = totalSets > 0 ? Math.round(totalReps / totalSets) : 0;
    const total = weightDist.light + weightDist.medium + weightDist.heavy;
    const weightDistribution = total > 0 ? {
        light: Math.round((weightDist.light / total) * 100),
        medium: Math.round((weightDist.medium / total) * 100),
        heavy: Math.round((weightDist.heavy / total) * 100)
    } : { light: 0, medium: 0, heavy: 0 };
    
    const hours = Math.floor(totalTime / 3600);
    const minutes = Math.floor((totalTime % 3600) / 60);
    const avgTime = history.length > 0 ? Math.round(totalTime / history.length / 60) : 0;
    const avgCalories = history.length > 0 ? Math.round(totalCalories / history.length) : 0;
    const frequency = Math.round((history.length / 7) * 10) / 10;
    
    // Progress
    let progress = 0;
    if (history.length > 1) {
        const mid = Math.floor(history.length / 2);
        const recent = history.slice(0, mid);
        const older = history.slice(mid);
        const recentAvg = recent.reduce((sum, w) => sum + (w.exercises ? w.exercises.reduce((s, ex) => s + (ex.sets ? ex.sets.reduce((ss, set) => ss + (set.weight * set.reps), 0) : 0), 0) : 0), 0) / recent.length;
        const olderAvg = older.reduce((sum, w) => sum + (w.exercises ? w.exercises.reduce((s, ex) => s + (ex.sets ? ex.sets.reduce((ss, set) => ss + (set.weight * set.reps), 0) : 0), 0) : 0), 0) / older.length;
        progress = olderAvg > 0 ? Math.round(((recentAvg - olderAvg) / olderAvg) * 100) : 0;
    }
    
    return {
        totalTime: { hours, minutes },
        totalCalories: Math.round(totalCalories),
        totalWorkouts: history.length,
        totalVolume: Math.round(totalVolume),
        longestStreak,
        progress,
        avgTime,
        avgCalories,
        frequency,
        totalSets,
        avgReps,
        topExercise: topExercise[0] + ' (' + topExercise[1] + ')',
        weightDistribution,
        durationBins,
        currentStreak,
        avgStreak,
        kcalPerMuscle
    };
}

function estimateCalories(workout) {
    const settings = getSettings();
    const met = settings.metValue || 4.5;
    const bodyWeight = settings.bodyWeight || 75;
    let calories = 0;
    const duration = (workout.duration || 0) / 60; // seconden naar minuten
    if (workout.exercises) {
        workout.exercises.forEach(ex => {
            if (ex.sets) {
                ex.sets.forEach(set => {
                    // MET based calculation: MET * weight * hours * adjustment factor
                    calories += (met * bodyWeight * (duration / workout.exercises.length / 60)) * 1.2;
                });
            }
        });
    }
    return Math.round(calories);
}

function renderVolumeChart(history) {
    const canvas = document.getElementById('volumeChart');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const selectedExercise = document.getElementById('exerciseSelector').value;
    const data = history.map(w => {
        let volume = 0;
        if (w.exercises) {
            w.exercises.forEach(ex => {
                if (selectedExercise === 'total' || ex.name === selectedExercise) {
                    if (ex.sets) ex.sets.forEach(set => volume += (set.weight || 0) * (set.reps || 0));
                }
            });
        }
        return { date: new Date(w.startTime), volume };
    }).sort((a, b) => a.date - b.date);
    
    // Simple line chart
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (data.length < 2) return;
    const maxVolume = Math.max(...data.map(d => d.volume));
    const minDate = data[0].date;
    const maxDate = data[data.length - 1].date;
    const dateRange = maxDate - minDate;
    
    ctx.beginPath();
    ctx.strokeStyle = '#007bff';
    ctx.lineWidth = 2;
    data.forEach((d, i) => {
        const x = 50 + ((d.date - minDate) / dateRange) * (canvas.width - 100);
        const y = canvas.height - 50 - (d.volume / maxVolume) * (canvas.height - 100);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // Axes labels
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    // Y-axis
    ctx.fillText('0', 5, canvas.height - 45);
    ctx.fillText(maxVolume.toFixed(0), 5, 15);
    // X-axis
    ctx.fillText(minDate.getMonth() + 1 + '/' + minDate.getDate(), 50, canvas.height - 5);
    ctx.fillText(maxDate.getMonth() + 1 + '/' + maxDate.getDate(), canvas.width - 100, canvas.height - 5);
}

function renderFrequencyChart(history, period) {
    const canvas = document.getElementById('frequencyChart');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Group by week or month
    const grouped = {};
    history.forEach(w => {
        const date = new Date(w.startTime);
        const key = period === 'week' ? date.getFullYear() + '-W' + Math.ceil((date.getDate() - date.getDay() + 1) / 7) : date.getFullYear() + '-' + date.getMonth();
        grouped[key] = (grouped[key] || 0) + 1;
    });
    const labels = Object.keys(grouped).sort().map(key => {
        if (period === 'week') {
            const [year, w] = key.split('-W');
            return 'W' + w + ' ' + year;
        } else {
            const [year, month] = key.split('-');
            const months = ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'];
            return months[parseInt(month)] + ' ' + year;
        }
    });
    const rawLabels = Object.keys(grouped).sort(); // for values
    const values = rawLabels.map(l => grouped[l]);
    
    // Bar chart
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const barWidth = (canvas.width - 100) / labels.length;
    const maxVal = Math.max(...values);
    values.forEach((v, i) => {
        const x = 50 + i * barWidth;
        const height = (v / maxVal) * (canvas.height - 100);
        const y = canvas.height - 50 - height;
        ctx.fillStyle = '#007bff';
        ctx.fillRect(x, y, barWidth - 5, height);
        // Label on bar
        ctx.fillStyle = '#fff';
        ctx.fillText(v.toString(), x + barWidth / 2 - 5, y - 5);
        // X label
        ctx.save();
        ctx.translate(x + barWidth / 2, canvas.height - 20);
        ctx.rotate(-Math.PI / 4);
        ctx.fillText(labels[i], 0, 0);
        ctx.restore();
    });
    // Y-axis
    ctx.fillStyle = '#fff';
    ctx.fillText('0', 5, canvas.height - 45);
    ctx.fillText(maxVal.toString(), 5, 55);
}

function renderDurationChart(durationBins) {
    const canvas = document.getElementById('durationChart');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const labels = Object.keys(durationBins);
    const values = Object.values(durationBins);
    const barWidth = (canvas.width - 100) / labels.length;
    const maxVal = Math.max(...values);
    values.forEach((v, i) => {
        const x = 50 + i * barWidth;
        const height = (v / maxVal) * (canvas.height - 100);
        const y = canvas.height - 50 - height;
        ctx.fillStyle = '#17a2b8';
        ctx.fillRect(x, y, barWidth - 5, height);
        ctx.fillStyle = '#fff';
        ctx.fillText(v.toString(), x + barWidth / 2 - 5, y - 5);
        ctx.fillText(labels[i], x + barWidth / 2 - 15, canvas.height - 20);
    });
    ctx.fillStyle = '#fff';
    ctx.fillText('0', 5, canvas.height - 45);
    ctx.fillText(maxVal.toString(), 5, 55);
}

function renderMuscleChart(history, kcalPerMuscle) {
    const canvas = document.getElementById('muscleChart');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const muscleCount = {};
    
    // Get all possible muscle groups from WORKOUT_DATA
    const allMuscles = new Set();
    WORKOUT_DATA.schemas.forEach(s => {
        s.muscleGroups.forEach(g => {
            allMuscles.add(g.name);
        });
    });
    
    // Count from history
    history.forEach(w => {
        if (w.exercises) {
            w.exercises.forEach(ex => {
                const muscle = ex.muscleGroup || 'Other';
                muscleCount[muscle] = (muscleCount[muscle] || 0) + (ex.sets ? ex.sets.length : 0);
            });
        }
    });
    
    // Ensure all muscles are included, even if 0
    allMuscles.forEach(m => {
        if (!(m in muscleCount)) muscleCount[m] = 0;
    });
    
    const total = Object.values(muscleCount).reduce((a, b) => a + b, 0);
    const colors = ['#ff6384', '#36a2eb', '#cc65fe', '#ffce56', '#4bc0c0', '#ff9f40', '#ff6384', '#c9cbcf'];
    let startAngle = 0;
    let i = 0;
    const legendItems = [];
    Object.entries(muscleCount).sort((a, b) => b[1] - a[1]).forEach(([muscle, count]) => {
        const sliceAngle = total > 0 ? (count / total) * 2 * Math.PI : 0;
        if (count > 0) {
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, canvas.height / 2);
            ctx.arc(canvas.width / 2, canvas.height / 2, 80, startAngle, startAngle + sliceAngle);
            ctx.closePath();
            ctx.fillStyle = colors[i % colors.length];
            ctx.fill();
        }
        legendItems.push({ color: count > 0 ? colors[i % colors.length] : '#ccc', label: muscle, percentage: total > 0 ? Math.round((count / total) * 100) : 0, kcal: Math.round(kcalPerMuscle[muscle] || 0) });
        startAngle += sliceAngle;
        i++;
    });
    
    // Add legend to the right
    const legendContainer = canvas.parentNode.querySelector('.chart-legend-list');
    legendContainer.innerHTML = ''; // Clear previous legend
    legendItems.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'legend-item';
        itemEl.innerHTML = '<span class="legend-color" style="background: ' + item.color + '"></span> ' + item.label + ' (' + item.percentage + '%)';
        legendContainer.appendChild(itemEl);
    });
}

// EXERCISES VIEW
function renderExercisesList() {
    const container = document.getElementById("exercisesList");
    if (!container) return;
    
    const customExercises = getCustomExercises();
    const allExercises = [];
    
    // Add standard exercises
    WORKOUT_DATA.schemas.forEach(schema => {
        schema.muscleGroups.forEach(group => {
            group.exercises.forEach(exercise => {
                allExercises.push({
                    ...exercise,
                    muscleGroup: group.name,
                    custom: false
                });
            });
        });
    });
    
    // Add custom exercises
    Object.values(customExercises).forEach(exercise => {
        allExercises.push({
            ...exercise,
            muscleGroup: exercise.muscleGroupName || exercise.muscleGroup || 'Onbekend',
            custom: true
        });
    });
    
    // Sort by name
    allExercises.sort((a, b) => a.name.localeCompare(b.name));
    
    if (allExercises.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"></div>
                <h3>Geen oefeningen</h3>
                <p>Er zijn geen oefeningen beschikbaar.</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = allExercises.map(exercise => `
        <div class="exercise-item" style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--dark-card); border-radius: 12px; margin-bottom: 0.5rem; border: 1px solid var(--border);">
            <div style="flex: 1;">
                <div style="font-weight: 600; color: var(--text);">
                    ${exercise.name} 
                    ${exercise.custom ? '<span style="color: var(--primary);">⚡ Eigen</span>' : ''}
                    ${exercise.videoUrl ? '<span style="color: var(--success); margin-left: 0.5rem;" title="Video beschikbaar">📹</span>' : ''}
                </div>
                <div style="font-size: 0.875rem; color: var(--text-muted);">${exercise.muscleGroup} • MET ${exercise.met.toFixed(1)}</div>
            </div>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
                ${exercise.videoUrl ? `
                <button class="btn-icon" onclick="openVideoModal('${exercise.name.replace(/'/g, "\\'")}', '${exercise.videoUrl}')" title="Bekijk video" style="background: none; border: none; color: var(--success); cursor: pointer; padding: 4px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="5 3 19 12 5 21 5 3"></polygon>
                    </svg>
                </button>` : ''}
                ${exercise.custom ? `
                <button class="btn-icon edit-btn" onclick="editCustomExercise(${exercise.id})" title="Bewerken" style="background: none; border: none; color: var(--primary); cursor: pointer; padding: 4px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                </button>
                <button class="btn-icon delete-btn" onclick="deleteCustomExercise(${exercise.id})" title="Verwijderen" style="background: none; border: none; color: var(--danger); cursor: pointer; padding: 4px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14M10 11v6m4-6v6"/>
                    </svg>
                </button>` : ''}
            </div>
        </div>
    `).join("");
}

function deleteCustomExercise(exerciseId) {
    if (!confirm('Weet je zeker dat je deze oefening wilt verwijderen?')) return;
    
    const custom = getCustomExercises();
    delete custom[exerciseId];
    saveCustomExercises(custom);
    renderExercisesList();
    showToast('Oefening verwijderd', 'success');
}

// PROGRESS VIEW
function renderProgress() {
    const container = document.getElementById("progressContainer");
    const history = getWorkoutHistory();
    if (!container) return;
    
    if (history.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"></div>
                <h3>Geen data</h3>
                <p>Importeer of voltooi workouts om progressie te zien.</p>
            </div>
        `;
        return;
    }
    
    // Verzamel schema's
    const schemas = [];
    const schemaMap = {};
    history.forEach(w => {
        if (!schemaMap[w.schemaId]) {
            schemaMap[w.schemaId] = { id: w.schemaId, name: w.schemaName };
            schemas.push(schemaMap[w.schemaId]);
        }
    });
    if (schemas.length === 0) {
        container.innerHTML = `<div class="empty-state"><div class="empty-state-icon"></div><h3>Geen schema's</h3><p>Workouts missen schema-informatie.</p></div>`;
        return;
    }
    
    // Default selectie
    if (!progressState.schemaId || !schemaMap[progressState.schemaId]) {
        progressState.schemaId = schemas[0].id;
    }
    
    // Exercises per schema
    const exerciseMap = {};
    history.filter(w => w.schemaId === progressState.schemaId).forEach(w => {
        w.exercises.forEach(ex => {
            if (!exerciseMap[ex.id]) {
                exerciseMap[ex.id] = { id: ex.id, name: ex.name };
            }
        });
    });
    const exercises = Object.values(exerciseMap);
    if (exercises.length === 0) {
        container.innerHTML = `<div class="empty-state"><div class="empty-state-icon"></div><h3>Geen oefeningen</h3><p>Geen oefeningen gevonden voor dit schema.</p></div>`;
        return;
    }
    if (!progressState.exerciseId || !exerciseMap[progressState.exerciseId]) {
        progressState.exerciseId = exercises[0].id;
    }
    
    container.innerHTML = `
        <div style="display:flex; gap:1rem; flex-wrap:wrap; margin-bottom:1rem;">
            <div style="flex:1; min-width:200px;">
                <label style="font-weight:700; display:block; margin-bottom:0.35rem;">Schema</label>
                <select id="progressSchemaSelect" style="width:100%; padding:0.65rem; border-radius:12px; border:1px solid var(--border); background:var(--dark-card); color:var(--text);">
                    ${schemas.map(s => `<option value="${s.id}" ${s.id === progressState.schemaId ? 'selected' : ''}>${s.name}</option>`).join('')}
                </select>
            </div>
            <div style="flex:1; min-width:200px;">
                <label style="font-weight:700; display:block; margin-bottom:0.35rem;">Oefening</label>
                <select id="progressExerciseSelect" style="width:100%; padding:0.65rem; border-radius:12px; border:1px solid var(--border); background:var(--dark-card); color:var(--text);">
                    ${exercises.map(ex => `<option value="${ex.id}" ${ex.id === progressState.exerciseId ? 'selected' : ''}>${ex.name}</option>`).join('')}
                </select>
            </div>
        </div>

        <div style="background:var(--dark-card); border:1px solid var(--border); border-radius:16px; padding:1rem; box-shadow:var(--shadow);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                <div>
                    <div style="font-weight:800;">Progressie</div>
                    <div style="color:var(--text-muted); font-size:0.9rem;">Gewicht (kg) over tijd</div>
                </div>
                <div id="progressLegend" style="color:var(--text-muted); font-size:0.9rem;"></div>
            </div>
            <div id="progressChart" style="width:100%; height:260px;">
                <div style="text-align:center; color:var(--text-muted); padding:2rem;">Grafiek wordt geladen…</div>
            </div>
        </div>
    `;
    
    document.getElementById('progressSchemaSelect').addEventListener('change', (e) => {
        progressState.schemaId = e.target.value;
        progressState.exerciseId = null;
        renderProgress();
    });
    document.getElementById('progressExerciseSelect').addEventListener('change', (e) => {
        progressState.exerciseId = parseInt(e.target.value, 10);
        updateProgressChart();
    });
    
    // Initial render
    updateProgressChart();
    
    // Add 1RM overview section
    renderOneRepMaxOverview(container, history, progressState.schemaId);
}

function updateProgressChart() {
    const container = document.getElementById('progressChart');
    const legend = document.getElementById('progressLegend');
    if (!container) return;
    const history = getWorkoutHistory();
    if (!progressState.schemaId || !progressState.exerciseId) {
        container.innerHTML = `<div style="text-align:center; color:var(--text-muted); padding:2rem;">Selecteer een schema en oefening.</div>`;
        return;
    }
    
    const points = [];
    history.filter(w => w.schemaId === progressState.schemaId).forEach(w => {
        const ex = w.exercises.find(e => e.id === progressState.exerciseId);
        if (!ex) return;
        let maxSet = ex.sets.reduce((best, s) => {
            const weight = parseFloat(s.weight || 0);
            const completed = !!s.completed;
            if (completed && weight > (best.weight || 0)) return { weight, reps: s.reps || 0 };
            if (!best.weight || weight > best.weight) return { weight, reps: s.reps || 0 };
            return best;
        }, { weight: 0, reps: 0 });
        points.push({
            date: new Date(w.startTime),
            weight: maxSet.weight || 0,
            reps: maxSet.reps || 0
        });
    });
    points.sort((a,b) => a.date - b.date);
    
    if (points.length === 0) {
        container.innerHTML = `<div style="text-align:center; color:var(--text-muted); padding:2rem;">Geen data voor deze oefening.</div>`;
        if (legend) legend.textContent = '';
        return;
    }
    
    // Probeer Chart.js, fallback naar SVG
    if (typeof Chart !== 'undefined') {
        createChartJsChart(container, points, legend);
    } else {
        createSVGChart(container, points, legend);
    }
}

// Global Chart instance tracker
let currentProgressChart = null;

function createChartJsChart(container, points, legend) {
    // Destroy vorige chart instance
    if (currentProgressChart) {
        currentProgressChart.destroy();
        currentProgressChart = null;
    }
    
    // Maak container leeg - ALTIJD
    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }
    
    const canvas = document.createElement('canvas');
    container.appendChild(canvas);
    
    const prs = getPRs();
    const pr = prs[progressState.exerciseId?.toString()] || null;
    const prWeight = pr?.weight || 0;
    
    const labels = points.map(p => {
        return `${p.date.getDate()}/${p.date.getMonth()+1}`;
    });
    const data = points.map(p => p.weight);
    
    // Bepaal welke punten PRs zijn
    const pointColors = points.map(p => p.weight >= prWeight && prWeight > 0 ? '#FFCC00' : '#4A90E2');
    
    currentProgressChart = new Chart(canvas, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Gewicht (kg)',
                data: data,
                borderColor: '#4A90E2',
                backgroundColor: 'rgba(74, 144, 226, 0.1)',
                borderWidth: 3,
                fill: true,
                pointRadius: 6,
                pointBackgroundColor: pointColors,
                pointBorderColor: pointColors,
                pointHoverRadius: 8,
                tension: 0.4,
                pointBorderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                y: {
                    beginAtZero: false,
                    ticks: {
                        color: 'var(--text-muted)',
                        callback: function(value) {
                            return value + 'kg';
                        }
                    },
                    grid: {
                        color: 'rgba(74, 144, 226, 0.1)'
                    }
                },
                x: {
                    ticks: {
                        color: 'var(--text-muted)'
                    },
                    grid: {
                        color: 'rgba(74, 144, 226, 0.05)'
                    }
                }
            }
        }
    });
    
    if (legend) {
        legend.innerHTML = prWeight > 0 ? `PR: ${prWeight}kg <span style="color:#FFCC00; margin-left:0.5rem;">★</span>` : '';
    }
}

function createSVGChart(container, points, legend) {
    // Destroy vorige chart instance als die bestaat
    if (currentProgressChart) {
        currentProgressChart.destroy();
        currentProgressChart = null;
    }
    
    // Maak container leeg - ALTIJD
    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }
    const weights = points.map(p => p.weight);
    const minY = Math.max(0, Math.min(...weights) - 5);
    const maxY = Math.max(...weights) + 5;
    const height = 200;
    const width = 100 * Math.max(points.length - 1, 1);
    const xStep = points.length > 1 ? width / (points.length - 1) : 0;
    
    const yScale = (w) => {
        if (maxY === minY) return height / 2;
        return height - ((w - minY) / (maxY - minY)) * height;
    };
    const xScale = (i) => i * xStep;
    
    const prs = getPRs();
    const pr = prs[progressState.exerciseId?.toString()] || null;
    const hasPR = !!pr;
    const prWeight = pr?.weight || 0;
    
    const polylinePoints = points.map((p,i) => `${xScale(i)},${yScale(p.weight)}`).join(' ');
    const circles = points.map((p,i) => {
        const isPR = hasPR && p.weight >= prWeight;
        return `<circle cx="${xScale(i)}" cy="${yScale(p.weight)}" r="4" fill="${isPR ? '#FFCC00' : '#4A90E2'}" stroke="${isPR ? '#F4C2A1' : 'none'}" />`;
    }).join('');
    
    const labels = points.map((p,i) => {
        const dateStr = `${p.date.getDate()}-${p.date.getMonth()+1}`;
        const isPR = hasPR && p.weight >= prWeight;
        return `<text x="${xScale(i)}" y="${yScale(p.weight)-10}" fill="${isPR ? '#FFCC00' : '#8E8E93'}" font-size="10" text-anchor="middle">${p.weight}kg</text>
                <text x="${xScale(i)}" y="${height+18}" fill="#8E8E93" font-size="10" text-anchor="middle">${dateStr}</text>`;
    }).join('');
    
    container.innerHTML = `
        <svg viewBox="0 0 ${width} ${height+30}" preserveAspectRatio="xMidYMax meet" style="width:100%; height:240px;">
            <polyline fill="none" stroke="#4A90E2" stroke-width="3" points="${polylinePoints}" stroke-linecap="round" stroke-linejoin="round"></polyline>
            ${circles}
            ${labels}
        </svg>
    `;
    if (legend) {
        document.body.classList.add('swipe-active');
        legend.innerHTML = hasPR ? `PR: ${prWeight}kg <span style="color:#FFCC00; margin-left:0.5rem;">★</span>` : '';
    }
}

// Calculate 1RM using Epley formula: weight * (1 + reps/30)
function calculateOneRepMax(weight, reps) {
    if (!weight || weight <= 0 || !reps || reps <= 0) return 0;
    return Math.round(weight * (1 + reps / 30));
}

function renderPRs() {
    const container = document.getElementById("prsContainer");
    const prs = getPRs();
    
    if (!container) return;
    
    // Convert PRs object to array
    const prArray = Object.values(prs).filter(pr => pr && pr.exerciseName);
    
    if (prArray.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 3rem 1rem; color: var(--text-muted);">
                <div style="font-size: 3rem; margin-bottom: 1rem;">🏆</div>
                <h3 style="margin-bottom: 0.5rem;">Nog geen PRs</h3>
                <p>Voltooi workouts om je persoonlijke records te vestigen!</p>
                <button onclick="switchView('workout')" style="margin-top: 1rem; padding: 0.75rem 1.5rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">
                    Start Workout
                </button>
            </div>
        `;
        return;
    }
    
    // Sort PRs based on selected criteria
    const sortBy = document.getElementById('prsSortSelect')?.value || 'date';
    prArray.sort((a, b) => {
        switch (sortBy) {
            case 'name':
                return a.exerciseName.localeCompare(b.exerciseName);
            case 'weight':
                return b.weight - a.weight;
            case 'onerm':
                return b.oneRM - a.oneRM;
            case 'date':
            default:
                return new Date(b.date) - new Date(a.date);
        }
    });
    
    container.innerHTML = `
        <div class="prs-grid">
            ${prArray.map(pr => `
                <div class="pr-card" onclick="showPRDetails('${pr.exerciseId}')">
                    <div class="pr-card-header">
                        <h3 class="pr-card-title">${pr.exerciseName}</h3>
                        <div class="pr-card-actions">
                            <button class="btn-icon" onclick="event.stopPropagation(); deletePR('${pr.exerciseId}')" title="Verwijder PR">
                                🗑️
                            </button>
                        </div>
                    </div>
                    <div class="pr-card-stats">
                        <div class="pr-card-stat">
                            <span class="pr-card-stat-value">${pr.weight}kg</span>
                            <span class="pr-card-stat-label">Gewicht</span>
                        </div>
                        <div class="pr-card-stat">
                            <span class="pr-card-stat-value">${pr.reps}</span>
                            <span class="pr-card-stat-label">Reps</span>
                        </div>
                        <div class="pr-card-stat">
                            <span class="pr-card-stat-value">${pr.oneRM.toFixed(1)}kg</span>
                            <span class="pr-card-stat-label">1RM</span>
                        </div>
                    </div>
                    <div class="pr-card-date">
                        ${formatPRDate(pr.date)}
                    </div>
                </div>
            `).join("")}
        </div>
    `;
}

function formatPRDate(dateString) {
    const date = new Date(dateString);
    const now = new Date();
    const diffTime = now - date;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    // If less than 7 days ago, show relative time
    if (diffDays === 0) {
        return 'Vandaag';
    } else if (diffDays === 1) {
        return 'Gisteren';
    } else if (diffDays < 7) {
        return `${diffDays} dagen geleden`;
    }
    
    // Otherwise show formatted date
    const day = date.getDate();
    const monthNames = ['jan.', 'feb.', 'mrt.', 'apr.', 'mei', 'jun.', 'jul.', 'aug.', 'sep.', 'okt.', 'nov.', 'dec.'];
    const month = monthNames[date.getMonth()];
    const year = date.getFullYear();
    
    // Show year only if not current year
    const currentYear = now.getFullYear();
    return year === currentYear ? `${day} ${month}` : `${day} ${month} ${year}`;
}

function showPRDetails(exerciseId) {
    const prs = getPRs();
    const pr = prs[exerciseId.toString()];
    
    if (!pr) {
        showToast("PR niet gevonden", "error");
        return;
    }
    
    // For now, just show a toast with PR details
    // In the future, this could open a detailed modal
    showToast(`🏆 ${pr.exerciseName}: ${pr.weight}kg × ${pr.reps} (${pr.oneRM.toFixed(1)}kg 1RM)`, "info");
}

function deletePR(exerciseId) {
    if (!confirm("Weet je zeker dat je deze PR wilt verwijderen?")) {
        return;
    }
    
    const prs = getPRs();
    delete prs[exerciseId.toString()];
    localStorage.setItem("workout_prs", JSON.stringify(prs));
    
    renderPRs();
    showToast("PR verwijderd", "success");
}

// GOALS MANAGEMENT
function getGoals() {
    const stored = localStorage.getItem("workout_goals");
    return stored ? JSON.parse(stored) : [];
}

function saveGoals(goals) {
    localStorage.setItem("workout_goals", JSON.stringify(goals));
}

function renderGoals() {
    const container = document.getElementById("goalsContainer");
    const goals = getGoals();
    
    if (!container) return;
    
    if (goals.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 3rem 1rem; color: var(--text-muted);">
                <div style="font-size: 3rem; margin-bottom: 1rem;">🎯</div>
                <h3 style="margin-bottom: 0.5rem;">Geen doelen ingesteld</h3>
                <p>Stel doelen om je motivatie te behouden en progressie bij te houden!</p>
                <button onclick="showAddGoalModal()" style="margin-top: 1rem; padding: 0.75rem 1.5rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">
                    Stel je eerste doel
                </button>
            </div>
        `;
        return;
    }
    
    const now = new Date();
    container.innerHTML = `
        <div class="goals-grid">
            ${goals.map(goal => {
                const progress = calculateGoalProgress(goal);
                const isCompleted = progress >= 100;
                const isOverdue = new Date(goal.deadline) < now && !isCompleted;
                const deadlineStr = formatGoalDeadline(goal.deadline);
                
                return `
                    <div class="goal-card ${isCompleted ? 'completed' : ''} ${isOverdue ? 'overdue' : ''}">
                        <div class="goal-card-header">
                            <h3 class="goal-card-title">${goal.title}</h3>
                            <div class="goal-card-actions">
                                <button class="btn-icon" onclick="event.stopPropagation(); editGoal('${goal.id}')" title="Bewerk doel">
                                    ✏️
                                </button>
                                <button class="btn-icon" onclick="event.stopPropagation(); deleteGoal('${goal.id}')" title="Verwijder doel">
                                    🗑️
                                </button>
                            </div>
                        </div>
                        <div class="goal-card-type">${goal.type}</div>
                        <div class="goal-card-progress">
                            <div class="goal-progress-bar">
                                <div class="goal-progress-fill" style="width: ${Math.min(progress, 100)}%"></div>
                            </div>
                            <div style="text-align: center; font-size: 0.9rem; color: var(--text-muted);">
                                ${progress.toFixed(1)}% voltooid
                            </div>
                        </div>
                        <div class="goal-card-stats">
                            <div class="goal-card-stat">
                                <span class="goal-card-stat-value">${goal.target}</span>
                                <span class="goal-card-stat-label">Doel</span>
                            </div>
                            <div class="goal-card-stat">
                                <span class="goal-card-stat-value">${goal.current || 0}</span>
                                <span class="goal-card-stat-label">Huidig</span>
                            </div>
                            <div class="goal-card-stat">
                                <span class="goal-card-stat-value">${goal.unit}</span>
                                <span class="goal-card-stat-label">Eenheid</span>
                            </div>
                        </div>
                        <div class="goal-card-deadline">
                            Deadline: ${deadlineStr}
                        </div>
                    </div>
                `;
            }).join("")}
        </div>
    `;
}

function calculateGoalProgress(goal) {
    if (!goal.current || !goal.target) return 0;
    return Math.min((goal.current / goal.target) * 100, 100);
}

function formatGoalDeadline(deadlineStr) {
    const deadline = new Date(deadlineStr);
    const now = new Date();
    const diffTime = deadline - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays < 0) {
        return `${Math.abs(diffDays)} dagen geleden`;
    } else if (diffDays === 0) {
        return 'Vandaag';
    } else if (diffDays === 1) {
        return 'Morgen';
    } else if (diffDays < 7) {
        return `Over ${diffDays} dagen`;
    } else {
        return deadline.toLocaleDateString('nl-NL', { 
            day: 'numeric', 
            month: 'long', 
            year: deadline.getFullYear() !== now.getFullYear() ? 'numeric' : undefined 
        });
    }
}

function showAddGoalModal() {
    // For now, show a simple prompt. In the future, this could be a full modal
    const title = prompt("Geef je doel een naam:", "Bench Press 100kg");
    if (!title || !title.trim()) return;
    
    const target = parseFloat(prompt("Wat is je doelwaarde?", "100"));
    if (!target || target <= 0) return;
    
    const unit = prompt("Eenheid (kg, reps, workouts, etc.):", "kg");
    if (!unit || !unit.trim()) return;
    
    const deadline = prompt("Deadline (YYYY-MM-DD):", new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]);
    if (!deadline) return;
    
    const goal = {
        id: `goal_${Date.now()}`,
        title: title.trim(),
        type: "Persoonlijk", // Could be expanded to different types
        target: target,
        current: 0,
        unit: unit.trim(),
        deadline: deadline,
        createdAt: new Date().toISOString()
    };
    
    const goals = getGoals();
    goals.push(goal);
    saveGoals(goals);
    
    renderGoals();
    showToast(`Doel "${goal.title}" toegevoegd!`, "success");
}

function editGoal(goalId) {
    const goals = getGoals();
    const goal = goals.find(g => g.id === goalId);
    if (!goal) return;
    
    const newCurrent = parseFloat(prompt(`Update huidige waarde voor "${goal.title}":`, goal.current || 0));
    if (newCurrent !== null && !isNaN(newCurrent)) {
        goal.current = newCurrent;
        saveGoals(goals);
        renderGoals();
        showToast("Doel bijgewerkt!", "success");
    }
}

function deleteGoal(goalId) {
    if (!confirm("Weet je zeker dat je dit doel wilt verwijderen?")) {
        return;
    }
    
    const goals = getGoals();
    const filtered = goals.filter(g => g.id !== goalId);
    saveGoals(filtered);
    
    renderGoals();
    showToast("Doel verwijderd", "success");
}

function renderAnalytics() {
    const container = document.getElementById("analyticsContainer");
    const periodDays = parseInt(document.getElementById('analyticsPeriodSelect')?.value || '30');
    const history = getWorkoutHistory();
    
    if (!container) return;
    
    // Filter history for the selected period
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - periodDays);
    const filteredHistory = history.filter(w => new Date(w.startTime) >= cutoffDate);
    
    if (filteredHistory.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 3rem 1rem; color: var(--text-muted);">
                <div style="font-size: 3rem; margin-bottom: 1rem;">📊</div>
                <h3 style="margin-bottom: 0.5rem;">Niet genoeg data</h3>
                <p>Voltooi meer workouts om analytics te zien!</p>
                <button onclick="switchView('workout')" style="margin-top: 1rem; padding: 0.75rem 1.5rem; background: var(--primary); color: white; border: none; border-radius: 8px; font-weight: 600;">
                    Start Workout
                </button>
            </div>
        `;
        return;
    }
    
    const analytics = calculateAnalytics(filteredHistory, cutoffDate);
    
    container.innerHTML = `
        <div class="analytics-insight">
            <div class="analytics-insight-title">💡 ${analytics.insight.title}</div>
            <div class="analytics-insight-text">${analytics.insight.description}</div>
        </div>
        
        <div class="analytics-grid">
            <div class="analytics-card">
                <div class="analytics-card-header">
                    <div class="analytics-card-icon">📅</div>
                    <h3 class="analytics-card-title">Workout Patronen</h3>
                </div>
                <div class="analytics-card-content">
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Beste dag</span>
                        <span class="analytics-metric-value">${analytics.bestDay}</span>
                    </div>
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Gemiddelde duur</span>
                        <span class="analytics-metric-value">${analytics.avgDuration} min</span>
                    </div>
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Meest getrainde spier</span>
                        <span class="analytics-metric-value">${analytics.topMuscleGroup}</span>
                    </div>
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Workout consistentie</span>
                        <span class="analytics-metric-value">${analytics.consistency}%</span>
                    </div>
                </div>
            </div>
            
            <div class="analytics-card">
                <div class="analytics-card-header">
                    <div class="analytics-card-icon">📈</div>
                    <h3 class="analytics-card-title">Progressie Trends</h3>
                </div>
                <div class="analytics-card-content">
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Volume trend</span>
                        <span class="analytics-metric-value">${analytics.volumeTrend > 0 ? '+' : ''}${analytics.volumeTrend.toFixed(1)}%</span>
                    </div>
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Nieuwe PRs</span>
                        <span class="analytics-metric-value">${analytics.newPRs}</span>
                    </div>
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Streak</span>
                        <span class="analytics-metric-value">${analytics.currentStreak} dagen</span>
                    </div>
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Workout kwaliteit</span>
                        <span class="analytics-metric-value">${analytics.qualityScore}/10</span>
                    </div>
                </div>
            </div>
            
            <div class="analytics-card">
                <div class="analytics-card-header">
                    <div class="analytics-card-icon">🎯</div>
                    <h3 class="analytics-card-title">Doelstellingen</h3>
                </div>
                <div class="analytics-card-content">
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Doelen behaald</span>
                        <span class="analytics-metric-value">${analytics.goalsAchieved}</span>
                    </div>
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Actieve doelen</span>
                        <span class="analytics-metric-value">${analytics.activeGoals}</span>
                    </div>
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Motivatie score</span>
                        <span class="analytics-metric-value">${analytics.motivationScore}/10</span>
                    </div>
                    <div class="analytics-metric">
                        <span class="analytics-metric-label">Voorspelde progressie</span>
                        <span class="analytics-metric-value">${analytics.predictedProgress > 0 ? '+' : ''}${analytics.predictedProgress.toFixed(1)}%</span>
                    </div>
                </div>
            </div>
            
            <div class="analytics-card">
                <div class="analytics-card-header">
                    <div class="analytics-card-icon">💪</div>
                    <h3 class="analytics-card-title">Spiergroep Balans</h3>
                </div>
                <div class="analytics-card-content">
                    ${analytics.muscleBalance.map(muscle => `
                        <div class="analytics-metric">
                            <span class="analytics-metric-label">${muscle.name}</span>
                            <span class="analytics-metric-value">${muscle.percentage}%</span>
                        </div>
                    `).join('')}
                </div>
            </div>
        </div>
        
        <div class="analytics-chart-container">
            <h3 style="margin-bottom: 1rem; color: var(--text);">Volume Ontwikkeling</h3>
            <div id="analyticsVolumeChart" style="width: 100%; height: 200px; background: var(--dark-card); border-radius: 8px; display: flex; align-items: center; justify-content: center; color: var(--text-muted);">
                📊 Grafiek wordt geladen...
            </div>
        </div>
    `;
    
    // Render volume chart
    renderVolumeChart(filteredHistory);
}

function calculateAnalytics(history, cutoffDate) {
    const now = new Date();
    
    // Workout patterns
    const dayCounts = {};
    const muscleCounts = {};
    let totalDuration = 0;
    let totalVolume = 0;
    let previousVolume = 0;
    
    history.forEach(workout => {
        const day = new Date(workout.startTime).toLocaleDateString('nl-NL', { weekday: 'long' });
        dayCounts[day] = (dayCounts[day] || 0) + 1;
        
        totalDuration += workout.duration || 0;
        
        workout.exercises.forEach(exercise => {
            const muscleGroup = exercise.muscleGroup || 'Onbekend';
            muscleCounts[muscleGroup] = (muscleCounts[muscleGroup] || 0) + 1;
            
            exercise.sets.forEach(set => {
                if (set.completed && set.weight && set.reps) {
                    totalVolume += set.weight * set.reps;
                }
            });
        });
    });
    
    // Calculate volume trend (compare first half vs second half)
    const midPoint = Math.floor(history.length / 2);
    const firstHalf = history.slice(0, midPoint);
    const secondHalf = history.slice(midPoint);
    
    firstHalf.forEach(w => {
        w.exercises.forEach(ex => {
            ex.sets.forEach(set => {
                if (set.completed && set.weight && set.reps) {
                    previousVolume += set.weight * set.reps;
                }
            });
        });
    });
    
    const volumeTrend = previousVolume > 0 ? ((totalVolume / previousVolume - 1) * 100) : 0;
    
    // Goals data
    const goals = getGoals();
    const activeGoals = goals.filter(g => !g.completed).length;
    const goalsAchieved = goals.filter(g => g.completed).length;
    
    // Calculate insights
    const bestDay = Object.keys(dayCounts).reduce((a, b) => dayCounts[a] > dayCounts[b] ? a : b, 'Geen data');
    const topMuscleGroup = Object.keys(muscleCounts).reduce((a, b) => muscleCounts[a] > muscleCounts[b] ? a : b, 'Geen data');
    const avgDuration = history.length > 0 ? Math.round(totalDuration / history.length) : 0;
    
    // Calculate consistency (workouts per week in period)
    const periodDays = parseInt(document.getElementById('analyticsPeriodSelect')?.value || '30');
    const expectedWorkouts = Math.ceil(periodDays / 7) * 3; // Assume 3 workouts per week
    const consistency = Math.min(Math.round((history.length / expectedWorkouts) * 100), 100);
    
    // Calculate muscle balance
    const totalExercises = Object.values(muscleCounts).reduce((sum, count) => sum + count, 0);
    const muscleBalance = Object.keys(muscleCounts)
        .map(name => ({
            name,
            percentage: Math.round((muscleCounts[name] / totalExercises) * 100)
        }))
        .sort((a, b) => b.percentage - a.percentage)
        .slice(0, 4); // Top 4 muscle groups
    
    // Calculate current streak
    let currentStreak = 0;
    const sortedHistory = [...history].sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
    const today = new Date().toDateString();
    let checkDate = new Date();
    
    for (let i = 0; i < 30; i++) { // Check last 30 days
        const checkDateStr = checkDate.toDateString();
        const hasWorkout = sortedHistory.some(w => new Date(w.startTime).toDateString() === checkDateStr);
        
        if (hasWorkout) {
            currentStreak++;
        } else if (checkDateStr !== today) {
            break; // Break on first missed day (not counting today)
        }
        
        checkDate.setDate(checkDate.getDate() - 1);
    }
    
    // Calculate quality score based on various factors
    const avgSetsPerWorkout = history.reduce((sum, w) => sum + w.exercises.reduce((s, e) => s + e.sets.length, 0), 0) / history.length;
    const prs = getPRs();
    const newPRs = Object.values(prs).filter(pr => {
        const prDate = new Date(pr.date);
        return prDate >= cutoffDate;
    }).length;
    
    const qualityScore = Math.min(Math.round(
        (avgSetsPerWorkout * 2) + // Sets per workout (max 10 sets = 20 points)
        (consistency / 10) + // Consistency (max 10 points)
        (newPRs * 2) + // New PRs (max 10 points)
        (currentStreak / 3) // Streak (max ~10 points)
    ), 10);
    
    // Calculate motivation score
    const motivationScore = Math.min(Math.round(
        (goalsAchieved * 2) + // Achieved goals
        (activeGoals) + // Active goals
        (consistency / 10) + // Consistency
        (qualityScore / 2) // Quality
    ), 10);
    
    // Calculate predicted progress
    const predictedProgress = volumeTrend > 0 ? volumeTrend * 0.8 : Math.abs(volumeTrend) * 0.5;
    
    // Generate insight
    let insight = { title: "Houd vol!", description: "Blijf consistent trainen voor de beste resultaten." };
    
    if (consistency >= 80) {
        insight = { title: "Uitstekende consistentie!", description: "Je traint regelmatig - dit leidt tot geweldige resultaten." };
    } else if (newPRs > 0) {
        insight = { title: "Nieuwe PRs behaald!", description: `Je hebt ${newPRs} nieuwe persoonlijke records gezet. Geweldig!` };
    } else if (volumeTrend > 10) {
        insight = { title: "Sterke progressie!", description: "Je volume neemt toe - je wordt sterker!" };
    } else if (currentStreak >= 7) {
        insight = { title: `Streak van ${currentStreak} dagen!`, description: "Je bent on fire - houd dit vast!" };
    }
    
    return {
        bestDay,
        avgDuration,
        topMuscleGroup,
        consistency,
        volumeTrend,
        newPRs,
        currentStreak,
        qualityScore,
        goalsAchieved,
        activeGoals,
        motivationScore,
        predictedProgress,
        muscleBalance,
        insight
    };
}

function renderVolumeChart(history) {
    const container = document.getElementById('analyticsVolumeChart');
    if (!container) return;
    
    // Simple volume over time visualization
    const volumes = history.map(workout => {
        let volume = 0;
        workout.exercises.forEach(exercise => {
            exercise.sets.forEach(set => {
                if (set.completed && set.weight && set.reps) {
                    volume += set.weight * set.reps;
                }
            });
        });
        return {
            date: new Date(workout.startTime),
            volume: volume
        };
    }).sort((a, b) => a.date - b.date);
    
    if (volumes.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: var(--text-muted);">Geen volume data beschikbaar</div>';
        return;
    }
    
    // Create simple bar chart
    const maxVolume = Math.max(...volumes.map(v => v.volume));
    const chartHeight = 150;
    
    container.innerHTML = `
        <div style="display: flex; align-items: end; justify-content: space-between; height: ${chartHeight}px; padding: 0 1rem;">
            ${volumes.slice(-10).map(v => { // Show last 10 workouts
                const height = maxVolume > 0 ? (v.volume / maxVolume) * chartHeight : 0;
                const dateStr = v.date.toLocaleDateString('nl-NL', { month: 'short', day: 'numeric' });
                return `
                    <div style="display: flex; flex-direction: column; align-items: center; flex: 1;">
                        <div style="width: 100%; max-width: 30px; height: ${height}px; background: var(--primary); border-radius: 4px 4px 0 0; margin-bottom: 0.5rem;" title="${v.volume}kg op ${dateStr}"></div>
                        <div style="font-size: 0.7rem; color: var(--text-muted); transform: rotate(-45deg); transform-origin: center; white-space: nowrap;">${dateStr}</div>
                    </div>
                `;
            }).join('')}
        </div>
    `;
}

// MOBILE ENHANCEMENTS
// Enhanced haptic feedback for iPhone 17 and modern devices
function hapticFeedback(pattern = [50]) {
    console.log('🔄 hapticFeedback called with pattern:', pattern);

    // Always show some visual feedback
    const hapticIndicator = document.createElement('div');
    hapticIndicator.style.cssText = `
        position: fixed;
        bottom: 120px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(74, 144, 226, 0.95);
        color: white;
        padding: 12px 20px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: bold;
        z-index: 10001;
        pointer-events: none;
        animation: fadeInOut 2s ease-in-out;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
    `;
    hapticIndicator.textContent = '🔄 Haptic Feedback';
    document.body.appendChild(hapticIndicator);

    setTimeout(() => {
        if (hapticIndicator.parentNode) {
            hapticIndicator.remove();
        }
    }, 2000);

    // Check if vibration is supported
    if ('vibrate' in navigator) {
        console.log('✅ Vibration API available');

        // Check for iOS devices (more flexible detection)
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const iOSVersion = navigator.userAgent.match(/OS (\d+)_/)?.[1];
        const isIOS17Plus = isIOS && iOSVersion && parseInt(iOSVersion) >= 17;

        // Check if running in PWA mode (required for iOS vibration)
        const isPWA = window.navigator.standalone === true ||
                     window.matchMedia('(display-mode: standalone)').matches ||
                     document.referrer.includes('android-app://') ||
                     window.location.search.includes('pwa=true');

        console.log('📱 iOS detected:', isIOS, 'iOS Version:', iOSVersion, 'iOS 17+:', isIOS17Plus, 'PWA mode:', isPWA);
        console.log('🌐 User Agent:', navigator.userAgent);

        try {
            let vibrationWorked = false;

            if (isIOS && !isPWA) {
                console.log('⚠️ iOS detected but not in PWA mode - trying vibration anyway');
                // Try vibration even outside PWA, some iOS versions allow it
                vibrationWorked = tryVibration(pattern);
            } else {
                // Try vibration in PWA mode or on other platforms
                vibrationWorked = tryVibration(pattern);
            }

            if (!vibrationWorked) {
                console.log('🔄 Vibration failed, using audio feedback');
                audioFeedback(pattern);
            }
        } catch (error) {
            console.error('❌ Vibration error:', error);
            audioFeedback(pattern);
        }
    } else {
        console.log('❌ Vibration API not available, using audio feedback');
        audioFeedback(pattern);
    }
}

// Try vibration and return success status
function tryVibration(pattern) {
    try {
        const result = navigator.vibrate(pattern);
        console.log('🎯 Vibration attempted, result:', result);
        return result !== false; // Some browsers return boolean
    } catch (error) {
        console.error('❌ Vibration failed:', error);
        return false;
    }
}

// Audio-based haptic feedback for when vibration doesn't work
function audioFeedback(pattern) {
    console.log('🔊 Using audio feedback for haptic simulation');

    // Check device type for different audio handling
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isAndroid = /Android/.test(navigator.userAgent);

    console.log('📱 Device detection - iOS:', isIOS, 'Android:', isAndroid);

    try {
        // Create a new audio context for immediate playback
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Different handling for different platforms
        if (isAndroid) {
            // Android is stricter - try a more aggressive approach
            console.log('🤖 Android detected - using aggressive audio approach');

            // Force resume and play immediately, don't wait for promise
            audioCtx.resume().then(() => {
                console.log('✅ Android audio context resumed');
                playAudioFeedback(audioCtx, pattern, true); // Pass flag for Android
            }).catch(error => {
                console.error('❌ Android audio resume failed:', error);
                // Try playing anyway
                playAudioFeedback(audioCtx, pattern, true);
            });

            // Also try playing immediately without waiting
            setTimeout(() => {
                if (audioCtx.state === 'running') {
                    playAudioFeedback(audioCtx, pattern, true);
                }
            }, 100);

        } else {
            // iOS and other platforms - standard approach
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    playAudioFeedback(audioCtx, pattern, false);
                }).catch(error => {
                    console.error('❌ Failed to resume audio context:', error);
                    // enhancedVisualFeedback(pattern); - REMOVED
                });
            } else {
                playAudioFeedback(audioCtx, pattern, false);
            }
        }

        function playAudioFeedback(ctx, pattern, isAndroid = false) {
            try {
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                // Different settings for Android vs iOS
                if (isAndroid) {
                    // Android: Higher frequency, louder, longer for better audibility
                    oscillator.frequency.setValueAtTime(400, ctx.currentTime);
                    oscillator.type = 'square'; // Square wave is more audible on Android
                    gainNode.gain.setValueAtTime(0, ctx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.5, ctx.currentTime + 0.01); // Much louder
                    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3); // Longer
                    oscillator.stop(ctx.currentTime + 0.3);
                } else {
                    // iOS: Original settings
                    oscillator.frequency.setValueAtTime(200, ctx.currentTime);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0, ctx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.2, ctx.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
                    oscillator.stop(ctx.currentTime + 0.15);
                }

                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);
                oscillator.start(ctx.currentTime);

                console.log(`✅ Audio feedback played (${isAndroid ? 'Android' : 'iOS'} mode)`);

                // Visual indicator removed - was causing layout issues

                // Clean up audio context
                setTimeout(() => {
                    ctx.close();
                }, 1000);
            } catch (error) {
                console.error('❌ Audio feedback failed:', error);
                // enhancedVisualFeedback(pattern); - REMOVED
            }
        }
    } catch (error) {
        console.error('❌ Audio feedback setup failed:', error);
        // enhancedVisualFeedback(pattern); - REMOVED
    }
}

// Enhanced visual feedback when other methods don't work - REMOVED ENTIRELY

// Dynamic Island support for iPhone 14 Pro+ workout timer
// Note: Dynamic Island is a native iOS feature, this is a visual simulation for demo purposes
function updateDynamicIsland() {
    if (!currentWorkout) return; // Early exit: no workout active

    // More flexible iOS detection
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isIOS17Plus = isIOS && /OS 1[7-9]|OS 2[0-9]/.test(navigator.userAgent);
    const isDynamicIslandDevice = isIOS && /iPhone1[4-9]|iPhone2[0-9]/.test(navigator.userAgent); // iPhone 14 Pro+

    // Skip all logic and logging for non-iOS devices to avoid console spam
    if (!isIOS) return;

    if (currentWorkout) {
        if (isDynamicIslandDevice && isIOS17Plus) {

            // Create or update visual Dynamic Island overlay
            let dynamicIsland = document.getElementById('dynamic-island-overlay');
            if (!dynamicIsland) {
                dynamicIsland = document.createElement('div');
                dynamicIsland.id = 'dynamic-island-overlay';
                dynamicIsland.style.cssText = `
                    position: fixed;
                    top: max(10px, env(safe-area-inset-top, 10px));
                    left: 50%;
                    transform: translateX(-50%);
                    width: 120px;
                    height: 35px;
                    background: rgba(0, 0, 0, 0.8);
                    border-radius: 20px;
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 12px;
                    color: white;
                    font-weight: 500;
                    backdrop-filter: blur(20px);
                    -webkit-backdrop-filter: blur(20px);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(dynamicIsland);
            }

            let content = '';
            if (timerRunning) {
                // Update Dynamic Island with timer progress
                const progress = Math.min(1, timerSeconds / (currentWorkout.targetDuration || 3600));
                const timeStr = formatDuration(timerSeconds);
                content = `⏱️ ${timeStr}`;
                console.log(`⏱️ Timer: ${timeStr} (${Math.round(progress * 100)}%)`);
            } else {
                // Update Dynamic Island with workout progress
                let totalSets = 0;
                let completedSets = 0;

                currentWorkout.exercises.forEach(ex => {
                    ex.sets.forEach(set => {
                        totalSets++;
                        if (set.completed) completedSets++;
                    });
                });

                const progress = totalSets > 0 ? completedSets / totalSets : 0;
                content = `💪 ${completedSets}/${totalSets}`;
                console.log(`💪 Workout: ${completedSets}/${totalSets} sets (${Math.round(progress * 100)}%)`);
            }

            dynamicIsland.textContent = content;
            dynamicIsland.style.display = 'flex';

            // Auto-hide after 3 seconds
            clearTimeout(dynamicIsland.hideTimeout);
            dynamicIsland.hideTimeout = setTimeout(() => {
                if (dynamicIsland) {
                    dynamicIsland.style.opacity = '0';
                    setTimeout(() => {
                        if (dynamicIsland) dynamicIsland.style.display = 'none';
                    }, 300);
                }
            }, 3000);

        } else {
            // Fallback: Show a notification-style Dynamic Island simulation (iOS devices only)
            let fallbackIsland = document.getElementById('dynamic-island-fallback');
            if (!fallbackIsland) {
                fallbackIsland = document.createElement('div');
                fallbackIsland.id = 'dynamic-island-fallback';
                fallbackIsland.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-weight: 500;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    animation: fadeInOut 2s ease-in-out;
                `;
                document.body.appendChild(fallbackIsland);
            }

            let content = '';
            if (timerRunning) {
                const timeStr = formatDuration(timerSeconds);
                content = `⏱️ ${timeStr}`;
            } else {
                let totalSets = 0;
                let completedSets = 0;

                currentWorkout.exercises.forEach(ex => {
                    ex.sets.forEach(set => {
                        totalSets++;
                        if (set.completed) completedSets++;
                    });
                });

                content = `💪 ${completedSets}/${totalSets}`;
            }

            fallbackIsland.textContent = content;
            fallbackIsland.style.display = 'block';

            // Auto-hide after 3 seconds
            clearTimeout(fallbackIsland.hideTimeout);
            fallbackIsland.hideTimeout = setTimeout(() => {
                if (fallbackIsland) {
                    fallbackIsland.style.opacity = '0';
                    setTimeout(() => {
                        if (fallbackIsland) fallbackIsland.style.display = 'none';
                    }, 500);
                }
            }, 3000);
        }
    }
}

// Check if app should prompt for PWA installation
function checkPWAInstall() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isPWA = window.navigator.standalone === true || window.matchMedia('(display-mode: standalone)').matches;

    if (isIOS && !isPWA && !localStorage.getItem('pwa-prompt-dismissed')) {
        // Show PWA install prompt for iOS
        setTimeout(() => {
            showPWAInstallPrompt();
        }, 3000); // Show after 3 seconds
    }
}

// Show PWA install prompt for iOS
function showPWAInstallPrompt() {
    const prompt = document.createElement('div');
    prompt.id = 'pwa-install-prompt';
    prompt.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 16px;
        border-radius: 12px;
        z-index: 10000;
        font-size: 14px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    `;

    prompt.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 12px;">
            <span style="font-size: 20px; margin-right: 8px;">📱</span>
            <strong>Installeer Gym Tracker</strong>
        </div>
        <p style="margin: 0 0 16px 0; line-height: 1.4;">
            Installeer deze app voor volledige functies zoals vibratie feedback en offline gebruik.
        </p>
        <div style="display: flex; gap: 8px;">
            <button onclick="installPWA()" style="flex: 1; background: #4A90E2; color: white; border: none; padding: 10px; border-radius: 8px; font-weight: 500;">
                Installeren
            </button>
            <button onclick="dismissPWAPrompt()" style="background: #666; color: white; border: none; padding: 10px; border-radius: 8px;">
                Later
            </button>
        </div>
    `;

    document.body.appendChild(prompt);
}

function installPWA() {
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

    if (isIOS) {
        // iOS PWA install instructions - more detailed
        const instructions = `
📱 iOS Installatie Instructies:

1. Tik op de "Delen" knop (rechtsboven) 
2. Scroll naar beneden en tik "Zet op beginscherm"
3. Tik "Toevoegen" in de popup
4. De app verschijnt nu op je homescreen

🔄 Herlaad deze pagina na installatie om vibratie te testen!
        `.trim();

        // Show detailed instructions
        if (confirm('Wil je gedetailleerde iOS installatie instructies zien?')) {
            alert(instructions);
        } else {
            showToast('📱 Tik Delen → Zet op beginscherm', 'info');
        }
    } else {
        // Try to trigger install prompt for other browsers
        if ('beforeinstallprompt' in window) {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.prompt();
            });
        }
        showToast('🔄 PWA installatie poging...', 'info');
    }

    dismissPWAPrompt();
}

function dismissPWAPrompt() {
    const prompt = document.getElementById('pwa-install-prompt');
    if (prompt) {
        prompt.remove();
        localStorage.setItem('pwa-prompt-dismissed', 'true');
    }
}

// Action Button support for iPhone 15 Pro+
// Note: Action Button is a native iOS feature, this is a simulation for demo purposes
function setupActionButton() {
    console.log('🔘 setupActionButton called');

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isIOS17Plus = isIOS && /OS 1[7-9]|OS 2[0-9]/.test(navigator.userAgent);

    console.log('📱 iOS detected:', isIOS, 'iOS 17+:', isIOS17Plus);

    if (isIOS17Plus) {
        console.log('🔘 Action Button setup requested (iOS 17+ detected)');
        console.log('🏋️‍♂️ Action: Start Quick Workout');

        // In a real implementation, this would configure the Action Button
        // For now, we'll just log the setup
    } else {
        console.log('ℹ️ Action Button not available (requires iOS 17+)');
    }
}

// Camera Control support for iPhone 15 Pro Max
// Note: Camera Control is a native iOS feature, this is a simulation for demo purposes
function setupCameraControl() {
    console.log('📷 setupCameraControl called');

    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    const isIOS17Plus = isIOS && /OS 1[7-9]|OS 2[0-9]/.test(navigator.userAgent);

    console.log('📱 iOS detected:', isIOS, 'iOS 17+:', isIOS17Plus);

    if (isIOS17Plus) {
        console.log('📷 Camera Control setup requested (iOS 17+ detected)');
        console.log('💪 Actions: Complete Set, Next Exercise');

        // In a real implementation, this would configure Camera Control
        // For now, we'll just log the setup
    } else {
        console.log('ℹ️ Camera Control not available (requires iOS 17+)');
    }
}

// Swipe gesture handling for set rows
function initSwipeGestures() {
    document.addEventListener('touchstart', handleTouchStart, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd, { passive: false });
}

let touchStartX = 0;
let touchStartY = 0;
let touchCurrentX = 0;
let touchCurrentY = 0;
let swipingElement = null;
let swipeThreshold = 80; // Minimum swipe distance

function handleTouchStart(e) {
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchCurrentX = touchStartX;
    touchCurrentY = touchStartY;
    
    // Find if we're touching a set row, but NOT if we're directly touching a checkbox
    const target = e.target.closest('.set-row');
    const isCheckbox = e.target.closest('.checkbox');
    
    if (target && !isCheckbox) {
        swipingElement = target;
        // Don't add swipe-active yet - wait for actual movement in handleTouchMove
        swipingElement.style.transition = 'none';
    }
}

function handleTouchMove(e) {
    if (!swipingElement) return;
    
    const touch = e.touches[0];
    touchCurrentX = touch.clientX;
    touchCurrentY = touch.clientY;
    
    const deltaX = touchCurrentX - touchStartX;
    const deltaY = touchCurrentY - touchStartY;
    
    // Only allow horizontal swipes (more horizontal than vertical movement)
    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 15) { // Increased threshold
        e.preventDefault();
        
        // Add swipe-active class only when we detect actual swipe movement
        if (!swipingElement.classList.contains('swipe-active')) {
            swipingElement.classList.add('swipe-active');
            document.body.classList.add('swipe-active');
        }
        
        // Limit swipe distance to prevent over-swiping
        const limitedDeltaX = Math.max(-120, Math.min(120, deltaX));
        swipingElement.style.transform = `translateX(${limitedDeltaX}px)`;
        
        // Enhanced visual feedback with opacity changes
        if (Math.abs(limitedDeltaX) > swipeThreshold) {
            if (limitedDeltaX > 0) {
                swipingElement.style.background = 'linear-gradient(90deg, rgba(74, 144, 226, 0.15) 0%, rgba(74, 144, 226, 0.05) 50%, transparent 100%)';
                swipingElement.style.borderLeft = '4px solid #4A90E2';
                swipingElement.style.borderRight = 'none';
            } else {
                swipingElement.style.background = 'linear-gradient(90deg, transparent 0%, rgba(255, 59, 48, 0.05) 50%, rgba(255, 59, 48, 0.15) 100%)';
                swipingElement.style.borderRight = '4px solid #FF3B30';
                swipingElement.style.borderLeft = 'none';
            }
        } else {
            swipingElement.style.background = '';
            swipingElement.style.borderLeft = '';
            swipingElement.style.borderRight = '';
        }
    }
}

function handleTouchEnd(e) {
    if (!swipingElement) return;
    
    const deltaX = touchCurrentX - touchStartX;
    const deltaY = touchCurrentY - touchStartY;
    
    // Reset visual feedback
    swipingElement.style.background = '';
    swipingElement.style.borderLeft = '';
    swipingElement.style.borderRight = '';
    swipingElement.style.transition = '';
    document.body.classList.remove('swipe-active');
    swipingElement.classList.remove('swipe-active');
    
    // Check if it's a valid swipe
    if (Math.abs(deltaX) > swipeThreshold && Math.abs(deltaX) > Math.abs(deltaY) * 2) { // More strict horizontal check
        const exerciseId = parseInt(swipingElement.dataset.exerciseId);
        const setIndex = parseInt(swipingElement.dataset.setIndex);
        
        if (deltaX > 0) {
            // Swipe right - complete set
            completeSetWithHaptic(exerciseId, setIndex);
        } else {
            // Swipe left - delete set
            deleteSetWithConfirmation(exerciseId, setIndex);
        }
    } else {
        // Not a valid swipe, reset position
        swipingElement.style.transform = '';
    }
    
    swipingElement = null;
}

function completeSetWithHaptic(exerciseId, setIndex) {
    const exercise = currentWorkout.exercises.find(ex => ex.id === exerciseId);
    if (!exercise) return;

    const set = exercise.sets[setIndex];
    if (!set.completed && (!set.reps || !set.weight)) {
        showToast("Vul eerst reps en gewicht in", "error");
        return;
    }

    set.completed = true;
    // hapticFeedback([30, 50, 30]); // Short vibration pattern - REMOVED
    // updateDynamicIsland(); // Update Dynamic Island with workout progress - REMOVED
    startRestTimer();
    checkAndShowPR(exercise, setIndex);
    focusOnTimer();
    renderExercises();
    updateStats();
    showToast("Set voltooid! 💪", "success");
}

function deleteSetWithConfirmation(exerciseId, setIndex) {
    if (confirm('Set verwijderen?')) {
        const exercise = currentWorkout.exercises.find(ex => ex.id === exerciseId);
        if (!exercise || exercise.sets.length <= 1) return;
        
        exercise.sets.splice(setIndex, 1);
        hapticFeedback([100]); // Longer vibration for deletion
        renderExercises();
        updateStats();
        showToast("Set verwijderd", "info");
    }
}

// Speech recognition for quick exercise adding
function initSpeechRecognition() {
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.log('Speech recognition not supported');
        return;
    }
    
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    
    recognition.lang = 'nl-NL'; // Dutch language
    recognition.continuous = false;
    recognition.interimResults = false;
    
    recognition.onresult = function(event) {
        const transcript = event.results[0][0].transcript.toLowerCase();
        console.log('Speech recognized:', transcript);
        
        // Try to match exercise names
        const matchedExercise = findExerciseBySpeech(transcript);
        if (matchedExercise) {
            addExerciseToWorkout(matchedExercise.id);
            hapticFeedback([50, 50, 50]);
            showToast(`"${matchedExercise.name}" toegevoegd! 🎤`, "success");
        } else {
            showToast(`"${transcript}" niet herkend. Probeer: bench press, squats, bicep curl`, "error");
        }
    };
    
    recognition.onend = function() {
        console.log('Speech recognition ended');
    };
    
    recognition.onerror = function(event) {
        console.error('Speech recognition error:', event.error);
        let errorMessage = "Spraakherkenning mislukt";
        
        switch(event.error) {
            case 'no-speech':
                errorMessage = "Geen spraak gedetecteerd";
                break;
            case 'audio-capture':
                errorMessage = "Microfoon toegang geweigerd";
                break;
            case 'not-allowed':
                errorMessage = "Microfoon toestemming nodig";
                break;
            case 'network':
                errorMessage = "Netwerk fout";
                break;
        }
        
        showToast(errorMessage, "error");
    };
    
    recognition.onstart = function() {
        console.log('Speech recognition started');
        showToast("Luistert... Spreek een oefening uit 🎤", "info");
    };
    
    // Make recognition globally available
    window.speechRecognition = recognition;
}

function findExerciseBySpeech(transcript) {
    // Common Dutch exercise name mappings - expanded list
    const exerciseMappings = {
        // Chest exercises
        'bench press': 'Chest Press',
        'bankdrukken': 'Chest Press',
        'bankdruk': 'Chest Press',
        'push up': 'Push-up',
        'pushup': 'Push-up',
        'push ups': 'Push-up',
        'opdrukken': 'Push-up',
        'opdruk': 'Push-up',
        'flyes': 'Flyes',
        'vlinders': 'Flyes',
        'butterfly': 'Flyes',
        'chest press': 'Chest Press',
        'borstpers': 'Chest Press',
        
        // Back exercises
        'pull down': 'Pull Down',
        'pull down': 'Pull Down',
        'rugtrekken': 'Pull Down',
        'rug trek': 'Pull Down',
        'seated row': 'Seated Row',
        'rijmachine': 'Seated Row',
        'one arm row': 'One Arm Row',
        'eenarmig roeien': 'One Arm Row',
        'een arm roeien': 'One Arm Row',
        
        // Shoulder exercises
        'shoulder press': 'Shoulder Press',
        'schouderdrukken': 'Shoulder Press',
        'schouderdruk': 'Shoulder Press',
        'front raise': 'Front Side Raise',
        'front raises': 'Front Side Raise',
        'voorste heffen': 'Front Side Raise',
        'side raise': 'Front Side Raise',
        'zijdse heffen': 'Front Side Raise',
        
        // Leg exercises
        'squat': 'Hack Squad',
        'squats': 'Hack Squad',
        'kniebuiging': 'Hack Squad',
        'knie buiging': 'Hack Squad',
        'leg press': 'Leg Press',
        'beenpers': 'Leg Press',
        'been pers': 'Leg Press',
        'leg curl': 'Leg Curl',
        'hamstring curl': 'Leg Curl',
        'hamstring': 'Leg Curl',
        'beenkrul': 'Leg Curl',
        'hack squat': 'Hack Squad',
        'hack squat': 'Hack Squad',
        
        // Arm exercises
        'bicep curl': 'Biceps Barbell Curl',
        'biceps curl': 'Biceps Barbell Curl',
        'bicep curls': 'Biceps Barbell Curl',
        'biceps curls': 'Biceps Barbell Curl',
        'bizep curl': 'Biceps Barbell Curl',
        'hammer curl': 'Hammer Curl DB',
        'hammer curls': 'Hammer Curl DB',
        'hamer curl': 'Hammer Curl DB',
        'french press': 'French Press',
        'french press': 'French Press',
        'triceps extension': 'Triceps Extension',
        'triceps extensions': 'Triceps Extension',
        'triceps': 'Triceps Extension',
        'incline curl': 'Incl. Dumbbell Curl',
        'incline curls': 'Incl. Dumbbell Curl',
        'schuin curl': 'Incl. Dumbbell Curl',
        'reverse curl': 'Reverse Curl',
        'reverse curls': 'Reverse Curl',
        'omgekeerde curl': 'Reverse Curl'
    };
    
    // Clean transcript
    const cleanTranscript = transcript.toLowerCase().trim();
    
    // Check for exact matches first
    for (const [key, value] of Object.entries(exerciseMappings)) {
        if (cleanTranscript.includes(key)) {
            // Find the actual exercise object
            const allExercises = getAllExercises();
            const exercise = Object.values(allExercises).find(ex => ex.name === value);
            if (exercise) return exercise;
        }
    }
    
    return null;
}

function startVoiceAdd() {
    if (window.speechRecognition) {
        window.speechRecognition.start();
        showToast("Luistert... Spreek een oefening uit 🎤", "info");
    } else {
        showToast("Spraakherkenning niet ondersteund op dit apparaat", "error");
    }
}

// Render 1RM overview for all exercises in the selected schema
function renderOneRepMaxOverview(container, history, schemaId) {
    const schemaWorkouts = history.filter(w => w.schemaId === schemaId);
    if (schemaWorkouts.length === 0) return;
    
    // Collect all exercises and their best 1RM
    const exerciseOneRMs = {};
    
    schemaWorkouts.forEach(workout => {
        workout.exercises.forEach(exercise => {
            if (!exerciseOneRMs[exercise.id]) {
                exerciseOneRMs[exercise.id] = {
                    id: exercise.id,
                    name: exercise.name,
                    best1RM: 0,
                    date: null
                };
            }
            
            // Find the best set in this workout
            exercise.sets.forEach(set => {
                if (set.completed && set.weight && set.reps) {
                    const oneRM = calculateOneRepMax(parseFloat(set.weight), parseInt(set.reps));
                    if (oneRM > exerciseOneRMs[exercise.id].best1RM) {
                        exerciseOneRMs[exercise.id].best1RM = oneRM;
                        exerciseOneRMs[exercise.id].date = new Date(workout.startTime);
                    }
                }
            });
        });
    });
    
    // Filter out exercises with no 1RM data
    const exercisesWithData = Object.values(exerciseOneRMs).filter(ex => ex.best1RM > 0);
    
    if (exercisesWithData.length === 0) return;
    
    // Sort by 1RM descending
    exercisesWithData.sort((a, b) => b.best1RM - a.best1RM);
    
    const oneRMSection = document.createElement('div');
    oneRMSection.style.cssText = `
        margin-top: 2rem;
        background: var(--dark-card);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: var(--shadow);
    `;
    
    oneRMSection.innerHTML = `
        <div style="margin-bottom: 1rem;">
            <div style="font-weight: 800; font-size: 1.1rem;">1 Rep Max Overzicht</div>
            <div style="color: var(--text-muted); font-size: 0.9rem;">Berekende maximale kracht per oefening</div>
        </div>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
            ${exercisesWithData.map(exercise => `
                <div style="background: var(--dark-elevated); border: 1px solid var(--border); border-radius: 12px; padding: 1rem;">
                    <div style="font-weight: 700; color: var(--text); margin-bottom: 0.5rem;">${exercise.name}</div>
                    <div style="font-size: 1.5rem; font-weight: 800; color: #4A90E2; margin-bottom: 0.25rem;">${exercise.best1RM.toFixed(1)} kg</div>
                    <div style="color: var(--text-muted); font-size: 0.8rem;">
                        ${exercise.date ? `Laatste update: ${exercise.date.toLocaleDateString('nl-NL')}` : ''}
                    </div>
                </div>
            `).join('')}
        </div>
    `;
    
    container.appendChild(oneRMSection);
}

// VIEW SWITCHING
function switchView(viewName) {
    currentView = viewName;
    
    // Update tabs
    document.querySelectorAll(".tab").forEach(tab => {
        tab.classList.toggle("active", tab.dataset.view === viewName);
    });
    
    // Update views
    document.querySelectorAll(".view").forEach(view => {
        view.classList.remove("active");
    });
    
    const viewMap = {
        "workout": "workoutView",
        "history": "historyView",
        "progress": "progressView",
        "prs": "prsView",
        "goals": "goalsView",
        "analytics": "analyticsView",
        "statistics": "statisticsView",
        "exercises": "exercisesView",
        "settings": "settingsView",
        "schemas": "schemasView",
        "beheer": "beheerView"
    };
    
    const targetViewId = viewMap[viewName];
    const targetEl = targetViewId ? document.getElementById(targetViewId) : null;
    if (targetEl && targetEl.classList) {
        targetEl.classList.add("active");
    } else {
        console.warn('switchView: target view not found', viewName, targetViewId);
    }
    
    // Render content
    if (viewName === "history") renderHistory();
    if (viewName === "statistics") renderStatistics();
    if (viewName === "progress") renderProgress();
    if (viewName === "prs") renderPRs();
    if (viewName === "goals") renderGoals();
    if (viewName === "analytics") renderAnalytics();
    if (viewName === "exercises") {
        renderExercisesList();
        document.getElementById("fabAddExercise").classList.add("visible");
        document.getElementById("fabVoiceAdd").classList.add("visible");
    } else if (viewName === "schemas") {
        // Render schema beheer UI when switching to schemas
        try { renderCustomSchemasList(); } catch (e) { console.warn('renderCustomSchemasList failed', e); }
    } else if (viewName === "beheer") {
        // Initialize beheer view with goals as default
        switchBeheerView('goals');
        initBeheerView();
    } else if (viewName !== "workout") {
        // Hide FAB unless in exercises view or workout view (workout view handles FAB in selectSchema)
        document.getElementById("fabAddExercise").classList.remove("visible");
        document.getElementById("fabVoiceAdd").classList.remove("visible");
    }
    if (viewName === "settings") updateSettingsUI();
}

function switchBeheerView(beheerViewName) {
    // Update beheer tabs
    document.querySelectorAll('.beheer-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    const activeTab = document.querySelector(`.beheer-tab[data-beheer-view="${beheerViewName}"]`);
    if (activeTab) {
        activeTab.classList.add('active');
        // Scroll to center the active tab
        scrollBeheerTabIntoView(activeTab);
        // Update indicator position
        updateBeheerTabIndicator(beheerViewName);
    }
    
    // Clear current content
    const beheerContent = document.querySelector('.beheer-content');
    if (!beheerContent) return;
    beheerContent.innerHTML = '';
    
    // Clone content from original view
    const sourceViewId = beheerViewName + 'View';
    const sourceView = document.getElementById(sourceViewId);
    if (sourceView) {
        const clonedContent = sourceView.cloneNode(true);
        // Remove the id to avoid duplicates
        clonedContent.removeAttribute('id');
        // Remove the view class to avoid conflicts
        clonedContent.classList.remove('view');
        beheerContent.appendChild(clonedContent);
        
        // Call appropriate render function
        switch (beheerViewName) {
            case 'goals':
                renderGoals();
                break;
            case 'statistics':
                renderStatistics();
                break;
            case 'exercises':
                renderExercisesList();
                document.getElementById("fabAddExercise").classList.add("visible");
                document.getElementById("fabVoiceAdd").classList.add("visible");
                break;
            case 'schemas':
                try { renderCustomSchemasList(); } catch (e) { console.warn('renderCustomSchemasList failed', e); }
                break;
        }
    }
}

// Scroll active tab into view smoothly
function scrollBeheerTabIntoView(activeTab) {
    const tabsContainer = document.querySelector('.beheer-tabs');
    if (!tabsContainer || !activeTab) return;
    
    const containerRect = tabsContainer.getBoundingClientRect();
    const tabRect = activeTab.getBoundingClientRect();
    
    const scrollLeft = tabsContainer.scrollLeft + tabRect.left - containerRect.left - (containerRect.width / 2) + (tabRect.width / 2);
    
    tabsContainer.scrollTo({
        left: scrollLeft,
        behavior: 'smooth'
    });
}

// Update the indicator position based on active tab
function updateBeheerTabIndicator(beheerViewName) {
    const indicator = document.querySelector('.beheer-tabs-indicator');
    const activeTab = document.querySelector(`.beheer-tab[data-beheer-view="${beheerViewName}"]`);
    
    if (!indicator || !activeTab) return;
    
    const tabs = document.querySelectorAll('.beheer-tab');
    const activeIndex = Array.from(tabs).indexOf(activeTab);
    
    if (activeIndex !== -1) {
        // Calculate position based on tab width and gap
        const tabWidth = activeTab.offsetWidth;
        const tabGap = 8; // 0.5rem = 8px
        const leftPosition = activeIndex * (tabWidth + tabGap) + 16; // 1rem padding = 16px
        
        indicator.style.width = `${tabWidth}px`;
        indicator.style.transform = `translateX(${leftPosition}px)`;
    }
}

// Initialize swipe functionality for beheer tabs
function initBeheerTabSwipe() {
    const tabsContainer = document.querySelector('.beheer-tabs');
    if (!tabsContainer) return;
    
    let startX = 0;
    let currentX = 0;
    let isDragging = false;
    
    tabsContainer.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        isDragging = true;
        tabsContainer.style.scrollBehavior = 'auto';
    });
    
    tabsContainer.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        currentX = e.touches[0].clientX;
        const diff = startX - currentX;
        
        if (Math.abs(diff) > 10) { // Minimum swipe distance
            e.preventDefault();
        }
    });
    
    tabsContainer.addEventListener('touchend', (e) => {
        if (!isDragging) return;
        isDragging = false;
        
        const diff = startX - currentX;
        const threshold = 50; // Minimum swipe distance to trigger tab change
        
        if (Math.abs(diff) > threshold) {
            const tabs = document.querySelectorAll('.beheer-tab');
            const activeTab = document.querySelector('.beheer-tab.active');
            const currentIndex = Array.from(tabs).indexOf(activeTab);
            
            let newIndex;
            if (diff > 0 && currentIndex < tabs.length - 1) {
                // Swipe left - next tab
                newIndex = currentIndex + 1;
            } else if (diff < 0 && currentIndex > 0) {
                // Swipe right - previous tab
                newIndex = currentIndex - 1;
            }
            
            if (newIndex !== undefined) {
                const newTab = tabs[newIndex];
                const newView = newTab.getAttribute('data-beheer-view');
                switchBeheerView(newView);
            }
        }
        
        tabsContainer.style.scrollBehavior = 'smooth';
        startX = 0;
        currentX = 0;
    });
}

// Initialize beheer tab functionality when beheer view is shown
    
    // Update indicator on window resize
    window.addEventListener('resize', () => {
        const activeTab = document.querySelector('.beheer-tab.active');
        if (activeTab) {
            const activeView = activeTab.getAttribute('data-beheer-view');
            updateBeheerTabIndicator(activeView);
        }
    });
function initBeheerView() {
    initBeheerTabSwipe();
    // Set initial indicator position
    updateBeheerTabIndicator('goals');
}

// Ensure a view is visible after full load (defensive, avoids black screen)
window.addEventListener('load', function() {
    try {
        const anyActive = document.querySelector('.view.active');
        if (!anyActive) {
            // Use currentView fallback or default to workout
            switchView(typeof currentView === 'string' ? currentView : 'workout');
        }
    } catch (e) {
        console.warn('Error ensuring active view on load', e);
        try { switchView('workout'); } catch (err) {}
    }
    
    // Initialize audio context on first user interaction to comply with autoplay policies
    let audioInitialized = false;
    function initAudioOnInteraction() {
        if (!audioInitialized) {
            initAudioContext();
            audioInitialized = true;
            // Remove listeners after first initialization
            document.removeEventListener('touchstart', initAudioOnInteraction);
            document.removeEventListener('click', initAudioOnInteraction);
            document.removeEventListener('keydown', initAudioOnInteraction);
        }
    }
    
    document.addEventListener('touchstart', initAudioOnInteraction, { once: false });
    document.addEventListener('click', initAudioOnInteraction, { once: false });
    document.addEventListener('keydown', initAudioOnInteraction, { once: false });
});

// BACKUP & IMPORT
function exportBackup() {
    const data = {
        workouts: getWorkoutHistory(),
        prs: getPRs(),
        settings: getSettings(),
        exportDate: new Date().toISOString()
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `gym-tracker-backup-${formatDate(new Date())}.json`;
    a.click();
    URL.revokeObjectURL(url);
    
    showToast("Backup gedownload!", "success");
}

function importBackup() {
    document.getElementById("importFileInput").click();
}

function handleImportFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        console.log("Import: File loaded, length:", e.target.result.length);
        console.log("Import: First 200 chars:", e.target.result.substring(0, 200));
        try {
            const data = JSON.parse(e.target.result);
            console.log("Import: JSON parsed successfully, keys:", Object.keys(data));
            
            if (data.workouts) localStorage.setItem("workout_history", JSON.stringify(data.workouts));
            if (data.prs) localStorage.setItem("workout_prs", JSON.stringify(data.prs));
            if (data.settings) localStorage.setItem("gym_settings", JSON.stringify(data.settings));
            
            showToast("Backup succesvol geïmporteerd!", "success");
            
            // Refresh views
            renderHistory();
            renderProgress();
            loadSettings();
        } catch (error) {
            console.error("Import error:", error);
            showToast("Ongeldige backup file", "error");
        }
    };
    reader.readAsText(file);
    
    // Reset input
    event.target.value = "";
}

// MODALS
function openModal(modalId) {
    document.getElementById(modalId).classList.add("active");
}

function closeModal(modalId) {
    document.getElementById(modalId).classList.remove("active");
}

// TOAST
function showToast(message, type = "success") {
    // Use enhanced toast for better UX
    showEnhancedToast(message, type);
    
    // Also update legacy toast for compatibility
    const legacyToast = document.getElementById("toast");
    if (legacyToast) {
        legacyToast.textContent = message;
        legacyToast.className = `toast ${type}`;
        legacyToast.classList.add("show");
        
        setTimeout(() => {
            legacyToast.classList.remove("show");
        }, 3000);
    }
}

// UTILITY
function formatDate(date) {
    const options = { day: "numeric", month: "long", year: "numeric" };
    return date.toLocaleDateString("nl-NL", options);
}

function formatTime(date) {
    return date.toLocaleTimeString("nl-NL", { hour: "2-digit", minute: "2-digit" });
}

function formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    if (hours > 0) {
        return `${hours}u ${minutes}m`;
    }
    return `${minutes}m`;
}

function loadSettings() {
    const settings = getSettings();
    const bodyWeightInput = document.getElementById("bodyWeightInput");
    const metValueInput = document.getElementById("metValueInput");
    const defaultSetsInput = document.getElementById("defaultSetsInput");

    if (bodyWeightInput) bodyWeightInput.value = settings.bodyWeight;
    if (metValueInput) metValueInput.value = (settings.metValue || 4.5).toFixed(1);
    if (defaultSetsInput) defaultSetsInput.value = settings.defaultSets;
}

// DARK MODE THEME MANAGEMENT
function loadTheme() {
    const savedTheme = localStorage.getItem('gym_theme') || 'dark';
    applyTheme(savedTheme === 'dark');
}

function applyTheme(isDarkMode) {
    document.body.classList.toggle('light-mode', !isDarkMode);
    updateThemeToggle(isDarkMode);
}

function toggleDarkMode() {
    const currentlyDark = !document.body.classList.contains('light-mode');
    const newIsDark = !currentlyDark; // flip
    applyTheme(newIsDark);
    localStorage.setItem('gym_theme', newIsDark ? 'dark' : 'light');
}

function setAppVersionLabel() {
    const versionElement = document.getElementById('appVersionText');
    if (versionElement) {
        versionElement.textContent = APP_VERSION;
    }
}

async function forceReload() {
    try {
        console.log("🔄 Force reload initiated...");
        const isSecure = (window.isSecureContext && (location.protocol === 'https:' || location.hostname === 'localhost'));
        if (!isSecure) {
            // Fallback: simple reload with cache-bust; avoids SecurityError on file://
            const url = new URL(location.href);
            url.searchParams.set("v", APP_VERSION);
            url.searchParams.set("t", Date.now().toString());
            location.replace(url.toString());
            return;
        }
        
        // Unregister service workers
        if ('serviceWorker' in navigator) {
            const registrations = await navigator.serviceWorker.getRegistrations();
            for (let registration of registrations) {
                await registration.unregister();
                console.log("🗑️ Service worker unregistered");
            }
        }
        
        // Clear caches
        if ('caches' in window) {
            const cacheNames = await caches.keys();
            await Promise.all(cacheNames.map(name => caches.delete(name)));
            console.log("🗑️ Caches cleared");
        }
        
        // Clear localStorage version to force re-initialization
        localStorage.removeItem("app_version");
        
        // Reload with cache bust
        const url = new URL(location.href);
        url.searchParams.set("v", APP_VERSION);
        url.searchParams.set("t", Date.now().toString());
        location.replace(url.toString());
        
    } catch (e) {
        console.error("⚠️ Force reload error:", e);
        // Fallback to simple reload
        location.reload();
    }
}

function toggleLogging() {
    const settings = getSettings();
    const newLoggingEnabled = !settings.loggingEnabled;
    settings.loggingEnabled = newLoggingEnabled;
    saveSettings(settings);
    updateLoggingToggle(newLoggingEnabled);
}

function toggleTestMode() {
    const settings = getSettings();
    const newTestMode = !settings.testMode;
    settings.testMode = newTestMode;
    saveSettings(settings);
    updateTestModeToggle(newTestMode);
}

function toggleVoiceRecognition() {
    const settings = getSettings();
    const newVoiceEnabled = !settings.voiceRecognitionEnabled;
    settings.voiceRecognitionEnabled = newVoiceEnabled;
    saveSettings(settings);
    updateVoiceRecognitionToggle(newVoiceEnabled);
    // Update FAB visibility
    updateVoiceFABVisibility(newVoiceEnabled);
}

function updateThemeToggle(isDarkMode) {
    const toggle = document.getElementById('themeToggle');
    if (toggle) {
        // active state indicates Dark Mode ON
        toggle.classList.toggle('active', isDarkMode);
    }
}

function updateLoggingToggle(isLoggingEnabled) {
    const toggle = document.getElementById('loggingToggle');
    if (toggle) {
        toggle.classList.toggle('active', isLoggingEnabled);
    }
    const logBtn = document.getElementById('showConsoleLogBtn');
 

function updateVoiceRecognitionToggle(isVoiceEnabled) {
    const toggle = document.getElementById('voiceRecognitionToggle');
    if (toggle) {
        toggle.classList.toggle('active', isVoiceEnabled);
    }
}   if (logBtn) {
        logBtn.style.display = isLoggingEnabled ? 'block' : 'none';
    }
}

function updateTestModeToggle(isTestMode) {
    const toggle = document.getElementById('testModeToggle');
    if (toggle) {
        toggle.classList.toggle('active', isTestMode);
    }
}

function updateVoiceRecognitionToggle(isVoiceEnabled) {
    const toggle = document.getElementById('voiceRecognitionToggle');
    if (toggle) {
        toggle.classList.toggle('active', isVoiceEnabled);
    }
}

function updateVoiceFABVisibility(isVisible) {
    const voiceFAB = document.getElementById('fabVoiceAdd');
    if (voiceFAB) {
        voiceFAB.style.display = isVisible ? 'flex' : 'none';
    }
}

function updateSettingsUI() {
    const settings = getSettings();
    const isDarkMode = !document.body.classList.contains('light-mode');
    
    // Update app version
    const versionEl = document.getElementById('appVersionText');
    if (versionEl) {
        versionEl.textContent = APP_VERSION;
    }
    
    // Update body weight input
    
    // Update voice recognition toggle
    updateVoiceRecognitionToggle(settings.voiceRecognitionEnabled);
    const bodyWeightInput = document.getElementById('bodyWeightInput');
    if (bodyWeightInput) {
        bodyWeightInput.value = settings.bodyWeight;
    }
    
    // Update default sets input
    const defaultSetsInput = document.getElementById('defaultSetsInput');
    if (defaultSetsInput) {
        defaultSetsInput.value = settings.defaultSets;
    }
    
    // Update theme toggle
    updateThemeToggle(isDarkMode);
    
    // Update logging toggle
    updateLoggingToggle(settings.loggingEnabled);
    
    // Update test mode toggle
    updateTestModeToggle(settings.testMode);
}

function updateBodyWeight(value) {
    const weight = Math.max(30, Math.min(200, parseInt(value) || 75));
    document.getElementById('bodyWeightInput').value = weight;
    const settings = getSettings();
    settings.bodyWeight = weight;
    saveSettings(settings);
}

function updateMETValue(value) {
    const met = Math.max(1.0, Math.min(15.0, parseFloat(value) || 4.5));
    document.getElementById('metValueInput').value = met.toFixed(1);
    const settings = getSettings();
    settings.metValue = met;
    saveSettings(settings);
}

function updateDefaultSets(value) {
    const sets = Math.max(1, Math.min(10, parseInt(value) || 3));
    document.getElementById('defaultSetsInput').value = sets;
    const settings = getSettings();
    settings.defaultSets = sets;
    saveSettings(settings);
}

// DATA EXPORT/IMPORT FUNCTIONS
function exportBackup() {
    try {
        const backup = {
            version: APP_VERSION,
            timestamp: new Date().toISOString(),
            data: {
                workout_history: getWorkoutHistory(),
                workout_prs: getPRs(),
                workout_goals: getGoals(),
                workout_templates: getWorkoutTemplates(),
                gym_custom_exercises: getCustomExercises(),
                gym_custom_schemas: getCustomSchemas(),
                gym_settings: getSettings()
            }
        };
        
        const dataStr = JSON.stringify(backup, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = `gym-tracker-backup-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        showToast("Backup geëxporteerd!", "success");
    } catch (error) {
        console.error("Export error:", error);
        showToast("Export mislukt: " + error.message, "error");
    }
}

// Export workouts to JSON for automation (default: last 180 days)
function exportWorkoutsJSON(rangeDays = 180) {
    try {
        const history = getWorkoutHistory();
        const cutoff = Date.now() - (rangeDays * 24 * 60 * 60 * 1000);

        const filtered = history.filter(w => {
            if (!w.startTime) return false;
            const ts = new Date(w.startTime).getTime();
            return !Number.isNaN(ts) && ts >= cutoff;
        });

        const workouts = filtered.map(w => {
            const exercises = (w.exercises || []).map(ex => ({
                id: ex.id || null,
                name: ex.name,
                muscleGroup: ex.muscleGroup || null,
                muscleGroupIcon: ex.muscleGroupIcon || null,
                sets: (ex.sets || []).map(set => ({
                    reps: set.reps,
                    weight: set.weight,
                    completed: !!set.completed
                }))
            }));

            const totalVolume = exercises.reduce((sum, ex) => sum + ex.sets.reduce((s, set) => s + ((Number(set.weight) || 0) * (Number(set.reps) || 0)), 0), 0);

            return {
                schemaId: w.schemaId || null,
                schemaName: w.schemaName || null,
                startTime: w.startTime || null,
                endTime: w.endTime || null,
                durationSeconds: w.duration || null,
                totalVolume,
                exercises
            };
        });

        const payload = {
            version: APP_VERSION,
            generatedAt: new Date().toISOString(),
            rangeDays,
            count: workouts.length,
            workouts
        };

        const dataStr = JSON.stringify(payload, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `gym-tracker-workouts-${rangeDays}d-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        showToast(`Workouts geëxporteerd (${workouts.length} items)`, "success");
    } catch (error) {
        console.error("Workout export error:", error);
        showToast("Export mislukt: " + error.message, "error");
    }
}

function importBackup() {
    const input = document.getElementById('importFileInput');
    if (input) {
        input.click();
    } else {
        showToast("Import functie niet beschikbaar", "error");
    }
}

function handleImportFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            const backup = JSON.parse(e.target.result);
            
            // Validate backup structure
            if (!backup.data || typeof backup.data !== 'object') {
                throw new Error("Ongeldige backup structuur");
            }
            
            // Confirm import
            if (!confirm("Weet je zeker dat je deze backup wilt importeren? Dit overschrijft al je huidige data!")) {
                return;
            }
            
            console.log('📥 Importing backup...', backup);
            
            // Import data - handle all possible data structures
            let itemsImported = 0;
            
            if (backup.data.workout_history && Array.isArray(backup.data.workout_history)) {
                localStorage.setItem("workout_history", JSON.stringify(backup.data.workout_history));
                console.log('✅ Imported workout_history:', backup.data.workout_history.length, 'workouts');
                itemsImported++;
            }
            
            if (backup.data.workout_prs && typeof backup.data.workout_prs === 'object') {
                localStorage.setItem("workout_prs", JSON.stringify(backup.data.workout_prs));
                console.log('✅ Imported workout_prs:', Object.keys(backup.data.workout_prs).length, 'PRs');
                itemsImported++;
            }
            
            if (backup.data.workout_goals) {
                localStorage.setItem("workout_goals", JSON.stringify(backup.data.workout_goals));
                console.log('✅ Imported workout_goals');
                itemsImported++;
            }
            
            if (backup.data.workout_templates) {
                localStorage.setItem("workout_templates", JSON.stringify(backup.data.workout_templates));
                console.log('✅ Imported workout_templates');
                itemsImported++;
            }
            
            if (backup.data.gym_custom_exercises) {
                localStorage.setItem("gym_custom_exercises", JSON.stringify(backup.data.gym_custom_exercises));
                console.log('✅ Imported gym_custom_exercises');
                itemsImported++;
            }
            
            if (backup.data.gym_custom_schemas) {
                localStorage.setItem("gym_custom_schemas", JSON.stringify(backup.data.gym_custom_schemas));
                console.log('✅ Imported gym_custom_schemas');
                itemsImported++;
            }
            
            if (backup.data.gym_settings) {
                localStorage.setItem("gym_settings", JSON.stringify(backup.data.gym_settings));
                console.log('✅ Imported gym_settings');
                itemsImported++;
            }
            
            console.log(`📦 Import complete: ${itemsImported} data types imported`);
            
            // Trigger cloud sync if enabled
            if (FirestoreSync.enabled) {
                console.log('☁️ Triggering cloud sync...');
                await FirestoreSync.uploadAllData();
            }
            
            showToast(`Backup geïmporteerd! (${itemsImported} items). App wordt herladen...`, "success");
            
            // Reload to refresh all UI
            setTimeout(() => {
                window.location.reload();
            }, 2000);
            
        } catch (error) {
            console.error("❌ Import error:", error);
            showToast("Import mislukt: " + error.message, "error");
        }
    };
    reader.readAsText(file);
}

// ============================================================================
// CLOUD SYNC FUNCTIONS
// ============================================================================

// Display current Sync Key in UI
function displaySyncKey() {
    const syncKeyInput = document.getElementById('syncKeyInput');
    if (syncKeyInput) {
        syncKeyInput.value = FirestoreSync.userId || 'Geen key actief';
    }
}

// Copy Sync Key to clipboard
function copySyncKey() {
    const syncKey = FirestoreSync.userId;
    if (!syncKey) {
        showToast('Geen Sync Key beschikbaar', 'error');
        return;
    }
    
    navigator.clipboard.writeText(syncKey).then(() => {
        showToast('Sync Key gekopieerd naar klembord!', 'success');
    }).catch(err => {
        // Fallback for older browsers
        const input = document.getElementById('syncKeyInput');
        input.select();
        document.execCommand('copy');
        showToast('Sync Key gekopieerd!', 'success');
    });
}

// Show dialog to change/enter Sync Key
function showChangeSyncKeyDialog() {
    const newKey = prompt(
        '🔑 Voer je Sync Key in van een ander device:\n\n' +
        'Let op: Dit overschrijft je huidige Sync Key!\n' +
        'Alle devices met dezelfde key delen data.\n\n' +
        'Huidige key: ' + (FirestoreSync.userId || 'geen'),
        ''
    );
    
    if (newKey && newKey.trim()) {
        changeSyncKey(newKey.trim());
    }
}

// Change Sync Key
async function changeSyncKey(newKey) {
    if (!newKey || newKey.length < 10) {
        showToast('Ongeldige Sync Key (minimaal 10 tekens)', 'error');
        return;
    }
    
    const oldKey = FirestoreSync.userId;
    
    // Confirm change
    if (!confirm(`Weet je zeker dat je wilt overschakelen naar deze Sync Key?\n\nOude key: ${oldKey}\nNieuwe key: ${newKey}\n\nJe huidige lokale data blijft behouden.`)) {
        return;
    }
    
    // Update user ID
    localStorage.setItem('firebase_user_id', newKey);
    FirestoreSync.userId = newKey;
    
    console.log('🔑 Sync Key changed:', oldKey, '→', newKey);
    
    // Update UI
    displaySyncKey();
    
    // If Cloud Sync is enabled, upload local data to new key
    if (FirestoreSync.enabled) {
        try {
            await FirestoreSync.uploadAllData();
            showToast('Sync Key gewijzigd! Lokale data geüpload naar nieuwe key.', 'success');
            
            // Re-setup realtime sync
            FirestoreSync.setupRealtimeSync();
        } catch (error) {
            showToast('Sync Key gewijzigd, maar upload mislukt: ' + error.message, 'error');
        }
    } else {
        showToast('Sync Key gewijzigd! Schakel Cloud Sync in om te synchroniseren.', 'success');
    }
}

// Generate new Sync Key
function generateNewSyncKey() {
    if (!confirm('⚠️ Weet je zeker dat je een NIEUWE Sync Key wilt genereren?\n\nDit betekent:\n✓ Je krijgt een nieuwe unieke key\n✓ Deze key werkt nog niet op je andere devices\n✗ Je verliest verbinding met je oude sync group\n\nTip: Gebruik alleen als je opnieuw wilt beginnen!')) {
        return;
    }
    
    // Generate new unique user ID
    const newKey = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    localStorage.setItem('firebase_user_id', newKey);
    FirestoreSync.userId = newKey;
    
    console.log('✨ New Sync Key generated:', newKey);
    
    // Update UI
    displaySyncKey();
    
    showToast('Nieuwe Sync Key gegenereerd! Kopieer deze naar je andere devices.', 'success');
}

// Toggle cloud sync on/off
async function toggleCloudSync(enabled) {
    const statusText = document.getElementById('cloudSyncStatusText');
    const manualSyncBtn = document.getElementById('manualSyncBtn');
    
    if (enabled) {
        // Show loading
        statusText.innerHTML = '⏳ Initialiseren...';
        
        const success = await FirestoreSync.enable();
        
        if (success) {
            statusText.innerHTML = '✅ Cloud Sync actief! Data wordt automatisch gesynchroniseerd tussen al je apparaten.';
            manualSyncBtn.disabled = false;
            showToast("Cloud Sync ingeschakeld!", "success");
        } else {
            // Revert toggle if failed
            document.getElementById('cloudSyncToggle').checked = false;
            statusText.innerHTML = '❌ Kan geen verbinding maken met Firebase. Check je internetverbinding.';
            showToast("Cloud Sync mislukt", "error");
        }
    } else {
        FirestoreSync.disable();
        statusText.innerHTML = 'ℹ️ Cloud Sync is uitgeschakeld. Zet aan voor automatische backup en sync tussen devices.';
        manualSyncBtn.disabled = true;
        showToast("Cloud Sync uitgeschakeld", "info");
    }
}

// Manual sync button
async function manualCloudSync() {
    const btn = document.getElementById('manualSyncBtn');
    const statusText = document.getElementById('cloudSyncStatusText');
    
    btn.disabled = true;
    btn.textContent = '⏳ Synchroniseren...';
    statusText.innerHTML = '⏳ Synchroniseren met cloud...';
    
    try {
        await FirestoreSync.uploadAllData();
        btn.textContent = '🔄 Handmatig Synchroniseren';
        btn.disabled = false;
        statusText.innerHTML = '✅ Laatste sync: ' + new Date().toLocaleTimeString('nl-NL');
        showToast("Gesynchroniseerd met cloud!", "success");
    } catch (error) {
        btn.textContent = '🔄 Handmatig Synchroniseren';
        btn.disabled = false;
        statusText.innerHTML = '❌ Sync mislukt: ' + error.message;
        showToast("Sync mislukt", "error");
    }
}

// Initialize cloud sync toggle on settings load
function initCloudSyncUI() {
    const cloudSyncToggle = document.getElementById('cloudSyncToggle');
    const manualSyncBtn = document.getElementById('manualSyncBtn');
    const statusText = document.getElementById('cloudSyncStatusText');
    
    if (cloudSyncToggle) {
        const syncEnabled = localStorage.getItem('cloud_sync_enabled') === 'true';
        cloudSyncToggle.checked = syncEnabled;
        
        if (syncEnabled) {
            manualSyncBtn.disabled = false;
            statusText.innerHTML = '✅ Cloud Sync actief! Data wordt automatisch gesynchroniseerd.';
        }
    }
    
    // Display current Sync Key
    displaySyncKey();
}

// Test function for rest timer overlay
function testRestTimerOverlay() {
    console.log("=== TESTING REST TIMER OVERLAY ===");

    // Check if elements exist
    const overlay = document.getElementById("restTimerOverlay");
    const progress = document.getElementById("restTimerProgress");
    const label = document.getElementById("restTimerLabel");

    console.log("Elements check:");
    console.log("- Overlay:", overlay);
    console.log("- Progress:", progress);
    console.log("- Label:", label);

    if (!overlay || !progress || !label) {
        console.error("CRITICAL: Some elements are missing!");
        return;
    }

    // Disable test mode for proper testing
    const settings = getSettings();
    if (settings.testMode) {
        settings.testMode = false;
        saveSettings(settings);
        updateTestModeToggle(false);
        console.log("Test mode disabled");
    }

    console.log("Starting 10-second test timer...");
    startRestTimer(10);
}

// Initialize on load
document.addEventListener("DOMContentLoaded", init);

// Sync timers when returning from background
function syncForegroundTimers() {
    syncTimerState();
    syncRestTimer();
}

document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
        syncForegroundTimers();
    }
});

window.addEventListener("focus", syncForegroundTimers);


// ===== ENHANCED UI/UX FUNCTIONS =====

/**
 * Apply staggered animations to list items for smooth loading
 */
function applyStaggeredAnimation(selector, delay = 100) {
    const elements = document.querySelectorAll(selector);
    elements.forEach((el, index) => {
        el.style.animationDelay = `${index * delay}ms`;
        el.classList.add('stagger-item');
    });
}

/**
 * Enhanced button feedback with haptic-like visual response
 */
function enhanceButtonFeedback(button) {
    if (!button) return;
    
    button.addEventListener('click', function(e) {
        // Add pressed state
        this.classList.add('btn-pressed');
        
        // Remove after animation
        setTimeout(() => {
            this.classList.remove('btn-pressed');
        }, 150);
        
        // Trigger haptic feedback if available
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
    });
}

/**
 * Smooth scroll to element with offset
 */
function smoothScrollTo(element, offset = 0) {
    if (!element) return;
    
    const elementPosition = element.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.pageYOffset - offset;
    
    window.scrollTo({
        top: offsetPosition,
        behavior: 'smooth'
    });
}

/**
 * Enhanced toast notifications with animations
 */
function showEnhancedToast(message, type = 'info', duration = 3000) {
    // Remove existing toasts
    const existingToasts = document.querySelectorAll('.toast');
    existingToasts.forEach(toast => toast.remove());
    
    // Create new toast
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.innerHTML = `
        <span class="toast-icon">${getToastIcon(type)}</span>
        <span class="toast-message">${message}</span>
    `;
    
    document.body.appendChild(toast);
    
    // Auto remove
    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

function getToastIcon(type) {
    const icons = {
        'success': '✅',
        'error': '❌',
        'warning': '⚠️',
        'info': 'ℹ️'
    };
    return icons[type] || icons.info;
}

/**
 * Loading state management
 */
function setLoadingState(element, loading = true) {
    if (!element) return;
    
    if (loading) {
        element.classList.add('loading');
        element.disabled = true;
        element.dataset.originalText = element.textContent;
        element.textContent = '⏳';
    } else {
        element.classList.remove('loading');
        element.disabled = false;
        if (element.dataset.originalText) {
            element.textContent = element.dataset.originalText;
        }
    }
}

/**
 * Progressive enhancement for modern browsers
 */
function applyProgressiveEnhancement() {
    // Check for modern features
    const supportsCSSGrid = CSS.supports('display', 'grid');
    const supportsFlexbox = CSS.supports('display', 'flex');
    const supportsBackdropFilter = CSS.supports('backdrop-filter', 'blur(10px)');
    
    document.documentElement.classList.add('enhanced-ui');
    
    if (supportsBackdropFilter) {
        document.documentElement.classList.add('backdrop-filter-supported');
    }
    
    // Add touch device detection
    if ('ontouchstart' in window) {
        document.documentElement.classList.add('touch-device');
    }
}

/**
 * Performance optimization: Debounce function calls
 */
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const context = this;
        const later = () => {
            clearTimeout(timeout);
            func.apply(context, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

/**
 * Enhanced form validation with visual feedback
 */
function enhanceFormValidation() {
    const inputs = document.querySelectorAll('input, select, textarea');
    
    inputs.forEach(input => {
        input.addEventListener('blur', function() {
            validateField(this);
        });
        
        input.addEventListener('input', debounce(function() {
            if (this.classList.contains('invalid')) {
                validateField(this);
            }
        }, 300));
    });
}

// Basic field validation used by enhanceFormValidation
function validateField(el) {
    if (!el) return;
    const value = (el.value ?? '').toString().trim();
    const isRequired = el.hasAttribute('required');
    let invalid = false;
    if (isRequired && value.length === 0) {
        invalid = true;
    }
    if (!invalid && el.type === 'number') {
        if (el.value !== '' && isNaN(Number(el.value))) {
            invalid = true;
        }
    }
    if (!invalid && el.pattern) {
        try {
            const re = new RegExp(el.pattern);
            if (!re.test(value)) invalid = true;
        } catch (e) { /* ignore invalid pattern */ }
    }
    el.classList.toggle('invalid', invalid);
}

// Test functions for debugging iOS 17+ features
function testHapticFeedback() {
    console.log('🧪 Testing haptic feedback...');

    // Create a prominent visual overlay for immediate feedback
    const overlay = document.createElement('div');
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(74, 144, 226, 0.3);
        z-index: 10000;
        pointer-events: none;
        animation: flash 0.3s ease-out;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

    const indicator = document.createElement('div');
    indicator.style.cssText = `
        background: rgba(255, 255, 255, 0.9);
        color: #4A90E2;
        padding: 20px 30px;
        border-radius: 15px;
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    `;
    indicator.textContent = '🔔 Testing Haptic Feedback...';
    overlay.appendChild(indicator);
    document.body.appendChild(overlay);

    // Remove overlay after animation
    setTimeout(() => {
        if (overlay.parentNode) {
            overlay.remove();
        }
    }, 600);

    // Check current PWA status
    const isPWA = window.navigator.standalone === true ||
                 window.matchMedia('(display-mode: standalone)').matches ||
                 document.referrer.includes('android-app://') ||
                 window.location.search.includes('pwa=true');

    console.log('🔍 PWA Status:', isPWA);
    console.log('🔍 navigator.standalone:', window.navigator.standalone);
    console.log('🔍 display-mode:', window.matchMedia('(display-mode: standalone)').matches);
    console.log('🔍 Vibration API available:', 'vibrate' in navigator);

    // Detailed diagnostic information
    const diagnostics = {
        userAgent: navigator.userAgent,
        isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
        iOSVersion: navigator.userAgent.match(/OS (\d+)_/)?.[1],
        isIOS17Plus: /iPad|iPhone|iPod/.test(navigator.userAgent) && /OS 1[7-9]|OS 2[0-9]/.test(navigator.userAgent),
        isDynamicIslandDevice: /iPad|iPhone|iPod/.test(navigator.userAgent) && /iPhone1[4-9]|iPhone2[0-9]/.test(navigator.userAgent),
        vibrationAPI: 'vibrate' in navigator,
        standalone: window.navigator.standalone === true,
        displayMode: window.matchMedia('(display-mode: standalone)').matches,
        referrer: document.referrer.includes('android-app://'),
        pwaParam: window.location.search.includes('pwa=true'),
        isPWA: isPWA
    };

    console.log('🔍 Detailed Diagnostics:', diagnostics);

    // Create diagnostic overlay
    const diagOverlay = document.createElement('div');
    diagOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 10002;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        font-family: monospace;
        font-size: 12px;
        color: white;
        overflow-y: auto;
        pointer-events: auto;
    `;

    const diagContent = document.createElement('div');
    diagContent.style.cssText = `
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 10px;
        max-width: 400px;
        width: 100%;
        max-height: 80vh;
        overflow-y: auto;
        pointer-events: auto;
    `;

    diagContent.innerHTML = `
        <h3 style="color: #4A90E2; margin-top: 0;">🔍 Haptic Diagnostics</h3>
        <div style="margin-bottom: 15px;">
            <strong>Device:</strong> ${diagnostics.isIOS ? 'iOS' : 'Other'}<br>
            <strong>iOS Version:</strong> ${diagnostics.iOSVersion || 'N/A'}<br>
            <strong>iOS 17+:</strong> ${diagnostics.isIOS17Plus ? '✅' : '❌'}<br>
            <strong>Dynamic Island:</strong> ${diagnostics.isDynamicIslandDevice ? '✅' : '❌'}<br>
        </div>
        <div style="margin-bottom: 15px;">
            <strong>Vibration API:</strong> ${diagnostics.vibrationAPI ? '✅' : '❌'}<br>
            <strong>PWA Mode:</strong> ${diagnostics.isPWA ? '✅' : '❌'}<br>
            <strong>Standalone:</strong> ${diagnostics.standalone ? '✅' : '❌'}<br>
            <strong>Display Mode:</strong> ${diagnostics.displayMode ? '✅' : '❌'}<br>
        </div>
        <div style="margin-bottom: 15px;">
            <strong>Fix voor vibratie:</strong><br>
            ${!diagnostics.isPWA && diagnostics.isIOS ? '📱 Installeer als PWA voor vibratie ondersteuning' :
              !diagnostics.vibrationAPI ? '❌ Dit apparaat ondersteunt geen vibratie' :
              diagnostics.isPWA && diagnostics.isIOS ? '⚠️ iOS PWA - vibratie kan beperkt zijn. Probeer Safari direct.' :
              '✅ Vibratie zou moeten werken'}
        </div>
        <div style="margin-bottom: 15px;">
            <strong>Fix voor Dynamic Island:</strong><br>
            ${!diagnostics.isIOS ? '📱 Vereist iOS apparaat (iPhone/iPad)' :
              !diagnostics.isIOS17Plus ? '📱 Vereist iOS 17+ (update je iOS)' :
              !diagnostics.isDynamicIslandDevice ? '📱 Vereist iPhone 14 Pro/15 Pro+ (met Dynamic Island)' :
              '✅ Dynamic Island visualisatie actief'}
        </div>
        <div style="margin-bottom: 15px;">
            <strong>Audio feedback:</strong><br>
            Als vibratie niet werkt, gebruikt de app audio feedback. Force Audio speelt altijd een luide piep af.<br>
            <small style="color:#ccc;">💡 Test de knoppen in deze volgorde: Force Visual → Force Audio → Test Simpele Vibratie</small>
        </div>
        <div style="margin-bottom: 15px;">
            <strong>Test opties:</strong><br>
            <button onclick="testSimpleVibration()" style="background:#9B59B6;color:white;border:none;padding:8px 12px;border-radius:5px;margin-right:8px;margin-bottom:5px;font-size:12px;min-width:120px;cursor:pointer;">Test Simpele Vibratie</button>
            <button onclick="forceAudioFeedback()" style="background:#F39C12;color:black;border:none;padding:8px 12px;border-radius:5px;margin-right:8px;margin-bottom:5px;font-size:12px;min-width:120px;cursor:pointer;">Force Audio</button>
            <button onclick="forceVisualFeedback()" style="background:#E74C3C;color:white;border:none;padding:8px 12px;border-radius:5px;margin-right:8px;margin-bottom:5px;font-size:12px;min-width:120px;cursor:pointer;">Force Visual</button>
            <button onclick="testAlternativeFeedback()" style="background:#27AE60;color:white;border:none;padding:8px 12px;border-radius:5px;margin-bottom:5px;font-size:12px;min-width:120px;cursor:pointer;">Alt Feedback</button>
        </div>
        ${!diagnostics.isPWA && diagnostics.isIOS ? '<button onclick="installPWA(); this.parentNode.parentNode.remove()" style="background:#E67E22;color:white;border:none;padding:10px 20px;border-radius:5px;margin-top:10px;">📱 Installeer PWA</button>' : ''}
        <button onclick="this.parentNode.parentNode.remove()" style="background:#4A90E2;color:white;border:none;padding:10px 20px;border-radius:5px;margin-top:10px;">Close</button>
    `;

    diagOverlay.appendChild(diagContent);
    document.body.appendChild(diagOverlay);

    hapticFeedback([100, 50, 100, 50, 100]);

    setTimeout(() => {
        showToast('🔔 Haptic test voltooid - check diagnostics', 'info');
    }, 500);
}

function testDynamicIsland() {
    console.log('🧪 Testing Dynamic Island...');

    // Create a prominent visual overlay for immediate feedback
    const overlay = document.createElement('div');
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(46, 204, 113, 0.3);
        z-index: 10000;
        pointer-events: none;
        animation: flash 0.3s ease-out;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

    const indicator = document.createElement('div');
    indicator.style.cssText = `
        background: rgba(255, 255, 255, 0.9);
        color: #2ECC71;
        padding: 20px 30px;
        border-radius: 15px;
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    `;
    indicator.textContent = '🏝️ Testing Dynamic Island...';
    overlay.appendChild(indicator);
    document.body.appendChild(overlay);

    // Remove overlay after animation
    setTimeout(() => {
        if (overlay.parentNode) {
            overlay.remove();
        }
    }, 600);

    updateDynamicIsland();

    // Show immediate feedback
    setTimeout(() => {
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isIOS17Plus = isIOS && /OS 1[7-9]|OS 2[0-9]/.test(navigator.userAgent);
        const isDynamicIslandDevice = isIOS && /iPhone1[4-9]|iPhone2[0-9]/.test(navigator.userAgent);

        if (isDynamicIslandDevice && isIOS17Plus) {
            showToast('🏝️ Dynamic Island test: Native simulatie actief', 'success');
        } else {
            showToast('🏝️ Dynamic Island test: Fallback notificatie actief', 'info');
        }
    }, 100);
}

function testSimpleVibration() {
    console.log('🧪 Testing simple vibration...');

    if ('vibrate' in navigator) {
        try {
            console.log('🎯 Attempting vibration...');

            // Try vibration with a longer duration for better feedback
            const result = navigator.vibrate([100, 50, 100, 50, 200]);
            console.log('🎯 Vibration result:', result);

            if (result !== false) {
                showToast('✅ Vibratie gevoeld! (patroon: kort-lang)', 'success');
            } else {
                showToast('❌ Vibratie geblokkeerd - mogelijk niet ondersteund', 'warning');
            }
        } catch (error) {
            console.error('❌ Vibration error:', error);
            showToast('❌ Vibratie fout: ' + error.message, 'error');
        }
    } else {
        showToast('❌ Dit apparaat heeft geen vibratie functie', 'error');
    }
}

function forceAudioFeedback() {
    console.log('🔊 Forcing audio feedback...');

    try {
        // Create a new audio context for immediate playback
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Resume if suspended (required for autoplay policies)
        if (audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
                playImmediateAudio(audioCtx);
            }).catch(error => {
                console.error('❌ Failed to resume audio context:', error);
                showToast('❌ Audio kon niet worden hervat', 'error');
            });
        } else {
            playImmediateAudio(audioCtx);
        }

        function playImmediateAudio(ctx) {
            try {
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();

                // High frequency beep for guaranteed audibility
                oscillator.frequency.setValueAtTime(800, ctx.currentTime);
                oscillator.type = 'square';

                // Very loud and long beep
                gainNode.gain.setValueAtTime(0, ctx.currentTime);
                gainNode.gain.linearRampToValueAtTime(1.0, ctx.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);

                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);

                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + 0.5);

                console.log('✅ Audio beep played');
                showToast('🔊 PIEP! Hoor je het harde geluid?', 'success');

                // Clean up
                setTimeout(() => {
                    ctx.close();
                }, 1000);
            } catch (error) {
                console.error('❌ Audio playback failed:', error);
                showToast('❌ Audio fout: ' + error.message, 'error');
            }
        }
    } catch (error) {
        console.error('❌ Audio context creation failed:', error);
        showToast('❌ Audio niet mogelijk op dit apparaat', 'error');
    }
}

function forceVisualFeedback() {
    console.log('💫 Forcing visual feedback...');

    // Create a prominent full-screen visual feedback overlay
    const visualOverlay = document.createElement('div');
    visualOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 193, 7, 0.6);
        z-index: 10000;
        pointer-events: none;
        animation: flash 0.6s ease-out;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

    const visualIndicator = document.createElement('div');
    visualIndicator.style.cssText = `
        background: rgba(255, 255, 255, 0.95);
        color: #F39C12;
        padding: 25px 35px;
        border-radius: 20px;
        font-size: 20px;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
        animation: bounceIn 0.4s ease-out;
    `;
    visualIndicator.textContent = '💫 VISUELE FEEDBACK!';
    visualOverlay.appendChild(visualIndicator);
    document.body.appendChild(visualOverlay);

    // Remove overlay after animation
    setTimeout(() => {
        if (visualOverlay.parentNode) {
            visualOverlay.remove();
        }
    }, 1000);

    // Create a visual vibration effect on the body
    const body = document.body;
    const originalTransform = body.style.transform || '';

    // More noticeable vibration animation
    body.style.transition = 'transform 0.08s ease-in-out';
    body.style.transform = originalTransform + ' translateX(5px) scale(1.03)';

    setTimeout(() => {
        body.style.transform = originalTransform + ' translateX(-5px) scale(1.01)';
    }, 80);

    setTimeout(() => {
        body.style.transform = originalTransform + ' translateX(3px) scale(1.02)';
    }, 160);

    setTimeout(() => {
        body.style.transform = originalTransform + ' translateX(-3px) scale(1.01)';
    }, 240);

    setTimeout(() => {
        body.style.transform = originalTransform;
        body.style.transition = '';
    }, 320);

function forceVisualFeedback() {
    console.log('💫 Forcing visual feedback...');

    // Create a prominent full-screen visual feedback overlay
    const visualOverlay = document.createElement('div');
    visualOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 193, 7, 0.8);
        z-index: 10000;
        pointer-events: none;
        animation: flash 0.8s ease-out;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

    const visualIndicator = document.createElement('div');
    visualIndicator.style.cssText = `
        background: rgba(255, 255, 255, 0.95);
        color: #F39C12;
        padding: 30px 40px;
        border-radius: 25px;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        animation: bounceIn 0.5s ease-out;
        border: 4px solid #F39C12;
    `;
    visualIndicator.textContent = '💫 SCHERM TRILT!';
    visualOverlay.appendChild(visualIndicator);
    document.body.appendChild(visualOverlay);

    // Remove overlay after animation
    setTimeout(() => {
        if (visualOverlay.parentNode) {
            visualOverlay.remove();
        }
    }, 1200);

    // Create a more intense visual vibration effect on the body
    const body = document.body;
    const originalTransform = body.style.transform || '';

    // More intense vibration animation sequence
    const vibrateSequence = [
        { transform: 'translateX(8px) scale(1.05)', duration: 60 },
        { transform: 'translateX(-8px) scale(1.03)', duration: 60 },
        { transform: 'translateX(6px) scale(1.04)', duration: 60 },
        { transform: 'translateX(-6px) scale(1.02)', duration: 60 },
        { transform: 'translateX(4px) scale(1.03)', duration: 60 },
        { transform: 'translateX(-4px) scale(1.01)', duration: 60 },
        { transform: 'translateX(2px) scale(1.02)', duration: 60 },
        { transform: originalTransform, duration: 60 }
    ];

    body.style.transition = 'transform 0.06s ease-in-out';

    let delay = 0;
    vibrateSequence.forEach((step, index) => {
        setTimeout(() => {
            body.style.transform = originalTransform + ' ' + step.transform;
        }, delay);
        delay += step.duration;
    });

    // Reset after sequence
    setTimeout(() => {
        body.style.transform = originalTransform;
        body.style.transition = '';
    }, delay + 100);

    showToast('💫 Visuele feedback: scherm trilt!', 'warning');
}

function testAlternativeFeedback() {
    console.log('🔄 Testing alternative feedback methods...');

    // Test Notification API for sound
    if ('Notification' in window) {
        console.log('🔔 Notification API available');

        if (Notification.permission === 'granted') {
            // Try to play a system sound via notification
            try {
                const notification = new Notification('Test', {
                    body: 'Testing alternative feedback',
                    icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTI0IDEySDh2NmgyVjEyek0xNiA5YzEuMSAwIDIgLjkgMiAydjJjMCAxLjEtLjkgMi0yIDJzLTEtLjktMi0ydi0yYzAtMS4xLjktMiAyLTJzMi45LTIgMiAyIDIgMnYyYzAgMS4xLS45IDItMiAyUzE0IDEwLjEgMTQgOXoiIGZpbGw9IiM0QTkwRTIiLz4KPC9zdmc+',
                    silent: false
                });

                setTimeout(() => {
                    notification.close();
                }, 1000);

                showToast('🔔 Notification geluid getest', 'info');
            } catch (error) {
                console.error('❌ Notification error:', error);
                showToast('❌ Notification fout', 'error');
            }
        } else if (Notification.permission !== 'denied') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    showToast('🔔 Notification toestemming verleend', 'success');
                } else {
                    showToast('❌ Notification geweigerd', 'error');
                }
            });
        } else {
            showToast('❌ Notification geblokkeerd', 'error');
        }
    } else {
        console.log('❌ Notification API not available');
        showToast('❌ Notification API niet beschikbaar', 'error');
    }

    // Test Web Audio API with different approach
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Create a more noticeable sound
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filterNode = audioContext.createBiquadFilter();

        oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // Higher frequency for more noticeable sound
        oscillator.type = 'square'; // Square wave for more tactile feel

        filterNode.type = 'lowpass';
        filterNode.frequency.setValueAtTime(1000, audioContext.currentTime);

        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);

        oscillator.connect(filterNode);
        filterNode.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);

        setTimeout(() => {
            audioContext.close();
        }, 500);

        console.log('✅ Alternative audio feedback played');
        showToast('🔊 Alternatieve audio feedback', 'info');
    } catch (error) {
        console.error('❌ Alternative audio error:', error);
        showToast('❌ Audio fout: ' + error.message.substring(0, 50), 'error');
    }
}
}

/**
 * Initialize all UI enhancements
 */
function initUIEnhancements() {
    applyProgressiveEnhancement();
    enhanceFormValidation();
    
    // Enhance all buttons
    document.querySelectorAll('.btn, button').forEach(btn => {
        enhanceButtonFeedback(btn);
    });
    
    // Apply staggered animations to key lists
    applyStaggeredAnimation('.stat-card');
    applyStaggeredAnimation('.pr-card');
    applyStaggeredAnimation('.history-item');
    applyStaggeredAnimation('.exercise-item');
}

// Call enhancements after DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(initUIEnhancements, 100); // Small delay to ensure all elements are rendered
});
</script>
</body>
</html>
